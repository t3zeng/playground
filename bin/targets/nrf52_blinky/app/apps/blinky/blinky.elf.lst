
/Users/tianzeng/Documents/workspace/playground/bin/targets/nrf52_blinky/app/apps/blinky/blinky.elf:     file format elf32-littlearm
/Users/tianzeng/Documents/workspace/playground/bin/targets/nrf52_blinky/app/apps/blinky/blinky.elf
architecture: armv7e-m, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x0000c121

Program Header:
0x70000001 off    0x00011ba0 vaddr 0x00011ba0 paddr 0x00011ba0 align 2**2
         filesz 0x00000018 memsz 0x00000018 flags r--
    LOAD off    0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**16
         filesz 0x00011bb8 memsz 0x00011bb8 flags rwx
    LOAD off    0x00020100 vaddr 0x20000100 paddr 0x00011bb8 align 2**16
         filesz 0x00000060 memsz 0x00002314 flags rw-
    LOAD off    0x00030000 vaddr 0x20000000 paddr 0x20000000 align 2**16
         filesz 0x00000000 memsz 0x00000100 flags rw-
private flags = 5000200: [Version5 EABI] [soft-float ABI]

Sections:
Idx Name               Size      VMA       LMA       File off  Algn  Flags
  0 .imghdr            00000020  0000c000  0000c000  0000c000  2**0  ALLOC
  1 .text              00005b80  0000c020  0000c020  0000c020  2**2  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .ARM.extab         00000000  00011ba0  00011ba0  00020160  2**0  CONTENTS
  3 .ARM.exidx         00000018  00011ba0  00011ba0  00011ba0  2**2  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .vector_relocation 00000100  20000000  20000000  00030000  2**0  ALLOC
  5 .rtt               00000000  20000100  20000100  00020160  2**0  CONTENTS
  6 .data              00000060  20000100  00011bb8  00020100  2**2  CONTENTS, ALLOC, LOAD, DATA
  7 .bssnz             00000000  20000160  20000160  00020160  2**0  CONTENTS
  8 .bss               000022b4  20000160  00011c18  00020160  2**3  ALLOC
  9 .stack_dummy       000001b0  20002418  20002418  00020160  2**3  CONTENTS, READONLY
 10 .ARM.attributes    0000002a  00000000  00000000  00020310  2**0  CONTENTS, READONLY
 11 .comment           00000079  00000000  00000000  0002033a  2**0  CONTENTS, READONLY
 12 .svc_table         00000004  00000000  00000000  000203b3  2**0  CONTENTS, READONLY
 13 .debug_line        0001ef58  00000000  00000000  000203b7  2**0  CONTENTS, READONLY, DEBUGGING
 14 .debug_info        000412d0  00000000  00000000  0003f30f  2**0  CONTENTS, READONLY, DEBUGGING
 15 .debug_abbrev      0000a022  00000000  00000000  000805df  2**0  CONTENTS, READONLY, DEBUGGING
 16 .debug_aranges     00001598  00000000  00000000  0008a608  2**3  CONTENTS, READONLY, DEBUGGING
 17 .debug_str         00006d06  00000000  00000000  0008bba0  2**0  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc         000144d6  00000000  00000000  000928a6  2**0  CONTENTS, READONLY, DEBUGGING
 19 .debug_ranges      00001798  00000000  00000000  000a6d7c  2**0  CONTENTS, READONLY, DEBUGGING
 20 .debug_frame       00003870  00000000  00000000  000a8514  2**2  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
0000c000 l    d  .imghdr	00000000 .imghdr
0000c020 l    d  .text	00000000 .text
00011ba0 l    d  .ARM.extab	00000000 .ARM.extab
00011ba0 l    d  .ARM.exidx	00000000 .ARM.exidx
20000000 l    d  .vector_relocation	00000000 .vector_relocation
20000100 l    d  .rtt	00000000 .rtt
20000100 l    d  .data	00000000 .data
20000160 l    d  .bssnz	00000000 .bssnz
20000160 l    d  .bss	00000000 .bss
20002418 l    d  .stack_dummy	00000000 .stack_dummy
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .svc_table	00000000 .svc_table
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 gcc_startup_cm4.o
000001b0 l       *ABS*	00000000 Stack_Size
00000000 l       *ABS*	00000000 Heap_Size
0000c128 l       .text	00000000 .bss_zero_loop
00000000 l    df *ABS*	00000000 hal_system.c
00000000 l    df *ABS*	00000000 system_nrf52.c
0000c228 l     F .text	00000024 errata_36
0000c24c l     F .text	00000024 errata_98
0000c270 l     F .text	00000024 errata_103
0000c294 l     F .text	00000024 errata_115
0000c2b8 l     F .text	00000024 errata_120
0000c2dc l     F .text	00000024 errata_121
00000000 l    df *ABS*	00000000 start.c
00000000 l    df *ABS*	00000000 main.c
20000160 l     O .bss	00000004 g_task1_loops
00000000 l    df *ABS*	00000000 nrf52_blinky-sysinit-app.c
00000000 l    df *ABS*	00000000 bus.c
20000164 l     O .bss	00000004 g_bus_node_lock_timeout
00000000 l    df *ABS*	00000000 cmsis_nvic.c
00000000 l    df *ABS*	00000000 sbrk.c
20000168 l     O .bss	00000004 brk
2000016c l     O .bss	00000004 sbrk_base
20000170 l     O .bss	00000004 sbrk_limit
00000000 l    df *ABS*	00000000 os_fault.c
00000000 l    df *ABS*	00000000 os.c
0000c6b8 l     F .text	0000001e os_main
200002d0 l     O .bss	00001000 g_os_main_stack
200001c8 l     O .bss	00000100 g_idle_task_stack
00000000 l    df *ABS*	00000000 os_callout.c
00000000 l    df *ABS*	00000000 os_dev.c
0000c94c l     F .text	00000060 os_dev_add
0000c9ac l     F .text	00000022 os_dev_initialize
0000c9ce l     F .text	00000024 os_dev_init
2000132c l     O .bss	00000008 g_os_dev_list
00000000 l    df *ABS*	00000000 os_eventq.c
20001334 l     O .bss	00000010 os_eventq_main
00000000 l    df *ABS*	00000000 os_mempool.c
0000cb78 l     F .text	00000078 os_mempool_init_internal
00000000 l    df *ABS*	00000000 os_msys.c
0000cc94 l     F .text	00000058 os_msys_init_once
2000134c l     O .bss	00000db0 os_msys_1_data
200020fc l     O .bss	0000000c os_msys_1_mbuf_pool
20002108 l     O .bss	0000001c os_msys_1_mempool
20000104 l     O .data	00000008 g_msys_pool_list
00000000 l    df *ABS*	00000000 os_mutex.c
00000000 l    df *ABS*	00000000 os_sanity.c
0000cee4 l     F .text	00000020 os_sanity_check_list_lock
0000cf04 l     F .text	0000001c os_sanity_check_list_unlock
00000000 l    df *ABS*	00000000 os_sched.c
00000000 l    df *ABS*	00000000 os_task.c
0000d278 l     F .text	00000018 _clear_stack
00000000 l    df *ABS*	00000000 os_time.c
0000d380 l     F .text	00000044 os_deltatime
0000d3c4 l     F .text	00000064 os_time_tick
20002148 l     O .bss	00000030 basetod
00000000 l    df *ABS*	00000000 os_arch_arm.c
0000d4a6 l     F .text	00000002 os_arch_task_return_handler
00000000 l    df *ABS*	00000000 os_mbuf.c
00000000 l    df *ABS*	00000000 HAL_CM4.o
0000d6ac l       .text	00000000 SVC_User
0000d6ca l       .text	00000000 SVC_Done
00000000 l    df *ABS*	00000000 memcmp.c
0000d750 l       .text	00000000 test1
0000d744 l       .text	00000000 loop1
0000d756 l       .text	00000000 res1
0000d772 l       .text	00000000 test2
0000d77a l       .text	00000000 done
0000d766 l       .text	00000000 loop2
00000000 l    df *ABS*	00000000 memcpy.c
0000d786 l       .text	00000000 test1
0000d782 l       .text	00000000 loop1
0000d794 l       .text	00000000 test2
0000d790 l       .text	00000000 loop2
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 console.c
0000d7f8 l     F .text	0000004c add_ascii_num_with_char
0000d844 l     F .text	0000003c console_handle_line
0000d880 l     F .text	0000003c console_filter_out
0000d8bc l     F .text	0000001e console_filter_write
0000d8dc l     F .text	00000044 console_append_char
0000d920 l     F .text	0000001e console_write_nolock
0000d940 l     F .text	00000050 handle_end
0000d990 l     F .text	00000050 handle_home
0000d9e0 l     F .text	00000068 del_char
0000da48 l     F .text	00000020 handle_delete
0000da68 l     F .text	00000190 handle_ansi
0000dbf8 l     F .text	00000058 handle_backspace
0000dc50 l     F .text	0000005c console_clear_line
0000dcac l     F .text	000000a8 insert_char
0000dd60 l     F .text	0000000a console_nlip_enable_echo
0000dd6a l     F .text	0000000a console_nlip_disable_echo
0000dd74 l     F .text	00000104 handle_nlip
20002180 l     O .bss	00000004 ansi_val
20002184 l     O .bss	00000004 ansi_val_2
20002188 l     O .bss	00000010 avail_queue
20002198 l     O .bss	00000004 completion
2000219c l     O .bss	00000004 console_compat_rx_cb
200021a4 l     O .bss	0000000c console_write_lock
200021b0 l     O .bss	00000002 cur
200021b4 l     O .bss	00000004 current_line_ev
200021b8 l     O .bss	00000004 esc_state
200021c0 l     O .bss	00000004 lines_queue
200021c4 l     O .bss	00000004 nlip_state
200021c8 l     O .bss	00000001 prev_endl.8685
200021c9 l     O .bss	00000001 rx_stalled
200021ca l     O .bss	00000002 trailing_chars
2000011c l     O .data	00000004 echo
00000000 l    df *ABS*	00000000 console_fmt.c
00000000 l    df *ABS*	00000000 ticks.c
20000120 l     O .data	00000001 do_ticks
00000000 l    df *ABS*	00000000 uart_console.c
0000e1bc l     F .text	00000008 uart_blocking_tx
0000e1c4 l     F .text	00000014 uart_console_ring_add_char
0000e1d8 l     F .text	00000014 uart_console_ring_pull_char
0000e1ec l     F .text	00000016 uart_console_ring_is_full
0000e202 l     F .text	0000000e uart_console_ring_is_empty
0000e210 l     F .text	00000030 uart_console_tx_flush
0000e240 l     F .text	0000001c uart_console_tx_char
0000e25c l     F .text	00000058 uart_console_queue_char
0000e2b4 l     F .text	00000044 uart_console_rx_char
0000e2f8 l     F .text	00000074 uart_console_rx_char_event
200021cc l     O .bss	00000008 cr_rx
200021d4 l     O .bss	00000020 cr_rx_buf
200021f4 l     O .bss	00000008 cr_tx
200021fc l     O .bss	00000020 cr_tx_buf
2000222c l     O .bss	00000001 uart_console_rx_stalled
20002230 l     O .bss	00000004 uart_dev
20002234 l     O .bss	00000004 write_char_cb
20000124 l     O .data	00000004 b.8533
00000000 l    df *ABS*	00000000 flash_map.c
0000e480 l     F .text	00000038 flash_area_find_idx
0000e4b8 l     F .text	00000058 flash_map_area_overlaps
0000e510 l     F .text	00000080 flash_map_add_new_dflt_areas
00000000 l    df *ABS*	00000000 log.c
0000e5f8 l     F .text	0000001c log_registered
0000e678 l     F .text	0000003c log_read_last_hdr
0000e7a8 l     F .text	00000040 log_read_hdr_walk
20002248 l     O .bss	00000001 log_written
20000128 l     O .data	00000008 g_log_list
00000000 l    df *ABS*	00000000 log_console.c
0000e7e8 l     F .text	00000004 log_console_read
0000e7ec l     F .text	00000004 log_console_walk
0000e7f0 l     F .text	00000004 log_console_flush
0000e7f4 l     F .text	00000048 log_console_print_hdr
0000e83c l     F .text	00000048 log_console_dump_cbor_entry
0000e884 l     F .text	00000040 log_console_append_body
0000e8c4 l     F .text	0000001c log_console_append
2000224c l     O .bss	0000001c log_console
00000000 l    df *ABS*	00000000 modlog.c
0000e948 l     F .text	00000028 modlog_find_by_module
0000e970 l     F .text	0000003c modlog_insert
0000e9ac l     F .text	0000001c modlog_alloc
0000e9c8 l     F .text	00000058 modlog_infer_handle
0000ea20 l     F .text	00000046 modlog_register_no_lock
20002268 l     O .bss	00000004 modlog_first_dflt
2000226c l     O .bss	000000c0 modlog_mapping_buf
20002348 l     O .bss	00000004 modlog_mappings
2000234c l     O .bss	00000024 modlog_rwl
00000000 l    df *ABS*	00000000 sysinit.c
0000eb64 l     F .text	00000006 sysinit_dflt_panic_cb
00000000 l    df *ABS*	00000000 mem.c
00000000 l    df *ABS*	00000000 rwlock.c
0000ebb4 l     F .text	0000000c rwlock_complete_handoff
0000ebc0 l     F .text	00000016 rwlock_write_must_block
0000ebd6 l     F .text	0000003a rwlock_unblock
00000000 l    df *ABS*	00000000 cbor_buf_reader.c
0000ecb2 l     F .text	00000006 cbuf_buf_reader_get8
0000ecb8 l     F .text	00000014 cbor_buf_reader_cpy
0000eccc l     F .text	0000001a cbor_buf_reader_cmp
0000ece6 l     F .text	0000001c cbuf_buf_reader_get64
0000ed02 l     F .text	00000008 cbuf_buf_reader_get32
0000ed0a l     F .text	0000000a cbuf_buf_reader_get16
00000000 l    df *ABS*	00000000 cborparser.c
0000ed4c l     F .text	00000024 is_fixed_type
0000ed70 l     F .text	00000004 iterate_noop
0000ed74 l     F .text	0000013c preparse_value
0000eeb0 l     F .text	0000004a preparse_next_value
0000eefa l     F .text	000000ba extract_length
0000efb4 l     F .text	00000172 iterate_string_chunks
0000f126 l     F .text	000000f6 advance_internal
00000000 l    df *ABS*	00000000 cborpretty.c
0000f4ec l     F .text	00000028 hexDump
0000f514 l     F .text	0000022c utf8EscapedDump
0000f740 l     F .text	000003dc value_to_pretty
0000fb1c l     F .text	00000064 container_to_pretty
00000000 l    df *ABS*	00000000 cborparser_dup_string.c
00000000 l    df *ABS*	00000000 hal_bsp.c
00000000 l    df *ABS*	00000000 hal_flash.c
00000000 l    df *ABS*	00000000 hal_flash.c
0000fc50 l     F .text	00000028 nrf52k_flash_wait_ready
0000fc78 l     F .text	00000050 nrf52k_flash_erase_sector
0000fcc8 l     F .text	00000004 nrf52k_flash_init
0000fccc l     F .text	00000028 nrf52k_flash_sector_info
0000fcf4 l     F .text	000000c8 nrf52k_flash_write
0000fdbc l     F .text	0000000e nrf52k_flash_read
00011b64 l     O .text	0000001c nrf52k_flash_funcs
00000000 l    df *ABS*	00000000 hal_os_tick.c
0000fdcc l     F .text	000000f4 nrf52_timer_handler
00000000 l    df *ABS*	00000000 hal_watchdog.c
00010018 l     F .text	00000016 nrf52_hal_wdt_default_handler
00010030 l     F .text	00000020 nrf52_wdt_irq_handler
00000000 l    df *ABS*	00000000 nrf52_periph.c
000100f4 l     F .text	00000044 nrf52_periph_create_timers
00010138 l     F .text	00000044 nrf52_periph_create_uart
20002380 l     O .bss	0000003c os_bsp_uart0
00011b80 l     O .text	00000004 os_bsp_uart0_cfg
00000000 l    df *ABS*	00000000 hal_timer.c
00010188 l     F .text	0000000a nrf_read_timer_cntr
00010194 l     F .text	000000f8 nrf_timer_set_ocmp
0001028c l     F .text	0000000a nrf_timer_disable_ocmp
00010296 l     F .text	00000010 nrf_rtc_disable_ocmp
000102a8 l     F .text	00000054 hal_timer_read_bsptimer
000102fc l     F .text	00000070 hal_timer_chk_queue
0001036c l     F .text	0000002c hal_timer_irq_handler
00011b84 l     O .text	00000018 nrf52_hal_timers
00000000 l    df *ABS*	00000000 nrf52_clock.c
200023d8 l     O .bss	00000001 nrf52_clock_hfxo_refcnt
00000000 l    df *ABS*	00000000 os_cputime.c
00000000 l    df *ABS*	00000000 os_sem.c
00000000 l    df *ABS*	00000000 malloc.c
0001067c l     F .text	00000004 malloc_lock_nop
00010680 l     F .text	00000002 malloc_unlock_nop
00010682 l     F .text	00000048 __malloc_from_block
000106cc l     F .text	00000064 __free_block
20000134 l     O .data	00000018 __malloc_head
2000014c l     O .data	00000004 malloc_lock
20000150 l     O .data	00000004 malloc_unlock
00000000 l    df *ABS*	00000000 mynewt.c
00010818 l     F .text	00000004 stdin_read
0001081c l     F .text	00000010 stdout_write
20000154 l     O .data	00000004 _stdin
20000158 l     O .data	00000008 _stdin_methods
00000000 l    df *ABS*	00000000 tinyprintf.c
0001082c l     F .text	000000fc ui2a
00010928 l     F .text	00000028 i2a
00010950 l     F .text	00000030 a2d
00010980 l     F .text	00000036 a2i
000109b6 l     F .text	00000024 putf
000109dc l     F .text	00000124 putchw
00010b00 l     F .text	00000064 intarg
00000000 l    df *ABS*	00000000 vprintf.c
00000000 l    df *ABS*	00000000 uart_hal.c
00010ec0 l     F .text	00000022 uart_hal_blocking_tx
00010ee2 l     F .text	00000022 uart_hal_start_rx
00010f04 l     F .text	00000022 uart_hal_start_tx
00010f26 l     F .text	0000002c uart_hal_resume
00010f52 l     F .text	0000002c uart_hal_suspend
00010f7e l     F .text	00000012 uart_hal_close
00010f90 l     F .text	00000086 uart_hal_open
00000000 l    df *ABS*	00000000 hal_uart.c
00011080 l     F .text	00000020 hal_uart_tx_fill_buf
000110a0 l     F .text	00000072 uart_irq_handler
00011114 l     F .text	00000014 uart0_irq_handler
00011128 l     F .text	00000014 uart1_irq_handler
0001113c l     F .text	00000104 hal_uart_baudrate
200023dc l     O .bss	0000001c uart0
200023f8 l     O .bss	0000001c uart1
00000000 l    df *ABS*	00000000 _aeabi_uldivmod.o
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 _dvmd_tls.o
00000000 l    df *ABS*	00000000 nrf52_blinky-sysflash.c
00000000 l    df *ABS*	00000000 SVC_Table.S
00000000 l       .svc_table	00000000 SVC_End
00000000 l    df *ABS*	00000000 
00011820 l       .text	00000000 __init_array_end
00011820 l       .text	00000000 __preinit_array_end
00011820 l       .text	00000000 __init_array_start
00011820 l       .text	00000000 __preinit_array_start
0000f21c g     F .text	00000090 _cbor_value_decode_int64_internal
000104d8 g     F .text	00000070 nrf52_clock_hfxo_request
0000e3e0 g     F .text	000000a0 uart_console_init
0000d5d0 g     F .text	00000030 os_arch_start
20002418 g       .bss	00000000 __HeapBase
2000213c g     O .bss	00000008 g_os_task_list
0000c634 g     F .text	00000084 os_idle_task
00000000 g       .svc_table	00000000 SVC_Count
0000c18e  w    F .text	00000002 TIMER2_IRQHandler
0000c188  w    F .text	00000002 DebugMon_Handler
20001344 g     O .bss	00000008 g_os_mempool_list
0000c18e  w    F .text	00000002 RTC0_IRQHandler
00010730 g     F .text	00000050 add_malloc_block
0000cae6 g     F .text	00000070 os_eventq_put
20000100 g       .data	00000000 __data_start__
00011b4c g     O .text	00000018 nrf52k_flash_dev
00010e88 g     F .text	00000024 printf
00011b9c g     O .text	00000004 stdout
0000c18e  w    F .text	00000002 SWI0_EGU0_IRQHandler
0000d540 g     F .text	0000008c os_arch_os_init
0000c17e  w    F .text	00000002 HardFault_Handler
000103a8 g     F .text	00000060 hal_timer_init
0000d600 g     F .text	00000060 os_arch_os_start
200021bc g     O .bss	00000001 g_console_ignore_non_nlip
200021be g     O .bss	00000001 g_console_silence_non_nlip
0000f2ce g     F .text	00000048 cbor_value_advance_fixed
0000e788 g     F .text	00000014 log_read
0000c18e  w    F .text	00000002 SWI2_EGU2_IRQHandler
0000d6fa g     F .text	0000000c SysTick_Handler
0000c18e  w    F .text	00000002 GPIOTE_IRQHandler
00010398 g     F .text	00000010 nrf52_timer0_irq_handler
0000c18e  w    F .text	00000002 PWM1_IRQHandler
20002238 g     O .bss	00000004 flash_map
0000d6d0 g     F .text	0000002a PendSV_Handler
0000c17c  w    F .text	00000002 NMI_Handler
00011bb8 g       .ARM.exidx	00000000 __exidx_end
0000c020 g       .text	00000000 __isr_vector_start
0000e614 g     F .text	00000048 log_init
0000d4b4 g     F .text	00000014 os_arch_ctx_sw
00011018 g     F .text	00000068 uart_hal_init
0000c1ac g     F .text	0000002c hal_system_reset
0000c6e4 g     F .text	00000088 os_init_idle_task
0000ed14 g     F .text	00000038 cbor_buf_reader_init
2000011c g       .data	00000000 __aeabi_unwind_cpp_pr0
0000d074 g     F .text	0000000c os_sched_set_current_task
0000c18e  w    F .text	00000002 POWER_CLOCK_IRQHandler
00011bb8 g       .ARM.exidx	00000000 __etext
0000e158 g     F .text	0000003c console_vprintf
0000c18e  w    F .text	00000002 RADIO_IRQHandler
2000221c g     O .bss	00000010 rx_ev
0000cd44 g     F .text	000000c0 os_mutex_release
0000cf30 g     F .text	00000020 os_sanity_check_register
20000160 g       .bssnz	00000000 __bssnz_start__
0000d480 g     F .text	00000026 os_time_delay
0000c18e  w    F .text	00000002 PDM_IRQHandler
0000e1b0 g     F .text	0000000c console_get_ticks
0000f2ac g     F .text	00000022 cbor_parser_init
0000cc38 g     F .text	00000010 os_mempool_module_init
0000c18e  w    F .text	00000002 TEMP_IRQHandler
0000d4da g     F .text	0000000a os_arch_in_critical
0000c18e  w    F .text	00000002 QDEC_IRQHandler
0000c18e  w    F .text	00000002 TIMER3_IRQHandler
0000d4a8 g     F .text	0000000a timer_handler
0000ca58 g     F .text	00000020 os_dev_lookup
0000d080 g     F .text	00000090 os_sched_sleep
0000d780 g     F .text	0000001a memcpy
0000c18e  w    F .text	00000002 PWM3_IRQHandler
00010050 g     F .text	00000080 hal_watchdog_init
00010548 g     F .text	0000000c os_cputime_init
0001152c g     F .text	00000000 .hidden __aeabi_uldivmod
00000020 g       *ABS*	00000000 _imghdr_size
0000d038 g     F .text	00000030 os_sched_ctx_sw_hook
200021a0 g     O .bss	00000004 console_is_midline
0000c18e  w    F .text	00000002 FPU_IRQHandler
0000c18e  w    F .text	00000002 USBD_IRQHandler
20000100 g     O .data	00000004 SystemCoreClock
0000c190 g     F .text	0000000c hal_system_init
0000c18e  w    F .text	00000002 SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0_IRQHandler
0000d4e4 g     F .text	00000044 os_arch_task_stack_init
00010780 g     F .text	0000006c malloc
0000c558 g     F .text	00000044 __assert_func
0000d1d4 g     F .text	00000048 os_sched_wakeup_ticks
0000e0f8 g     F .text	00000060 console_pkg_init
0000c184  w    F .text	00000002 UsageFault_Handler
20001324 g     O .bss	00000008 g_callout_list
0000c18e  w    F .text	00000002 UARTE0_UART0_IRQHandler
00010b64 g     F .text	00000300 tfp_format
2003fe50 g       *ABS*	00000000 __HeapLimit
20000160 g       .bss	00000000 __bss_start__
0000c19c g     F .text	00000010 hal_debugger_connected
0000c18e  w    F .text	00000002 TIMER4_IRQHandler
0001155c g     F .text	000002be .hidden __udivmoddi4
0000f4b4 g     F .text	00000038 _cbor_value_copy_string
20002134 g     O .bss	00000004 g_current_task
0000cf50 g     F .text	00000084 os_sanity_run
0000d4c8 g     F .text	0000000c os_arch_save_sr
000114e4 g     F .text	00000048 hal_uart_close
0000cbf0 g     F .text	00000014 os_mempool_init
20002144 g     O .bss	00000001 g_task_id
00011328 g     F .text	00000064 hal_uart_blocking_tx
00011ba0 g       .text	00000000 __exidx_start
0000cfd4 g     F .text	00000010 os_sanity_init
0000d670 g     F .text	00000014 os_set_env
0000fc08 g     F .text	00000010 hal_bsp_flash_dev
0000c418 g     F .text	0000004c __libc_init_array
0001017c g     F .text	0000000c nrf52_periph_create
20002128 g     O .bss	0000000c g_os_sanity_check_mu
0000c18e  w    F .text	00000002 CRYPTOCELL_IRQHandler
0000c520 g     F .text	00000038 _sbrk
0000fec0 g     F .text	000000b0 os_tick_idle
0000e194 g     F .text	0000001c console_printf
0000df60 g     F .text	00000008 console_blocking_mode
0000f316 g     F .text	0000014e cbor_value_enter_container
0000c18e  w    F .text	00000002 I2S_IRQHandler
0000c414  w    F .text	00000002 _init
0000c18e  w    F .text	00000002 SWI4_EGU4_IRQHandler
0000ff70 g     F .text	000000a8 os_tick_init
0000e8e0 g     F .text	00000008 log_console_get
0000c18e  w    F .text	00000002 TIMER0_IRQHandler
0000c76c g     F .text	000000d8 os_init
0000c120 g     F .text	0000005c Reset_Handler
0000c18e  w    F .text	00000002 UARTE1_IRQHandler
0000dd54 g     F .text	0000000c console_echo
20002370 g     O .bss	00000001 sysinit_active
200021bd g     O .bss	00000001 g_console_silence
0000d664 g     F .text	0000000a os_mbuf_pool_init
0000d706 g     F .text	0000001e os_default_irq_asm
0000d21c g     F .text	0000000c os_sched_next_task
0000cfe4 g     F .text	00000054 os_sched_insert
0000cabc g     F .text	00000010 os_dev_reset
00010e6c g     F .text	0000001c fprintf
0000cd30 g     F .text	00000014 os_mutex_init
0000c504 g     F .text	0000001c _sbrkInit
0000cb56 g     F .text	0000001a os_eventq_get_no_wait
20000160 g       .bssnz	00000000 __bssnz_end__
0000e590 g     F .text	00000068 flash_map_init
00010eac g     F .text	00000014 vprintf
0000c6d8 g     F .text	0000000c os_started
0000c18e  w    F .text	00000002 TIMER1_IRQHandler
20000000 g       .bss	00000000 _ram_start
0000d198 g     F .text	0000003c os_sched_os_timer_exp
20000000 g       .vector_relocation	00000000 __vector_tbl_reloc__
00011a04 g     O .text	0000002c log_console_handler
0000ec64 g     F .text	0000001e rwlock_release_write
0000c18e  w    F .text	00000002 SPIM3_IRQHandler
0000c18e  w    F .text	00000002 PWM2_IRQHandler
20000160 g       .data	00000000 __data_end__
0000e6b4 g     F .text	000000d4 log_register
0000c18e  w    F .text	00000002 ECB_IRQHandler
20002178 g     O .bss	00000004 g_os_time
00011240 g     F .text	0000003c hal_uart_init_cbs
000100e0 g     F .text	00000014 hal_watchdog_tickle
20002414 g       .bss	00000000 __bss_end__
0000c18e  w    F .text	00000002 SPIM1_SPIS1_TWIM1_TWIS1_SPI1_TWI1_IRQHandler
0000e65c g     F .text	00000010 log_hdr_len
0000ccec g     F .text	00000010 os_msys_reset
0000c18e g     F .text	00000002 Default_Handler
0000c464 g     F .text	00000018 _start
0000e79c g     F .text	0000000c log_fill_current_img_hash
0000d684 g     F .text	00000006 os_arch_init_task_stack
0000de78 g     F .text	00000034 console_lock
20000174 g     O .bss	00000050 g_idle_task
20000130 g     O .data	00000004 sysinit_panic_cb
20002124 g     O .bss	00000004 g_os_sanity_check_list
0001127c g     F .text	00000060 hal_uart_start_tx
0000cc04 g     F .text	00000032 os_memblock_get
0000d110 g     F .text	00000088 os_sched_wakeup
00010554 g     F .text	00000010 os_sem_init
0000eb84 g     F .text	00000030 mem_init_mbuf_pool
0000c59c g     F .text	00000098 os_default_irq
20002138 g     O .bss	00000004 g_os_last_ctx_sw_time
00010564 g     F .text	00000064 os_sem_release
0000d738 g     F .text	00000048 memcmp
0000d528 g     F .text	00000018 os_arch_init
0000c4c4 g     F .text	0000000c bus_pkg_init
0001181c  w    F .text	00000002 .hidden __aeabi_ldiv0
0000eb6c g     F .text	0000000c sysinit_start
00010408 g     F .text	000000d0 hal_timer_config
0000ca78 g     F .text	00000044 os_dev_open
0000e0f0 g     F .text	00000008 console_is_init
000105c8 g     F .text	000000b4 os_sem_pend
000100d0 g     F .text	00000010 hal_watchdog_enable
0000ec82 g     F .text	00000030 rwlock_init
0000cc48 g     F .text	0000004c os_msys_register
200002c8 g     O .bss	00000004 g_os_idle_ctr
0000c18e  w    F .text	00000002 SAADC_IRQHandler
0000d79a g     F .text	00000038 memset
0000c020 g       .text	00000100 __isr_vector
0000c47c g     F .text	0000002c main
0000e398 g     F .text	00000038 console_out_nolock
0000c18e  w    F .text	00000002 CCM_AAR_IRQHandler
0000c18e  w    F .text	00000002 WDT_IRQHandler
0000ea68 g     F .text	00000034 modlog_register
0000eb78 g     F .text	0000000c sysinit_end
0000ea9c g     F .text	000000c8 modlog_init
0000d68a g     F .text	00000046 SVC_Handler
0000cadc g     F .text	0000000a os_eventq_inited
0000deac g     F .text	0000003c console_unlock
0000cb70 g     F .text	00000008 os_eventq_dflt_get
0000e66c g     F .text	0000000a log_walk
0000c910 g     F .text	0000003c os_callout_wakeup_ticks
0000c18e  w    F .text	00000002 SWI5_EGU5_IRQHandler
2000223c g     O .bss	00000004 flash_map_entries
0000c020 g       .imghdr	00000000 __text
0000d7d2 g     F .text	00000018 strcmp
0000e36c g     F .text	0000002c uart_console_blocking_mode
0000d068 g     F .text	0000000c os_sched_get_current_task
0000dee8 g     F .text	00000078 console_write
0000c310 g     F .text	00000104 SystemInit
0000c18e  w    F .text	00000002 RNG_IRQHandler
0000d228 g     F .text	00000022 os_sched
000112dc g     F .text	0000004c hal_uart_start_rx
0000ce04 g     F .text	000000e0 os_mutex_pend
00000000 g       .svc_table	00000000 SVC_Table
0000c18e  w    F .text	00000002 RTC2_IRQHandler
20040000 g       .bss	00000000 __StackTop
0000c18e  w    F .text	00000002 PWM0_IRQHandler
0000c18e  w    F .text	00000002 SWI3_EGU3_IRQHandler
0000c8b4 g     F .text	0000005c os_callout_tick
00011a44 g     O .text	00000048 sysflash_map_dflt
0000e3d0 g     F .text	00000010 uart_console_is_init
200023bc g     O .bss	0000001c nrf52_hal_timer0
0000c120 g       .text	00000000 __isr_vector_end
0000c844 g     F .text	00000022 os_start
0000c18e  w    F .text	00000002 RTC1_IRQHandler
0000d290 g     F .text	0000000a os_task_stacktop_get
000113e8 g     F .text	000000fc hal_uart_config
0000c18e  w    F .text	00000002 SWI1_EGU1_IRQHandler
0000df68 g     F .text	00000188 console_handle_char
0000fb88 g     F .text	0000007e _cbor_value_dup_string
2000010c g     O .data	00000008 g_os_run_list
0000c4d0 g     F .text	00000034 NVIC_Relocate
0000c4a8 g     F .text	0000001c sysinit_app
2000217c g     O .bss	00000004 os_flags
0000d4d4 g     F .text	00000006 os_arch_restore_sr
20002374 g     O .bss	0000000c g_hal_os_tick
2003fe50 g       *ABS*	000001b0 __StackLimit
20001320 g     O .bss	00000004 g_os_started
0000c18e  w    F .text	00000002 SPIM2_SPIS2_SPI2_IRQHandler
0000c18e  w    F .text	00000002 NFCT_IRQHandler
0000f464 g     F .text	00000050 cbor_value_leave_container
0000c300 g     F .text	00000010 SystemCoreClockUpdate
0000ccfc g     F .text	00000034 os_msys_init
200021bf g     O .bss	00000001 g_is_output_nlip
0000d428 g     F .text	0000000c os_time_get
2000232c g     O .bss	0000001c modlog_mapping_pool
20002240 g     O .bss	00000008 g_log_info
0001181c  w    F .text	00000002 .hidden __aeabi_idiv0
0000d29c g     F .text	000000e4 os_task_init
0000c1d8 g     F .text	00000050 hal_system_clock_start
0000c182  w    F .text	00000002 BusFault_Handler
0000e8e8 g     F .text	00000060 log_console_init
0000d7ea g     F .text	0000000e strlen
0000c9f4 g     F .text	00000038 os_dev_create
0000ec10 g     F .text	00000054 rwlock_acquire_write
0000cacc g     F .text	00000010 os_eventq_init
0000d434 g     F .text	0000004c os_time_advance
0000d24c g     F .text	0000002c os_sched_resort
0000fc24 g     F .text	0000002c hal_flash_init
0000c18e  w    F .text	00000002 MWU_IRQHandler
0000c180  w    F .text	00000002 MemoryManagement_Handler
0000c18e  w    F .text	00000002 QSPI_IRQHandler
0000c18e  w    F .text	00000002 COMP_LPCOMP_IRQHandler
0000ca2c g     F .text	0000002c os_dev_initialize_all
20000114 g     O .data	00000008 g_os_sleep_list
0000fc18 g     F .text	0000000c hal_bsp_init
0000c868 g     F .text	0000004c os_pkg_init
0000cf20 g     F .text	00000010 os_sanity_check_init
0001138c g     F .text	0000005c hal_uart_init
0000fb80 g     F .text	00000008 cbor_value_to_pretty_advance
00010e64 g     F .text	00000008 vfprintf
200012d0 g     O .bss	00000050 g_os_main_task
000107ec g     F .text	0000002c free



Disassembly of section .text:

0000c020 <__isr_vector>:
    c020:	20040000 	.word	0x20040000
    c024:	0000c121 	.word	0x0000c121
    c028:	0000c17d 	.word	0x0000c17d
    c02c:	0000c17f 	.word	0x0000c17f
    c030:	0000c181 	.word	0x0000c181
    c034:	0000c183 	.word	0x0000c183
    c038:	0000c185 	.word	0x0000c185
	...
    c04c:	0000d68b 	.word	0x0000d68b
    c050:	0000c189 	.word	0x0000c189
    c054:	00000000 	.word	0x00000000
    c058:	0000d6d1 	.word	0x0000d6d1
    c05c:	0000d6fb 	.word	0x0000d6fb
    c060:	0000c18f 	.word	0x0000c18f
    c064:	0000c18f 	.word	0x0000c18f
    c068:	0000c18f 	.word	0x0000c18f
    c06c:	0000c18f 	.word	0x0000c18f
    c070:	0000c18f 	.word	0x0000c18f
    c074:	0000c18f 	.word	0x0000c18f
    c078:	0000c18f 	.word	0x0000c18f
    c07c:	0000c18f 	.word	0x0000c18f
    c080:	0000c18f 	.word	0x0000c18f
    c084:	0000c18f 	.word	0x0000c18f
    c088:	0000c18f 	.word	0x0000c18f
    c08c:	0000c18f 	.word	0x0000c18f
    c090:	0000c18f 	.word	0x0000c18f
    c094:	0000c18f 	.word	0x0000c18f
    c098:	0000c18f 	.word	0x0000c18f
    c09c:	0000c18f 	.word	0x0000c18f
    c0a0:	0000c18f 	.word	0x0000c18f
    c0a4:	0000c18f 	.word	0x0000c18f
    c0a8:	0000c18f 	.word	0x0000c18f
    c0ac:	0000c18f 	.word	0x0000c18f
    c0b0:	0000c18f 	.word	0x0000c18f
    c0b4:	0000c18f 	.word	0x0000c18f
    c0b8:	0000c18f 	.word	0x0000c18f
    c0bc:	0000c18f 	.word	0x0000c18f
    c0c0:	0000c18f 	.word	0x0000c18f
    c0c4:	0000c18f 	.word	0x0000c18f
    c0c8:	0000c18f 	.word	0x0000c18f
    c0cc:	0000c18f 	.word	0x0000c18f
    c0d0:	0000c18f 	.word	0x0000c18f
    c0d4:	0000c18f 	.word	0x0000c18f
	...
    c0e0:	0000c18f 	.word	0x0000c18f
    c0e4:	0000c18f 	.word	0x0000c18f
    c0e8:	0000c18f 	.word	0x0000c18f
    c0ec:	0000c18f 	.word	0x0000c18f
    c0f0:	0000c18f 	.word	0x0000c18f
    c0f4:	0000c18f 	.word	0x0000c18f
    c0f8:	0000c18f 	.word	0x0000c18f
    c0fc:	0000c18f 	.word	0x0000c18f
    c100:	0000c18f 	.word	0x0000c18f
    c104:	0000c18f 	.word	0x0000c18f
    c108:	0000c18f 	.word	0x0000c18f
    c10c:	00000000 	.word	0x00000000
    c110:	0000c18f 	.word	0x0000c18f
	...
    c11c:	0000c18f 	.word	0x0000c18f

0000c120 <Reset_Handler>:
    .type    Reset_Handler, %function
Reset_Handler:
    .fnstart

    /* Clear BSS */
    mov     r0, #0
    c120:	f04f 0000 	mov.w	r0, #0
    ldr     r2, =__bss_start__
    c124:	4a0c      	ldr	r2, [pc, #48]	; (c158 <.bss_zero_loop+0x30>)
    ldr     r3, =__bss_end__
    c126:	4b0d      	ldr	r3, [pc, #52]	; (c15c <.bss_zero_loop+0x34>)

0000c128 <.bss_zero_loop>:
.bss_zero_loop:
    cmp     r2, r3
    c128:	429a      	cmp	r2, r3
    itt     lt
    c12a:	bfbc      	itt	lt
    strlt   r0, [r2], #4
    c12c:	f842 0b04 	strlt.w	r0, [r2], #4
    blt    .bss_zero_loop
    c130:	e7fa      	blt.n	c128 <.bss_zero_loop>
 *      linker script.
 *      __etext: End of code section, i.e., begin of data sections to copy from.
 *      __data_start__/__data_end__: RAM address range that data should be
 *      copied to. Both must be aligned to 4 bytes boundary.  */

    ldr    r1, =__etext
    c132:	490b      	ldr	r1, [pc, #44]	; (c160 <.bss_zero_loop+0x38>)
    ldr    r2, =__data_start__
    c134:	4a0b      	ldr	r2, [pc, #44]	; (c164 <.bss_zero_loop+0x3c>)
    ldr    r3, =__data_end__
    c136:	4b0c      	ldr	r3, [pc, #48]	; (c168 <.bss_zero_loop+0x40>)

    subs    r3, r2
    c138:	1a9b      	subs	r3, r3, r2
    ble     .LC0
    c13a:	dd03      	ble.n	c144 <.bss_zero_loop+0x1c>

.LC1:
    subs    r3, 4
    c13c:	3b04      	subs	r3, #4
    ldr    r0, [r1,r3]
    c13e:	58c8      	ldr	r0, [r1, r3]
    str    r0, [r2,r3]
    c140:	50d0      	str	r0, [r2, r3]
    bgt    .LC1
    c142:	dcfb      	bgt.n	c13c <.bss_zero_loop+0x14>

.LC0:

    LDR     R0, =__HeapBase
    c144:	4809      	ldr	r0, [pc, #36]	; (c16c <.bss_zero_loop+0x44>)
    LDR     R1, =__HeapLimit
    c146:	490a      	ldr	r1, [pc, #40]	; (c170 <.bss_zero_loop+0x48>)
    BL      _sbrkInit
    c148:	f000 f9dc 	bl	c504 <_sbrkInit>

    LDR     R0, =SystemInit
    c14c:	4809      	ldr	r0, [pc, #36]	; (c174 <.bss_zero_loop+0x4c>)
    BLX     R0
    c14e:	4780      	blx	r0

    BL      hal_system_init
    c150:	f000 f81e 	bl	c190 <hal_system_init>

    LDR     R0, =_start
    c154:	4808      	ldr	r0, [pc, #32]	; (c178 <.bss_zero_loop+0x50>)
    BX      R0
    c156:	4700      	bx	r0
    ldr     r2, =__bss_start__
    c158:	20000160 	.word	0x20000160
    ldr     r3, =__bss_end__
    c15c:	20002414 	.word	0x20002414
    ldr    r1, =__etext
    c160:	00011bb8 	.word	0x00011bb8
    ldr    r2, =__data_start__
    c164:	20000100 	.word	0x20000100
    ldr    r3, =__data_end__
    c168:	20000160 	.word	0x20000160
    LDR     R0, =__HeapBase
    c16c:	20002418 	.word	0x20002418
    LDR     R1, =__HeapLimit
    c170:	2003fe50 	.word	0x2003fe50
    LDR     R0, =SystemInit
    c174:	0000c311 	.word	0x0000c311
    LDR     R0, =_start
    c178:	0000c465 	.word	0x0000c465

0000c17c <NMI_Handler>:
/* Dummy Exception Handlers (infinite loops which can be modified) */

    .weak   NMI_Handler
    .type   NMI_Handler, %function
NMI_Handler:
    B       .
    c17c:	e7fe      	b.n	c17c <NMI_Handler>

0000c17e <HardFault_Handler>:


    .weak   HardFault_Handler
    .type   HardFault_Handler, %function
HardFault_Handler:
    B       .
    c17e:	e7fe      	b.n	c17e <HardFault_Handler>

0000c180 <MemoryManagement_Handler>:


    .weak   MemoryManagement_Handler
    .type   MemoryManagement_Handler, %function
MemoryManagement_Handler:
    B       .
    c180:	e7fe      	b.n	c180 <MemoryManagement_Handler>

0000c182 <BusFault_Handler>:


    .weak   BusFault_Handler
    .type   BusFault_Handler, %function
BusFault_Handler:
    B       .
    c182:	e7fe      	b.n	c182 <BusFault_Handler>

0000c184 <UsageFault_Handler>:


    .weak   UsageFault_Handler
    .type   UsageFault_Handler, %function
UsageFault_Handler:
    B       .
    c184:	e7fe      	b.n	c184 <UsageFault_Handler>


    .weak   SVC_Handler
    .type   SVC_Handler, %function
SVC_Handler:
    B       .
    c186:	e7fe      	b.n	c186 <UsageFault_Handler+0x2>

0000c188 <DebugMon_Handler>:


    .weak   DebugMon_Handler
    .type   DebugMon_Handler, %function
DebugMon_Handler:
    b       .
    c188:	e7fe      	b.n	c188 <DebugMon_Handler>


    .weak   PendSV_Handler
    .type   PendSV_Handler, %function
PendSV_Handler:
    B       .
    c18a:	e7fe      	b.n	c18a <DebugMon_Handler+0x2>


    .weak   SysTick_Handler
    .type   SysTick_Handler, %function
SysTick_Handler:
    B       .
    c18c:	e7fe      	b.n	c18c <DebugMon_Handler+0x4>

0000c18e <Default_Handler>:
/* IRQ Handlers */

    .globl  Default_Handler
    .type   Default_Handler, %function
Default_Handler:
    B       .
    c18e:	e7fe      	b.n	c18e <Default_Handler>

0000c190 <hal_system_init>:
#if MYNEWT_VAL(MCU_ICACHE_ENABLED)
    NRF_NVMC->ICACHECNF = 1;
#endif

#if MYNEWT_VAL(MCU_DCDC_ENABLED)
    NRF_POWER->DCDCEN = 1;
    c190:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    c194:	2201      	movs	r2, #1
    c196:	f8c3 2578 	str.w	r2, [r3, #1400]	; 0x578
#endif
}
    c19a:	4770      	bx	lr

0000c19c <hal_debugger_connected>:
}

int
hal_debugger_connected(void)
{
    return CoreDebug->DHCSR & CoreDebug_DHCSR_C_DEBUGEN_Msk;
    c19c:	4b02      	ldr	r3, [pc, #8]	; (c1a8 <hal_debugger_connected+0xc>)
    c19e:	6818      	ldr	r0, [r3, #0]
}
    c1a0:	f000 0001 	and.w	r0, r0, #1
    c1a4:	4770      	bx	lr
    c1a6:	bf00      	nop
    c1a8:	e000edf0 	.word	0xe000edf0

0000c1ac <hal_system_reset>:
{
    c1ac:	b508      	push	{r3, lr}
        HAL_DEBUG_BREAK();
    c1ae:	f7ff fff5 	bl	c19c <hal_debugger_connected>
    c1b2:	b100      	cbz	r0, c1b6 <hal_system_reset+0xa>

static inline void
hal_debug_break(void)
{
#if !MYNEWT_VAL(MCU_DEBUG_IGNORE_BKPT)
    __BKPT(1);
    c1b4:	be01      	bkpt	0x0001
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    c1b6:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    c1ba:	4905      	ldr	r1, [pc, #20]	; (c1d0 <hal_system_reset+0x24>)
    c1bc:	68ca      	ldr	r2, [r1, #12]
    c1be:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
    c1c2:	4b04      	ldr	r3, [pc, #16]	; (c1d4 <hal_system_reset+0x28>)
    c1c4:	4313      	orrs	r3, r2
    c1c6:	60cb      	str	r3, [r1, #12]
    c1c8:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
    c1cc:	bf00      	nop
  for(;;)                                                           /* wait until reset */
    c1ce:	e7fd      	b.n	c1cc <hal_system_reset+0x20>
    c1d0:	e000ed00 	.word	0xe000ed00
    c1d4:	05fa0004 	.word	0x05fa0004

0000c1d8 <hal_system_clock_start>:
#if MYNEWT_VAL_CHOICE(MCU_LFCLK_SOURCE, LFSYNTH)
    /* Must turn on HFLCK for synthesized 32768 crystal */
    nrf52_clock_hfxo_request();
#else
    /* Make sure HFCLK is stopped */
    NRF_CLOCK->TASKS_HFCLKSTOP = 1;
    c1d8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    c1dc:	2201      	movs	r2, #1
    c1de:	605a      	str	r2, [r3, #4]
#endif

    /* Check if this clock source is already running */
    if ((NRF_CLOCK->LFCLKSTAT & regmsk) != regval) {
    c1e0:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
    c1e4:	4b0f      	ldr	r3, [pc, #60]	; (c224 <hal_system_clock_start+0x4c>)
    c1e6:	4013      	ands	r3, r2
    c1e8:	f1b3 1f01 	cmp.w	r3, #65537	; 0x10001
    c1ec:	d018      	beq.n	c220 <hal_system_clock_start+0x48>
        NRF_CLOCK->TASKS_LFCLKSTOP = 1;
    c1ee:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    c1f2:	2201      	movs	r2, #1
    c1f4:	60da      	str	r2, [r3, #12]
        NRF_CLOCK->EVENTS_LFCLKSTARTED = 0;
    c1f6:	2100      	movs	r1, #0
    c1f8:	f8c3 1104 	str.w	r1, [r3, #260]	; 0x104
        NRF_CLOCK->LFCLKSRC = clksrc;
    c1fc:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
        NRF_CLOCK->TASKS_LFCLKSTART = 1;
    c200:	609a      	str	r2, [r3, #8]

        /* Wait here till started! */
        while (1) {
            if (NRF_CLOCK->EVENTS_LFCLKSTARTED) {
    c202:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    c206:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
    c20a:	2b00      	cmp	r3, #0
    c20c:	d0f9      	beq.n	c202 <hal_system_clock_start+0x2a>
                if ((NRF_CLOCK->LFCLKSTAT & regmsk) == regval) {
    c20e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    c212:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
    c216:	4b03      	ldr	r3, [pc, #12]	; (c224 <hal_system_clock_start+0x4c>)
    c218:	4013      	ands	r3, r2
    c21a:	f1b3 1f01 	cmp.w	r3, #65537	; 0x10001
    c21e:	d1f0      	bne.n	c202 <hal_system_clock_start+0x2a>
                }
            }
        }
    }
#endif
}
    c220:	4770      	bx	lr
    c222:	bf00      	nop
    c224:	00010003 	.word	0x00010003

0000c228 <errata_36>:
#endif

#ifdef NRF52840_XXAA
static bool errata_36(void)
{
	if ((*(uint32_t *)0x10000130ul == 0x8ul) &&
    c228:	4b06      	ldr	r3, [pc, #24]	; (c244 <errata_36+0x1c>)
    c22a:	681b      	ldr	r3, [r3, #0]
    c22c:	2b08      	cmp	r3, #8
    c22e:	d001      	beq.n	c234 <errata_36+0xc>
			(*(uint32_t *)0x10000134ul == 0x0ul)) {
		return true;
	}

	return false;
    c230:	2000      	movs	r0, #0
    c232:	4770      	bx	lr
			(*(uint32_t *)0x10000134ul == 0x0ul)) {
    c234:	4b04      	ldr	r3, [pc, #16]	; (c248 <errata_36+0x20>)
    c236:	681b      	ldr	r3, [r3, #0]
	if ((*(uint32_t *)0x10000130ul == 0x8ul) &&
    c238:	b10b      	cbz	r3, c23e <errata_36+0x16>
	return false;
    c23a:	2000      	movs	r0, #0
    c23c:	4770      	bx	lr
		return true;
    c23e:	2001      	movs	r0, #1
}
    c240:	4770      	bx	lr
    c242:	bf00      	nop
    c244:	10000130 	.word	0x10000130
    c248:	10000134 	.word	0x10000134

0000c24c <errata_98>:


static bool errata_98(void)
{
	if ((*(uint32_t *)0x10000130ul == 0x8ul) &&
    c24c:	4b06      	ldr	r3, [pc, #24]	; (c268 <errata_98+0x1c>)
    c24e:	681b      	ldr	r3, [r3, #0]
    c250:	2b08      	cmp	r3, #8
    c252:	d001      	beq.n	c258 <errata_98+0xc>
			(*(uint32_t *)0x10000134ul == 0x0ul)) {
		return true;
	}

	return false;
    c254:	2000      	movs	r0, #0
    c256:	4770      	bx	lr
			(*(uint32_t *)0x10000134ul == 0x0ul)) {
    c258:	4b04      	ldr	r3, [pc, #16]	; (c26c <errata_98+0x20>)
    c25a:	681b      	ldr	r3, [r3, #0]
	if ((*(uint32_t *)0x10000130ul == 0x8ul) &&
    c25c:	b10b      	cbz	r3, c262 <errata_98+0x16>
	return false;
    c25e:	2000      	movs	r0, #0
    c260:	4770      	bx	lr
		return true;
    c262:	2001      	movs	r0, #1
}
    c264:	4770      	bx	lr
    c266:	bf00      	nop
    c268:	10000130 	.word	0x10000130
    c26c:	10000134 	.word	0x10000134

0000c270 <errata_103>:


static bool errata_103(void)
{
	if ((*(uint32_t *)0x10000130ul == 0x8ul) &&
    c270:	4b06      	ldr	r3, [pc, #24]	; (c28c <errata_103+0x1c>)
    c272:	681b      	ldr	r3, [r3, #0]
    c274:	2b08      	cmp	r3, #8
    c276:	d001      	beq.n	c27c <errata_103+0xc>
			(*(uint32_t *)0x10000134ul == 0x0ul)) {
		return true;
	}

	return false;
    c278:	2000      	movs	r0, #0
    c27a:	4770      	bx	lr
			(*(uint32_t *)0x10000134ul == 0x0ul)) {
    c27c:	4b04      	ldr	r3, [pc, #16]	; (c290 <errata_103+0x20>)
    c27e:	681b      	ldr	r3, [r3, #0]
	if ((*(uint32_t *)0x10000130ul == 0x8ul) &&
    c280:	b10b      	cbz	r3, c286 <errata_103+0x16>
	return false;
    c282:	2000      	movs	r0, #0
    c284:	4770      	bx	lr
		return true;
    c286:	2001      	movs	r0, #1
}
    c288:	4770      	bx	lr
    c28a:	bf00      	nop
    c28c:	10000130 	.word	0x10000130
    c290:	10000134 	.word	0x10000134

0000c294 <errata_115>:


static bool errata_115(void)
{
	if ((*(uint32_t *)0x10000130ul == 0x8ul) &&
    c294:	4b06      	ldr	r3, [pc, #24]	; (c2b0 <errata_115+0x1c>)
    c296:	681b      	ldr	r3, [r3, #0]
    c298:	2b08      	cmp	r3, #8
    c29a:	d001      	beq.n	c2a0 <errata_115+0xc>
			(*(uint32_t *)0x10000134ul == 0x0ul)) {
		return true;
	}

	return false;
    c29c:	2000      	movs	r0, #0
    c29e:	4770      	bx	lr
			(*(uint32_t *)0x10000134ul == 0x0ul)) {
    c2a0:	4b04      	ldr	r3, [pc, #16]	; (c2b4 <errata_115+0x20>)
    c2a2:	681b      	ldr	r3, [r3, #0]
	if ((*(uint32_t *)0x10000130ul == 0x8ul) &&
    c2a4:	b10b      	cbz	r3, c2aa <errata_115+0x16>
	return false;
    c2a6:	2000      	movs	r0, #0
    c2a8:	4770      	bx	lr
		return true;
    c2aa:	2001      	movs	r0, #1
}
    c2ac:	4770      	bx	lr
    c2ae:	bf00      	nop
    c2b0:	10000130 	.word	0x10000130
    c2b4:	10000134 	.word	0x10000134

0000c2b8 <errata_120>:


static bool errata_120(void)
{
	if ((*(uint32_t *)0x10000130ul == 0x8ul) &&
    c2b8:	4b06      	ldr	r3, [pc, #24]	; (c2d4 <errata_120+0x1c>)
    c2ba:	681b      	ldr	r3, [r3, #0]
    c2bc:	2b08      	cmp	r3, #8
    c2be:	d001      	beq.n	c2c4 <errata_120+0xc>
			(*(uint32_t *)0x10000134ul == 0x0ul)) {
		return true;
	}

	return false;
    c2c0:	2000      	movs	r0, #0
    c2c2:	4770      	bx	lr
			(*(uint32_t *)0x10000134ul == 0x0ul)) {
    c2c4:	4b04      	ldr	r3, [pc, #16]	; (c2d8 <errata_120+0x20>)
    c2c6:	681b      	ldr	r3, [r3, #0]
	if ((*(uint32_t *)0x10000130ul == 0x8ul) &&
    c2c8:	b10b      	cbz	r3, c2ce <errata_120+0x16>
	return false;
    c2ca:	2000      	movs	r0, #0
    c2cc:	4770      	bx	lr
		return true;
    c2ce:	2001      	movs	r0, #1
}
    c2d0:	4770      	bx	lr
    c2d2:	bf00      	nop
    c2d4:	10000130 	.word	0x10000130
    c2d8:	10000134 	.word	0x10000134

0000c2dc <errata_121>:

static bool errata_121(void)
{
	if ((*(uint32_t *)0x10000130ul == 0x8ul) &&
    c2dc:	4b06      	ldr	r3, [pc, #24]	; (c2f8 <errata_121+0x1c>)
    c2de:	681b      	ldr	r3, [r3, #0]
    c2e0:	2b08      	cmp	r3, #8
    c2e2:	d001      	beq.n	c2e8 <errata_121+0xc>
			(*(uint32_t *)0x10000134ul == 0x0ul)) {
		return true;
	}

	return false;
    c2e4:	2000      	movs	r0, #0
    c2e6:	4770      	bx	lr
			(*(uint32_t *)0x10000134ul == 0x0ul)) {
    c2e8:	4b04      	ldr	r3, [pc, #16]	; (c2fc <errata_121+0x20>)
    c2ea:	681b      	ldr	r3, [r3, #0]
	if ((*(uint32_t *)0x10000130ul == 0x8ul) &&
    c2ec:	b10b      	cbz	r3, c2f2 <errata_121+0x16>
	return false;
    c2ee:	2000      	movs	r0, #0
    c2f0:	4770      	bx	lr
		return true;
    c2f2:	2001      	movs	r0, #1
}
    c2f4:	4770      	bx	lr
    c2f6:	bf00      	nop
    c2f8:	10000130 	.word	0x10000130
    c2fc:	10000134 	.word	0x10000134

0000c300 <SystemCoreClockUpdate>:
    SystemCoreClock = __SYSTEM_CLOCK_64M;
    c300:	4b01      	ldr	r3, [pc, #4]	; (c308 <SystemCoreClockUpdate+0x8>)
    c302:	4a02      	ldr	r2, [pc, #8]	; (c30c <SystemCoreClockUpdate+0xc>)
    c304:	601a      	str	r2, [r3, #0]
}
    c306:	4770      	bx	lr
    c308:	20000100 	.word	0x20000100
    c30c:	03d09000 	.word	0x03d09000

0000c310 <SystemInit>:
{
    c310:	b508      	push	{r3, lr}
        if (errata_36()){
    c312:	f7ff ff89 	bl	c228 <errata_36>
    c316:	b140      	cbz	r0, c32a <SystemInit+0x1a>
            NRF_CLOCK->EVENTS_DONE = 0;
    c318:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    c31c:	2200      	movs	r2, #0
    c31e:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
            NRF_CLOCK->EVENTS_CTTO = 0;
    c322:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
            NRF_CLOCK->CTIV = 0;
    c326:	f8c3 2538 	str.w	r2, [r3, #1336]	; 0x538
        if (errata_98()){
    c32a:	f7ff ff8f 	bl	c24c <errata_98>
    c32e:	b110      	cbz	r0, c336 <SystemInit+0x26>
            *(volatile uint32_t *)0x4000568Cul = 0x00038148ul;
    c330:	4b2d      	ldr	r3, [pc, #180]	; (c3e8 <SystemInit+0xd8>)
    c332:	4a2e      	ldr	r2, [pc, #184]	; (c3ec <SystemInit+0xdc>)
    c334:	601a      	str	r2, [r3, #0]
        if (errata_103()){
    c336:	f7ff ff9b 	bl	c270 <errata_103>
    c33a:	b118      	cbz	r0, c344 <SystemInit+0x34>
            NRF_CCM->MAXPACKETSIZE = 0xFBul;
    c33c:	4b2c      	ldr	r3, [pc, #176]	; (c3f0 <SystemInit+0xe0>)
    c33e:	22fb      	movs	r2, #251	; 0xfb
    c340:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
        if (errata_115()){
    c344:	f7ff ffa6 	bl	c294 <errata_115>
    c348:	b148      	cbz	r0, c35e <SystemInit+0x4e>
            *(volatile uint32_t *)0x40000EE4 = (*(volatile uint32_t *)0x40000EE4 & 0xFFFFFFF0) | (*(uint32_t *)0x10000258 & 0x0000000F);
    c34a:	492a      	ldr	r1, [pc, #168]	; (c3f4 <SystemInit+0xe4>)
    c34c:	680b      	ldr	r3, [r1, #0]
    c34e:	f023 030f 	bic.w	r3, r3, #15
    c352:	4a29      	ldr	r2, [pc, #164]	; (c3f8 <SystemInit+0xe8>)
    c354:	6812      	ldr	r2, [r2, #0]
    c356:	f002 020f 	and.w	r2, r2, #15
    c35a:	4313      	orrs	r3, r2
    c35c:	600b      	str	r3, [r1, #0]
        if (errata_120()){
    c35e:	f7ff ffab 	bl	c2b8 <errata_120>
    c362:	b118      	cbz	r0, c36c <SystemInit+0x5c>
            *(volatile uint32_t *)0x40029640ul = 0x200ul;
    c364:	4b25      	ldr	r3, [pc, #148]	; (c3fc <SystemInit+0xec>)
    c366:	f44f 7200 	mov.w	r2, #512	; 0x200
    c36a:	601a      	str	r2, [r3, #0]
        if (errata_121()){
    c36c:	f7ff ffb6 	bl	c2dc <errata_121>
    c370:	b110      	cbz	r0, c378 <SystemInit+0x68>
            *(volatile uint32_t *)0x40029600ul = 0x00040400ul;
    c372:	4b23      	ldr	r3, [pc, #140]	; (c400 <SystemInit+0xf0>)
    c374:	4a23      	ldr	r2, [pc, #140]	; (c404 <SystemInit+0xf4>)
    c376:	601a      	str	r2, [r3, #0]
            if ((NRF_UICR->NFCPINS & UICR_NFCPINS_PROTECT_Msk) == (UICR_NFCPINS_PROTECT_NFC << UICR_NFCPINS_PROTECT_Pos)){
    c378:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
    c37c:	f8d3 320c 	ldr.w	r3, [r3, #524]	; 0x20c
    c380:	f013 0f01 	tst.w	r3, #1
    c384:	d104      	bne.n	c390 <SystemInit+0x80>
    SystemCoreClockUpdate();
    c386:	f7ff ffbb 	bl	c300 <SystemCoreClockUpdate>
    NVIC_Relocate();
    c38a:	f000 f8a1 	bl	c4d0 <NVIC_Relocate>
}
    c38e:	bd08      	pop	{r3, pc}
                NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Wen << NVMC_CONFIG_WEN_Pos;
    c390:	4b1d      	ldr	r3, [pc, #116]	; (c408 <SystemInit+0xf8>)
    c392:	2201      	movs	r2, #1
    c394:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
                while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
    c398:	4b1b      	ldr	r3, [pc, #108]	; (c408 <SystemInit+0xf8>)
    c39a:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
    c39e:	2b00      	cmp	r3, #0
    c3a0:	d0fa      	beq.n	c398 <SystemInit+0x88>
                NRF_UICR->NFCPINS &= ~UICR_NFCPINS_PROTECT_Msk;
    c3a2:	f04f 2210 	mov.w	r2, #268439552	; 0x10001000
    c3a6:	f8d2 320c 	ldr.w	r3, [r2, #524]	; 0x20c
    c3aa:	f023 0301 	bic.w	r3, r3, #1
    c3ae:	f8c2 320c 	str.w	r3, [r2, #524]	; 0x20c
                while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
    c3b2:	4b15      	ldr	r3, [pc, #84]	; (c408 <SystemInit+0xf8>)
    c3b4:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
    c3b8:	2b00      	cmp	r3, #0
    c3ba:	d0fa      	beq.n	c3b2 <SystemInit+0xa2>
                NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Ren << NVMC_CONFIG_WEN_Pos;
    c3bc:	4b12      	ldr	r3, [pc, #72]	; (c408 <SystemInit+0xf8>)
    c3be:	2200      	movs	r2, #0
    c3c0:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
                while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
    c3c4:	4b10      	ldr	r3, [pc, #64]	; (c408 <SystemInit+0xf8>)
    c3c6:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
    c3ca:	2b00      	cmp	r3, #0
    c3cc:	d0fa      	beq.n	c3c4 <SystemInit+0xb4>
    c3ce:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    c3d2:	490e      	ldr	r1, [pc, #56]	; (c40c <SystemInit+0xfc>)
    c3d4:	68ca      	ldr	r2, [r1, #12]
    c3d6:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
    c3da:	4b0d      	ldr	r3, [pc, #52]	; (c410 <SystemInit+0x100>)
    c3dc:	4313      	orrs	r3, r2
    c3de:	60cb      	str	r3, [r1, #12]
    c3e0:	f3bf 8f4f 	dsb	sy
    __NOP();
    c3e4:	bf00      	nop
  for(;;)                                                           /* wait until reset */
    c3e6:	e7fd      	b.n	c3e4 <SystemInit+0xd4>
    c3e8:	4000568c 	.word	0x4000568c
    c3ec:	00038148 	.word	0x00038148
    c3f0:	4000f000 	.word	0x4000f000
    c3f4:	40000ee4 	.word	0x40000ee4
    c3f8:	10000258 	.word	0x10000258
    c3fc:	40029640 	.word	0x40029640
    c400:	40029600 	.word	0x40029600
    c404:	00040400 	.word	0x00040400
    c408:	4001e000 	.word	0x4001e000
    c40c:	e000ed00 	.word	0xe000ed00
    c410:	05fa0004 	.word	0x05fa0004

0000c414 <_init>:
}

__attribute__((weak)) void
_init(void)
{
}
    c414:	4770      	bx	lr
	...

0000c418 <__libc_init_array>:
extern void (*__init_array_start[])(void);
extern void (*__init_array_end[])(void);

void
__libc_init_array(void)
{
    c418:	b538      	push	{r3, r4, r5, lr}
    size_t count;
    size_t i;

    count = __preinit_array_end - __preinit_array_start;
    c41a:	4d0e      	ldr	r5, [pc, #56]	; (c454 <__libc_init_array+0x3c>)
    c41c:	4b0e      	ldr	r3, [pc, #56]	; (c458 <__libc_init_array+0x40>)
    c41e:	1aed      	subs	r5, r5, r3
    c420:	10ad      	asrs	r5, r5, #2
    for (i = 0; i < count; i++)
    c422:	2400      	movs	r4, #0
    c424:	42ac      	cmp	r4, r5
    c426:	d205      	bcs.n	c434 <__libc_init_array+0x1c>
        __preinit_array_start[i]();
    c428:	4b0b      	ldr	r3, [pc, #44]	; (c458 <__libc_init_array+0x40>)
    c42a:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
    c42e:	4798      	blx	r3
    for (i = 0; i < count; i++)
    c430:	3401      	adds	r4, #1
    c432:	e7f7      	b.n	c424 <__libc_init_array+0xc>

    _init();
    c434:	f7ff ffee 	bl	c414 <_init>

    count = __init_array_end - __init_array_start;
    c438:	4d08      	ldr	r5, [pc, #32]	; (c45c <__libc_init_array+0x44>)
    c43a:	4b09      	ldr	r3, [pc, #36]	; (c460 <__libc_init_array+0x48>)
    c43c:	1aed      	subs	r5, r5, r3
    c43e:	10ad      	asrs	r5, r5, #2
    for (i = 0; i < count; i++)
    c440:	2400      	movs	r4, #0
    c442:	e004      	b.n	c44e <__libc_init_array+0x36>
        __init_array_start[i]();
    c444:	4b06      	ldr	r3, [pc, #24]	; (c460 <__libc_init_array+0x48>)
    c446:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
    c44a:	4798      	blx	r3
    for (i = 0; i < count; i++)
    c44c:	3401      	adds	r4, #1
    c44e:	42ac      	cmp	r4, r5
    c450:	d3f8      	bcc.n	c444 <__libc_init_array+0x2c>
}
    c452:	bd38      	pop	{r3, r4, r5, pc}
    c454:	00011820 	.word	0x00011820
    c458:	00011820 	.word	0x00011820
    c45c:	00011820 	.word	0x00011820
    c460:	00011820 	.word	0x00011820

0000c464 <_start>:
{
    c464:	b508      	push	{r3, lr}
        __libc_init_array();
    c466:	f7ff ffd7 	bl	c418 <__libc_init_array>
    os_init(main);
    c46a:	4803      	ldr	r0, [pc, #12]	; (c478 <_start+0x14>)
    c46c:	f000 f97e 	bl	c76c <os_init>
    os_start();
    c470:	f000 f9e8 	bl	c844 <os_start>
}
    c474:	bd08      	pop	{r3, pc}
    c476:	bf00      	nop
    c478:	0000c47d 	.word	0x0000c47d

0000c47c <main>:
 *
 * @return int NOTE: this function should never return!
 */
int
main(int argc, char **argv)
{
    c47c:	b508      	push	{r3, lr}

#ifdef ARCH_sim
    mcu_sim_parse_args(argc, argv);
#endif

    sysinit();
    c47e:	f002 fb75 	bl	eb6c <sysinit_start>
    c482:	f000 f811 	bl	c4a8 <sysinit_app>
    c486:	f002 fb77 	bl	eb78 <sysinit_end>
#endif

    while (1) {
#if UART_TEST
        /* Ensures prints show up over uART */
        console_printf("Hello world!\n");
    c48a:	4805      	ldr	r0, [pc, #20]	; (c4a0 <main+0x24>)
    c48c:	f001 fe82 	bl	e194 <console_printf>
        int result = 0;
        adc_read_channel(dev, 0, &result);
        console_printf("Result: %d\n", result);
#endif

        ++g_task1_loops;
    c490:	4a04      	ldr	r2, [pc, #16]	; (c4a4 <main+0x28>)
    c492:	6813      	ldr	r3, [r2, #0]
    c494:	3301      	adds	r3, #1
    c496:	6013      	str	r3, [r2, #0]

        /* Wait one second */
        os_time_delay(OS_TICKS_PER_SEC);
    c498:	2080      	movs	r0, #128	; 0x80
    c49a:	f000 fff1 	bl	d480 <os_time_delay>
    while (1) {
    c49e:	e7f4      	b.n	c48a <main+0xe>
    c4a0:	00011820 	.word	0x00011820
    c4a4:	20000160 	.word	0x20000160

0000c4a8 <sysinit_app>:
void log_init(void);
void bus_pkg_init(void);

void
sysinit_app(void)
{
    c4a8:	b508      	push	{r3, lr}
    /*** Stage 0 */
    /* 0.0: os_pkg_init (kernel/os) */
    os_pkg_init();
    c4aa:	f000 f9dd 	bl	c868 <os_pkg_init>

    /*** Stage 9 */
    /* 9.0: flash_map_init (sys/flash_map) */
    flash_map_init();
    c4ae:	f002 f86f 	bl	e590 <flash_map_init>

    /*** Stage 20 */
    /* 20.0: console_pkg_init (sys/console/full) */
    console_pkg_init();
    c4b2:	f001 fe21 	bl	e0f8 <console_pkg_init>

    /*** Stage 100 */
    /* 100.0: modlog_init (sys/log/modlog) */
    modlog_init();
    c4b6:	f002 faf1 	bl	ea9c <modlog_init>
    /* 100.1: log_init (sys/log/full) */
    log_init();
    c4ba:	f002 f8ab 	bl	e614 <log_init>
    /* 100.2: bus_pkg_init (hw/bus) */
    bus_pkg_init();
    c4be:	f000 f801 	bl	c4c4 <bus_pkg_init>
}
    c4c2:	bd08      	pop	{r3, pc}

0000c4c4 <bus_pkg_init>:
{
    uint32_t lock_timeout_ms;

    lock_timeout_ms = MYNEWT_VAL(BUS_DEFAULT_LOCK_TIMEOUT_MS);

    g_bus_node_lock_timeout = os_time_ms_to_ticks32(lock_timeout_ms);
    c4c4:	4b01      	ldr	r3, [pc, #4]	; (c4cc <bus_pkg_init+0x8>)
    c4c6:	2280      	movs	r2, #128	; 0x80
    c4c8:	601a      	str	r2, [r3, #0]
}
    c4ca:	4770      	bx	lr
    c4cc:	20000164 	.word	0x20000164

0000c4d0 <NVIC_Relocate>:
     * designated in the linker script.
     */
    current_location = (uint32_t *)&__isr_vector;
    new_location = (uint32_t *)&__vector_tbl_reloc__;

    if (new_location != current_location) {
    c4d0:	4a09      	ldr	r2, [pc, #36]	; (c4f8 <NVIC_Relocate+0x28>)
    c4d2:	4b0a      	ldr	r3, [pc, #40]	; (c4fc <NVIC_Relocate+0x2c>)
    c4d4:	429a      	cmp	r2, r3
    c4d6:	d00a      	beq.n	c4ee <NVIC_Relocate+0x1e>
        for (i = 0; i < NVIC_NUM_VECTORS; i++) {
    c4d8:	2300      	movs	r3, #0
    c4da:	e006      	b.n	c4ea <NVIC_Relocate+0x1a>
            new_location[i] = current_location[i];
    c4dc:	4a07      	ldr	r2, [pc, #28]	; (c4fc <NVIC_Relocate+0x2c>)
    c4de:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    c4e2:	4a05      	ldr	r2, [pc, #20]	; (c4f8 <NVIC_Relocate+0x28>)
    c4e4:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
        for (i = 0; i < NVIC_NUM_VECTORS; i++) {
    c4e8:	3301      	adds	r3, #1
    c4ea:	2b35      	cmp	r3, #53	; 0x35
    c4ec:	ddf6      	ble.n	c4dc <NVIC_Relocate+0xc>
    }

    /* Set VTOR except for M0 */
#if ((__CORTEX_M == 0) && (__VTOR_PRESENT == 0))
#else
    SCB->VTOR = (uint32_t)&__vector_tbl_reloc__;
    c4ee:	4a02      	ldr	r2, [pc, #8]	; (c4f8 <NVIC_Relocate+0x28>)
    c4f0:	4b03      	ldr	r3, [pc, #12]	; (c500 <NVIC_Relocate+0x30>)
    c4f2:	609a      	str	r2, [r3, #8]
#endif
}
    c4f4:	4770      	bx	lr
    c4f6:	bf00      	nop
    c4f8:	20000000 	.word	0x20000000
    c4fc:	0000c020 	.word	0x0000c020
    c500:	e000ed00 	.word	0xe000ed00

0000c504 <_sbrkInit>:
static char *brk;

void
_sbrkInit(char *base, char *limit)
{
    sbrk_base = base;
    c504:	4b03      	ldr	r3, [pc, #12]	; (c514 <_sbrkInit+0x10>)
    c506:	6018      	str	r0, [r3, #0]
    sbrk_limit = limit;
    c508:	4b03      	ldr	r3, [pc, #12]	; (c518 <_sbrkInit+0x14>)
    c50a:	6019      	str	r1, [r3, #0]
    brk = base;
    c50c:	4b03      	ldr	r3, [pc, #12]	; (c51c <_sbrkInit+0x18>)
    c50e:	6018      	str	r0, [r3, #0]
}
    c510:	4770      	bx	lr
    c512:	bf00      	nop
    c514:	2000016c 	.word	0x2000016c
    c518:	20000170 	.word	0x20000170
    c51c:	20000168 	.word	0x20000168

0000c520 <_sbrk>:

void *
_sbrk(int incr)
{
    c520:	4603      	mov	r3, r0
    char *prev_brk;
    char *new_brk = brk + incr;
    c522:	4a0a      	ldr	r2, [pc, #40]	; (c54c <_sbrk+0x2c>)
    c524:	6810      	ldr	r0, [r2, #0]
    c526:	4403      	add	r3, r0

    if (new_brk < sbrk_base || new_brk > sbrk_limit) {
    c528:	4a09      	ldr	r2, [pc, #36]	; (c550 <_sbrk+0x30>)
    c52a:	6812      	ldr	r2, [r2, #0]
    c52c:	429a      	cmp	r2, r3
    c52e:	d806      	bhi.n	c53e <_sbrk+0x1e>
    c530:	4a08      	ldr	r2, [pc, #32]	; (c554 <_sbrk+0x34>)
    c532:	6812      	ldr	r2, [r2, #0]
    c534:	429a      	cmp	r2, r3
    c536:	d305      	bcc.n	c544 <_sbrk+0x24>
        prev_brk = (char *)-1;
    } else {
        prev_brk = brk;
        brk = new_brk;
    c538:	4a04      	ldr	r2, [pc, #16]	; (c54c <_sbrk+0x2c>)
    c53a:	6013      	str	r3, [r2, #0]
    c53c:	4770      	bx	lr
        prev_brk = (char *)-1;
    c53e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    c542:	4770      	bx	lr
    c544:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    }

    return prev_brk;
}
    c548:	4770      	bx	lr
    c54a:	bf00      	nop
    c54c:	20000168 	.word	0x20000168
    c550:	2000016c 	.word	0x2000016c
    c554:	20000170 	.word	0x20000170

0000c558 <__assert_func>:
}
#endif

void
__assert_func(const char *file, int line, const char *func, const char *e)
{
    c558:	b508      	push	{r3, lr}
    c55a:	4675      	mov	r5, lr
    c55c:	4604      	mov	r4, r0
    c55e:	460e      	mov	r6, r1
#if MYNEWT_VAL(OS_CRASH_LOG)
    struct log_reboot_info lri;
#endif
    int sr;

    OS_ENTER_CRITICAL(sr);
    c560:	f000 ffb2 	bl	d4c8 <os_arch_save_sr>
    (void)sr;
    console_blocking_mode();
    c564:	f001 fcfc 	bl	df60 <console_blocking_mode>
    OS_PRINT_ASSERT(file, line, func, e);
    c568:	b16c      	cbz	r4, c586 <__assert_func+0x2e>
    c56a:	4633      	mov	r3, r6
    c56c:	4622      	mov	r2, r4
    c56e:	4629      	mov	r1, r5
    c570:	4807      	ldr	r0, [pc, #28]	; (c590 <__assert_func+0x38>)
    c572:	f001 fe0f 	bl	e194 <console_printf>

#if MYNEWT_VAL(OS_ASSERT_CB)
    os_assert_cb();
#endif

    SCB->ICSR = SCB_ICSR_NMIPENDSET_Msk;
    c576:	4b07      	ldr	r3, [pc, #28]	; (c594 <__assert_func+0x3c>)
    c578:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    c57c:	605a      	str	r2, [r3, #4]
    asm("isb");
    c57e:	f3bf 8f6f 	isb	sy
    hal_system_reset();
    c582:	f7ff fe13 	bl	c1ac <hal_system_reset>
    OS_PRINT_ASSERT(file, line, func, e);
    c586:	4629      	mov	r1, r5
    c588:	4803      	ldr	r0, [pc, #12]	; (c598 <__assert_func+0x40>)
    c58a:	f001 fe03 	bl	e194 <console_printf>
    c58e:	e7f2      	b.n	c576 <__assert_func+0x1e>
    c590:	00011840 	.word	0x00011840
    c594:	e000ed00 	.word	0xe000ed00
    c598:	00011830 	.word	0x00011830

0000c59c <os_default_irq>:
}

void
os_default_irq(struct trap_frame *tf)
{
    c59c:	b500      	push	{lr}
    c59e:	b083      	sub	sp, #12
    c5a0:	4604      	mov	r4, r0
#endif
#if MYNEWT_VAL(OS_CRASH_RESTORE_REGS)
    uint32_t orig_sp;
#endif

    console_blocking_mode();
    c5a2:	f001 fcdd 	bl	df60 <console_blocking_mode>
    console_printf("Unhandled interrupt (%ld), exception sp 0x%08lx\n",
      SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk, (uint32_t)tf->ef);
    c5a6:	4d1b      	ldr	r5, [pc, #108]	; (c614 <os_default_irq+0x78>)
    c5a8:	6869      	ldr	r1, [r5, #4]
    console_printf("Unhandled interrupt (%ld), exception sp 0x%08lx\n",
    c5aa:	6822      	ldr	r2, [r4, #0]
    c5ac:	f3c1 0108 	ubfx	r1, r1, #0, #9
    c5b0:	4819      	ldr	r0, [pc, #100]	; (c618 <os_default_irq+0x7c>)
    c5b2:	f001 fdef 	bl	e194 <console_printf>
    console_printf(" r0:0x%08lx  r1:0x%08lx  r2:0x%08lx  r3:0x%08lx\n",
      tf->ef->r0, tf->ef->r1, tf->ef->r2, tf->ef->r3);
    c5b6:	6820      	ldr	r0, [r4, #0]
    console_printf(" r0:0x%08lx  r1:0x%08lx  r2:0x%08lx  r3:0x%08lx\n",
    c5b8:	6883      	ldr	r3, [r0, #8]
    c5ba:	6842      	ldr	r2, [r0, #4]
    c5bc:	6801      	ldr	r1, [r0, #0]
    c5be:	68c0      	ldr	r0, [r0, #12]
    c5c0:	9000      	str	r0, [sp, #0]
    c5c2:	4816      	ldr	r0, [pc, #88]	; (c61c <os_default_irq+0x80>)
    c5c4:	f001 fde6 	bl	e194 <console_printf>
    console_printf(" r4:0x%08lx  r5:0x%08lx  r6:0x%08lx  r7:0x%08lx\n",
    c5c8:	6923      	ldr	r3, [r4, #16]
    c5ca:	9300      	str	r3, [sp, #0]
    c5cc:	68e3      	ldr	r3, [r4, #12]
    c5ce:	68a2      	ldr	r2, [r4, #8]
    c5d0:	6861      	ldr	r1, [r4, #4]
    c5d2:	4813      	ldr	r0, [pc, #76]	; (c620 <os_default_irq+0x84>)
    c5d4:	f001 fdde 	bl	e194 <console_printf>
      tf->r4, tf->r5, tf->r6, tf->r7);
    console_printf(" r8:0x%08lx  r9:0x%08lx r10:0x%08lx r11:0x%08lx\n",
    c5d8:	6a23      	ldr	r3, [r4, #32]
    c5da:	9300      	str	r3, [sp, #0]
    c5dc:	69e3      	ldr	r3, [r4, #28]
    c5de:	69a2      	ldr	r2, [r4, #24]
    c5e0:	6961      	ldr	r1, [r4, #20]
    c5e2:	4810      	ldr	r0, [pc, #64]	; (c624 <os_default_irq+0x88>)
    c5e4:	f001 fdd6 	bl	e194 <console_printf>
      tf->r8, tf->r9, tf->r10, tf->r11);
    console_printf("r12:0x%08lx  lr:0x%08lx  pc:0x%08lx psr:0x%08lx\n",
      tf->ef->r12, tf->ef->lr, tf->ef->pc, tf->ef->psr);
    c5e8:	6820      	ldr	r0, [r4, #0]
    console_printf("r12:0x%08lx  lr:0x%08lx  pc:0x%08lx psr:0x%08lx\n",
    c5ea:	6983      	ldr	r3, [r0, #24]
    c5ec:	6942      	ldr	r2, [r0, #20]
    c5ee:	6901      	ldr	r1, [r0, #16]
    c5f0:	69c0      	ldr	r0, [r0, #28]
    c5f2:	9000      	str	r0, [sp, #0]
    c5f4:	480c      	ldr	r0, [pc, #48]	; (c628 <os_default_irq+0x8c>)
    c5f6:	f001 fdcd 	bl	e194 <console_printf>
    console_printf("ICSR:0x%08lx HFSR:0x%08lx CFSR:0x%08lx\n",
    c5fa:	6869      	ldr	r1, [r5, #4]
    c5fc:	6aea      	ldr	r2, [r5, #44]	; 0x2c
    c5fe:	6aab      	ldr	r3, [r5, #40]	; 0x28
    c600:	480a      	ldr	r0, [pc, #40]	; (c62c <os_default_irq+0x90>)
    c602:	f001 fdc7 	bl	e194 <console_printf>
      SCB->ICSR, SCB->HFSR, SCB->CFSR);
    console_printf("BFAR:0x%08lx MMFAR:0x%08lx\n", SCB->BFAR, SCB->MMFAR);
    c606:	6ba9      	ldr	r1, [r5, #56]	; 0x38
    c608:	6b6a      	ldr	r2, [r5, #52]	; 0x34
    c60a:	4809      	ldr	r0, [pc, #36]	; (c630 <os_default_irq+0x94>)
    c60c:	f001 fdc2 	bl	e194 <console_printf>
            : "r0"
        );
    }
#endif

    hal_system_reset();
    c610:	f7ff fdcc 	bl	c1ac <hal_system_reset>
    c614:	e000ed00 	.word	0xe000ed00
    c618:	00011858 	.word	0x00011858
    c61c:	0001188c 	.word	0x0001188c
    c620:	000118c0 	.word	0x000118c0
    c624:	000118f4 	.word	0x000118f4
    c628:	00011928 	.word	0x00011928
    c62c:	0001195c 	.word	0x0001195c
    c630:	00011984 	.word	0x00011984

0000c634 <os_idle_task>:
 *
 * @param arg unused
 */
void
os_idle_task(void *arg)
{
    c634:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

    sanity_itvl_ticks = (MYNEWT_VAL(SANITY_INTERVAL) * OS_TICKS_PER_SEC) / 1000;
    sanity_last = 0;

#if MYNEWT_VAL(WATCHDOG_INTERVAL) > 0
    hal_watchdog_tickle();
    c636:	f003 fd53 	bl	100e0 <hal_watchdog_tickle>
    sanity_last = 0;
    c63a:	2600      	movs	r6, #0
    c63c:	e00e      	b.n	c65c <os_idle_task+0x28>
    while (1) {
        ++g_os_idle_ctr;

        now = os_time_get();
        if (OS_TIME_TICK_GEQ(now, sanity_last + sanity_itvl_ticks)) {
            os_sanity_run();
    c63e:	f000 fc87 	bl	cf50 <os_sanity_run>
#if MYNEWT_VAL(WATCHDOG_INTERVAL) > 0
            /* Tickle the watchdog after successfully running sanity */
            hal_watchdog_tickle();
    c642:	f003 fd4d 	bl	100e0 <hal_watchdog_tickle>
#if MYNEWT_VAL(OS_WATCHDOG_MONITOR)
            os_cputime_timer_stop(&os_wdog_monitor);
            os_cputime_timer_relative(&os_wdog_monitor, OS_WDOG_MONITOR_TMO);
#endif
#endif
            sanity_last = now;
    c646:	4626      	mov	r6, r4
    c648:	e014      	b.n	c674 <os_idle_task+0x40>
         * happens on next interval in case it was already performed on current
         * tick.
         */
        sanity_to_next = sanity_last + sanity_itvl_ticks - now;
        if ((int)sanity_to_next <= 0) {
            sanity_to_next += sanity_itvl_ticks;
    c64a:	f500 60f0 	add.w	r0, r0, #1920	; 0x780
    c64e:	e025      	b.n	c69c <os_idle_task+0x68>
        }
        iticks = min(iticks, sanity_to_next);

        if (iticks < MIN_IDLE_TICKS) {
            iticks = 0;
    c650:	2000      	movs	r0, #0
        /* Tell the architecture specific support to put the processor to sleep
         * for 'n' ticks.
         */

        os_trace_idle();
        os_tick_idle(iticks);
    c652:	f003 fc35 	bl	fec0 <os_tick_idle>
        OS_EXIT_CRITICAL(sr);
    c656:	4628      	mov	r0, r5
    c658:	f000 ff3c 	bl	d4d4 <os_arch_restore_sr>
        ++g_os_idle_ctr;
    c65c:	4a15      	ldr	r2, [pc, #84]	; (c6b4 <os_idle_task+0x80>)
    c65e:	6813      	ldr	r3, [r2, #0]
    c660:	3301      	adds	r3, #1
    c662:	6013      	str	r3, [r2, #0]
        now = os_time_get();
    c664:	f000 fee0 	bl	d428 <os_time_get>
    c668:	4604      	mov	r4, r0
        if (OS_TIME_TICK_GEQ(now, sanity_last + sanity_itvl_ticks)) {
    c66a:	f506 63f0 	add.w	r3, r6, #1920	; 0x780
    c66e:	1ac3      	subs	r3, r0, r3
    c670:	2b00      	cmp	r3, #0
    c672:	dae4      	bge.n	c63e <os_idle_task+0xa>
        OS_ENTER_CRITICAL(sr);
    c674:	f000 ff28 	bl	d4c8 <os_arch_save_sr>
    c678:	4605      	mov	r5, r0
        now = os_time_get();
    c67a:	f000 fed5 	bl	d428 <os_time_get>
    c67e:	4607      	mov	r7, r0
        sticks = os_sched_wakeup_ticks(now);
    c680:	f000 fda8 	bl	d1d4 <os_sched_wakeup_ticks>
    c684:	4604      	mov	r4, r0
        cticks = os_callout_wakeup_ticks(now);
    c686:	4638      	mov	r0, r7
    c688:	f000 f942 	bl	c910 <os_callout_wakeup_ticks>
        iticks = min(sticks, cticks);
    c68c:	4284      	cmp	r4, r0
    c68e:	bf28      	it	cs
    c690:	4604      	movcs	r4, r0
        sanity_to_next = sanity_last + sanity_itvl_ticks - now;
    c692:	f506 63f0 	add.w	r3, r6, #1920	; 0x780
    c696:	1bd8      	subs	r0, r3, r7
        if ((int)sanity_to_next <= 0) {
    c698:	2800      	cmp	r0, #0
    c69a:	ddd6      	ble.n	c64a <os_idle_task+0x16>
        iticks = min(iticks, sanity_to_next);
    c69c:	42a0      	cmp	r0, r4
    c69e:	bf28      	it	cs
    c6a0:	4620      	movcs	r0, r4
        if (iticks < MIN_IDLE_TICKS) {
    c6a2:	280b      	cmp	r0, #11
    c6a4:	d9d4      	bls.n	c650 <os_idle_task+0x1c>
        } else if (iticks > MAX_IDLE_TICKS) {
    c6a6:	f5b0 3f96 	cmp.w	r0, #76800	; 0x12c00
    c6aa:	d9d2      	bls.n	c652 <os_idle_task+0x1e>
            iticks = MAX_IDLE_TICKS;
    c6ac:	f44f 3096 	mov.w	r0, #76800	; 0x12c00
    c6b0:	e7cf      	b.n	c652 <os_idle_task+0x1e>
    c6b2:	bf00      	nop
    c6b4:	200002c8 	.word	0x200002c8

0000c6b8 <os_main>:
    return (g_os_started);
}

static void
os_main(void *arg)
{
    c6b8:	b508      	push	{r3, lr}
    c6ba:	4603      	mov	r3, r0
    int (*fn)(int argc, char **argv) = arg;

#if !MYNEWT_VAL(SELFTEST)
    fn(0, NULL);
    c6bc:	2100      	movs	r1, #0
    c6be:	4608      	mov	r0, r1
    c6c0:	4798      	blx	r3
    (void)fn;
    while (1) {
        os_eventq_run(os_eventq_dflt_get());
    }
#endif
    assert(0);
    c6c2:	f7ff fd6b 	bl	c19c <hal_debugger_connected>
    c6c6:	b100      	cbz	r0, c6ca <os_main+0x12>
    c6c8:	be01      	bkpt	0x0001
    c6ca:	2300      	movs	r3, #0
    c6cc:	461a      	mov	r2, r3
    c6ce:	4619      	mov	r1, r3
    c6d0:	4618      	mov	r0, r3
    c6d2:	f7ff ff41 	bl	c558 <__assert_func>
	...

0000c6d8 <os_started>:
}
    c6d8:	4b01      	ldr	r3, [pc, #4]	; (c6e0 <os_started+0x8>)
    c6da:	6818      	ldr	r0, [r3, #0]
    c6dc:	4770      	bx	lr
    c6de:	bf00      	nop
    c6e0:	20001320 	.word	0x20001320

0000c6e4 <os_init_idle_task>:
}
#endif

void
os_init_idle_task(void)
{
    c6e4:	b500      	push	{lr}
    c6e6:	b085      	sub	sp, #20
    int rc;

    rc = os_task_init(&g_idle_task, "idle", os_idle_task, NULL,
    c6e8:	2340      	movs	r3, #64	; 0x40
    c6ea:	9303      	str	r3, [sp, #12]
    c6ec:	4b1b      	ldr	r3, [pc, #108]	; (c75c <os_init_idle_task+0x78>)
    c6ee:	9302      	str	r3, [sp, #8]
    c6f0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    c6f4:	9301      	str	r3, [sp, #4]
    c6f6:	23ff      	movs	r3, #255	; 0xff
    c6f8:	9300      	str	r3, [sp, #0]
    c6fa:	2300      	movs	r3, #0
    c6fc:	4a18      	ldr	r2, [pc, #96]	; (c760 <os_init_idle_task+0x7c>)
    c6fe:	4919      	ldr	r1, [pc, #100]	; (c764 <os_init_idle_task+0x80>)
    c700:	4819      	ldr	r0, [pc, #100]	; (c768 <os_init_idle_task+0x84>)
    c702:	f000 fdcb 	bl	d29c <os_task_init>
            OS_IDLE_PRIO, OS_WAIT_FOREVER, g_idle_task_stack,
            OS_STACK_ALIGN(OS_IDLE_STACK_SIZE));
    assert(rc == 0);
    c706:	b950      	cbnz	r0, c71e <os_init_idle_task+0x3a>

    /* Initialize sanity */
    rc = os_sanity_init();
    c708:	f000 fc64 	bl	cfd4 <os_sanity_init>
    assert(rc == 0);
    c70c:	b988      	cbnz	r0, c732 <os_init_idle_task+0x4e>

#if MYNEWT_VAL(WATCHDOG_INTERVAL) > 0
    rc = hal_watchdog_init(MYNEWT_VAL(WATCHDOG_INTERVAL));
    c70e:	f247 5030 	movw	r0, #30000	; 0x7530
    c712:	f003 fc9d 	bl	10050 <hal_watchdog_init>
    assert(rc == 0);
    c716:	b9b0      	cbnz	r0, c746 <os_init_idle_task+0x62>
#if MYNEWT_VAL(OS_WATCHDOG_MONITOR)
    os_cputime_timer_init(&os_wdog_monitor, os_wdog_monitor_tmo, NULL);
    os_cputime_timer_relative(&os_wdog_monitor, OS_WDOG_MONITOR_TMO);
#endif
#endif
}
    c718:	b005      	add	sp, #20
    c71a:	f85d fb04 	ldr.w	pc, [sp], #4
    assert(rc == 0);
    c71e:	f7ff fd3d 	bl	c19c <hal_debugger_connected>
    c722:	b100      	cbz	r0, c726 <os_init_idle_task+0x42>
    c724:	be01      	bkpt	0x0001
    c726:	2300      	movs	r3, #0
    c728:	461a      	mov	r2, r3
    c72a:	4619      	mov	r1, r3
    c72c:	4618      	mov	r0, r3
    c72e:	f7ff ff13 	bl	c558 <__assert_func>
    assert(rc == 0);
    c732:	f7ff fd33 	bl	c19c <hal_debugger_connected>
    c736:	b100      	cbz	r0, c73a <os_init_idle_task+0x56>
    c738:	be01      	bkpt	0x0001
    c73a:	2300      	movs	r3, #0
    c73c:	461a      	mov	r2, r3
    c73e:	4619      	mov	r1, r3
    c740:	4618      	mov	r0, r3
    c742:	f7ff ff09 	bl	c558 <__assert_func>
    assert(rc == 0);
    c746:	f7ff fd29 	bl	c19c <hal_debugger_connected>
    c74a:	b100      	cbz	r0, c74e <os_init_idle_task+0x6a>
    c74c:	be01      	bkpt	0x0001
    c74e:	2300      	movs	r3, #0
    c750:	461a      	mov	r2, r3
    c752:	4619      	mov	r1, r3
    c754:	4618      	mov	r0, r3
    c756:	f7ff feff 	bl	c558 <__assert_func>
    c75a:	bf00      	nop
    c75c:	200001c8 	.word	0x200001c8
    c760:	0000c635 	.word	0x0000c635
    c764:	000119a0 	.word	0x000119a0
    c768:	20000174 	.word	0x20000174

0000c76c <os_init>:

void
os_init(int (*main_fn)(int argc, char **arg))
{
    c76c:	b510      	push	{r4, lr}
    c76e:	b084      	sub	sp, #16
    c770:	4604      	mov	r4, r0
#if MYNEWT_VAL(RTT)
    memset(&_SEGGER_RTT, 0, sizeof(_SEGGER_RTT));
    SEGGER_RTT_Init();
#endif

    TAILQ_INIT(&g_callout_list);
    c772:	4b2e      	ldr	r3, [pc, #184]	; (c82c <os_init+0xc0>)
    c774:	2200      	movs	r2, #0
    c776:	601a      	str	r2, [r3, #0]
    c778:	605b      	str	r3, [r3, #4]
    STAILQ_INIT(&g_os_task_list);
    c77a:	4b2d      	ldr	r3, [pc, #180]	; (c830 <os_init+0xc4>)
    c77c:	601a      	str	r2, [r3, #0]
    c77e:	605b      	str	r3, [r3, #4]
    os_eventq_init(os_eventq_dflt_get());
    c780:	f000 f9f6 	bl	cb70 <os_eventq_dflt_get>
    c784:	f000 f9a2 	bl	cacc <os_eventq_init>

    /* Initialize device list. */
    os_dev_reset();
    c788:	f000 f998 	bl	cabc <os_dev_reset>

    err = os_arch_os_init();
    c78c:	f000 fed8 	bl	d540 <os_arch_os_init>
    assert(err == OS_OK);
    c790:	bb18      	cbnz	r0, c7da <os_init+0x6e>

    if (main_fn) {
    c792:	b194      	cbz	r4, c7ba <os_init+0x4e>
        err = os_task_init(&g_os_main_task, "main", os_main, main_fn,
    c794:	f44f 6380 	mov.w	r3, #1024	; 0x400
    c798:	9303      	str	r3, [sp, #12]
    c79a:	4b26      	ldr	r3, [pc, #152]	; (c834 <os_init+0xc8>)
    c79c:	9302      	str	r3, [sp, #8]
    c79e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    c7a2:	9301      	str	r3, [sp, #4]
    c7a4:	237f      	movs	r3, #127	; 0x7f
    c7a6:	9300      	str	r3, [sp, #0]
    c7a8:	4623      	mov	r3, r4
    c7aa:	4a23      	ldr	r2, [pc, #140]	; (c838 <os_init+0xcc>)
    c7ac:	4923      	ldr	r1, [pc, #140]	; (c83c <os_init+0xd0>)
    c7ae:	4824      	ldr	r0, [pc, #144]	; (c840 <os_init+0xd4>)
    c7b0:	f000 fd74 	bl	d29c <os_task_init>
                   OS_MAIN_TASK_PRIO,
                   (OS_MAIN_TASK_TIMER_TICKS == 0) ? OS_WAIT_FOREVER : OS_MAIN_TASK_TIMER_TICKS,
                   g_os_main_stack, OS_STACK_ALIGN(OS_MAIN_STACK_SIZE));
        assert(err == 0);
    c7b4:	f010 0fff 	tst.w	r0, #255	; 0xff
    c7b8:	d119      	bne.n	c7ee <os_init+0x82>
    }

    /* Call bsp related OS initializations */
    hal_bsp_init();
    c7ba:	f003 fa2d 	bl	fc18 <hal_bsp_init>

    err = (os_error_t) os_dev_initialize_all(OS_DEV_INIT_PRIMARY);
    c7be:	2001      	movs	r0, #1
    c7c0:	f000 f934 	bl	ca2c <os_dev_initialize_all>
    assert(err == OS_OK);
    c7c4:	f010 0fff 	tst.w	r0, #255	; 0xff
    c7c8:	d11b      	bne.n	c802 <os_init+0x96>

    err = (os_error_t) os_dev_initialize_all(OS_DEV_INIT_SECONDARY);
    c7ca:	2002      	movs	r0, #2
    c7cc:	f000 f92e 	bl	ca2c <os_dev_initialize_all>
    assert(err == OS_OK);
    c7d0:	f010 0fff 	tst.w	r0, #255	; 0xff
    c7d4:	d11f      	bne.n	c816 <os_init+0xaa>
}
    c7d6:	b004      	add	sp, #16
    c7d8:	bd10      	pop	{r4, pc}
    assert(err == OS_OK);
    c7da:	f7ff fcdf 	bl	c19c <hal_debugger_connected>
    c7de:	b100      	cbz	r0, c7e2 <os_init+0x76>
    c7e0:	be01      	bkpt	0x0001
    c7e2:	2300      	movs	r3, #0
    c7e4:	461a      	mov	r2, r3
    c7e6:	4619      	mov	r1, r3
    c7e8:	4618      	mov	r0, r3
    c7ea:	f7ff feb5 	bl	c558 <__assert_func>
        assert(err == 0);
    c7ee:	f7ff fcd5 	bl	c19c <hal_debugger_connected>
    c7f2:	b100      	cbz	r0, c7f6 <os_init+0x8a>
    c7f4:	be01      	bkpt	0x0001
    c7f6:	2300      	movs	r3, #0
    c7f8:	461a      	mov	r2, r3
    c7fa:	4619      	mov	r1, r3
    c7fc:	4618      	mov	r0, r3
    c7fe:	f7ff feab 	bl	c558 <__assert_func>
    assert(err == OS_OK);
    c802:	f7ff fccb 	bl	c19c <hal_debugger_connected>
    c806:	b100      	cbz	r0, c80a <os_init+0x9e>
    c808:	be01      	bkpt	0x0001
    c80a:	2300      	movs	r3, #0
    c80c:	461a      	mov	r2, r3
    c80e:	4619      	mov	r1, r3
    c810:	4618      	mov	r0, r3
    c812:	f7ff fea1 	bl	c558 <__assert_func>
    assert(err == OS_OK);
    c816:	f7ff fcc1 	bl	c19c <hal_debugger_connected>
    c81a:	b100      	cbz	r0, c81e <os_init+0xb2>
    c81c:	be01      	bkpt	0x0001
    c81e:	2300      	movs	r3, #0
    c820:	461a      	mov	r2, r3
    c822:	4619      	mov	r1, r3
    c824:	4618      	mov	r0, r3
    c826:	f7ff fe97 	bl	c558 <__assert_func>
    c82a:	bf00      	nop
    c82c:	20001324 	.word	0x20001324
    c830:	2000213c 	.word	0x2000213c
    c834:	200002d0 	.word	0x200002d0
    c838:	0000c6b9 	.word	0x0000c6b9
    c83c:	000119a8 	.word	0x000119a8
    c840:	200012d0 	.word	0x200012d0

0000c844 <os_start>:

void
os_start(void)
{
    c844:	b508      	push	{r3, lr}
#if MYNEWT_VAL(OS_SCHEDULING)
    os_error_t err;

#if MYNEWT_VAL(WATCHDOG_INTERVAL) > 0
    /* Enable the watchdog prior to starting the OS */
    hal_watchdog_enable();
    c846:	f003 fc43 	bl	100d0 <hal_watchdog_enable>
#endif

    err = os_arch_os_start();
    c84a:	f000 fed9 	bl	d600 <os_arch_os_start>
    assert(err == OS_OK);
    c84e:	b900      	cbnz	r0, c852 <os_start+0xe>
#else
    assert(0);
#endif
}
    c850:	bd08      	pop	{r3, pc}
    assert(err == OS_OK);
    c852:	f7ff fca3 	bl	c19c <hal_debugger_connected>
    c856:	b100      	cbz	r0, c85a <os_start+0x16>
    c858:	be01      	bkpt	0x0001
    c85a:	2300      	movs	r3, #0
    c85c:	461a      	mov	r2, r3
    c85e:	4619      	mov	r1, r3
    c860:	4618      	mov	r0, r3
    c862:	f7ff fe79 	bl	c558 <__assert_func>
	...

0000c868 <os_pkg_init>:
    hal_system_reset();
}

void
os_pkg_init(void)
{
    c868:	b508      	push	{r3, lr}
    os_error_t err;

    /* Ensure this function only gets called by sysinit. */
    SYSINIT_ASSERT_ACTIVE();
    c86a:	4b11      	ldr	r3, [pc, #68]	; (c8b0 <os_pkg_init+0x48>)
    c86c:	781b      	ldrb	r3, [r3, #0]
    c86e:	b153      	cbz	r3, c886 <os_pkg_init+0x1e>

    err = os_dev_initialize_all(OS_DEV_INIT_KERNEL);
    c870:	2003      	movs	r0, #3
    c872:	f000 f8db 	bl	ca2c <os_dev_initialize_all>
    assert(err == OS_OK);
    c876:	f010 0fff 	tst.w	r0, #255	; 0xff
    c87a:	d10e      	bne.n	c89a <os_pkg_init+0x32>

    os_mempool_module_init();
    c87c:	f000 f9dc 	bl	cc38 <os_mempool_module_init>
    os_msys_init();
    c880:	f000 fa3c 	bl	ccfc <os_msys_init>
}
    c884:	bd08      	pop	{r3, pc}
    SYSINIT_ASSERT_ACTIVE();
    c886:	f7ff fc89 	bl	c19c <hal_debugger_connected>
    c88a:	b100      	cbz	r0, c88e <os_pkg_init+0x26>
    c88c:	be01      	bkpt	0x0001
    c88e:	2300      	movs	r3, #0
    c890:	461a      	mov	r2, r3
    c892:	4619      	mov	r1, r3
    c894:	4618      	mov	r0, r3
    c896:	f7ff fe5f 	bl	c558 <__assert_func>
    assert(err == OS_OK);
    c89a:	f7ff fc7f 	bl	c19c <hal_debugger_connected>
    c89e:	b100      	cbz	r0, c8a2 <os_pkg_init+0x3a>
    c8a0:	be01      	bkpt	0x0001
    c8a2:	2300      	movs	r3, #0
    c8a4:	461a      	mov	r2, r3
    c8a6:	4619      	mov	r1, r3
    c8a8:	4618      	mov	r0, r3
    c8aa:	f7ff fe55 	bl	c558 <__assert_func>
    c8ae:	bf00      	nop
    c8b0:	20002370 	.word	0x20002370

0000c8b4 <os_callout_tick>:
 * to run, it posts an event for each callout that's ready to run,
 * to the event queue provided to os_callout_init().
 */
void
os_callout_tick(void)
{
    c8b4:	b538      	push	{r3, r4, r5, lr}
    struct os_callout *c;
    uint32_t now;

    os_trace_api_void(OS_TRACE_ID_CALLOUT_TICK);

    now = os_time_get();
    c8b6:	f000 fdb7 	bl	d428 <os_time_get>
    c8ba:	4605      	mov	r5, r0
    c8bc:	e00f      	b.n	c8de <os_callout_tick+0x2a>
    while (1) {
        OS_ENTER_CRITICAL(sr);
        c = TAILQ_FIRST(&g_callout_list);
        if (c) {
            if (OS_TIME_TICK_GEQ(now, c->c_ticks)) {
                TAILQ_REMOVE(&g_callout_list, c, c_next);
    c8be:	69e2      	ldr	r2, [r4, #28]
    c8c0:	4b12      	ldr	r3, [pc, #72]	; (c90c <os_callout_tick+0x58>)
    c8c2:	605a      	str	r2, [r3, #4]
    c8c4:	69e3      	ldr	r3, [r4, #28]
    c8c6:	69a2      	ldr	r2, [r4, #24]
    c8c8:	601a      	str	r2, [r3, #0]
                c->c_next.tqe_prev = NULL;
    c8ca:	2300      	movs	r3, #0
    c8cc:	61e3      	str	r3, [r4, #28]
            } else {
                c = NULL;
            }
        }
        OS_EXIT_CRITICAL(sr);
    c8ce:	f000 fe01 	bl	d4d4 <os_arch_restore_sr>

        if (c) {
    c8d2:	b1d4      	cbz	r4, c90a <os_callout_tick+0x56>
            if (c->c_evq) {
    c8d4:	6920      	ldr	r0, [r4, #16]
    c8d6:	b1a0      	cbz	r0, c902 <os_callout_tick+0x4e>
                os_eventq_put(c->c_evq, &c->c_ev);
    c8d8:	4621      	mov	r1, r4
    c8da:	f000 f904 	bl	cae6 <os_eventq_put>
        OS_ENTER_CRITICAL(sr);
    c8de:	f000 fdf3 	bl	d4c8 <os_arch_save_sr>
        c = TAILQ_FIRST(&g_callout_list);
    c8e2:	4b0a      	ldr	r3, [pc, #40]	; (c90c <os_callout_tick+0x58>)
    c8e4:	681c      	ldr	r4, [r3, #0]
        if (c) {
    c8e6:	2c00      	cmp	r4, #0
    c8e8:	d0f1      	beq.n	c8ce <os_callout_tick+0x1a>
            if (OS_TIME_TICK_GEQ(now, c->c_ticks)) {
    c8ea:	6963      	ldr	r3, [r4, #20]
    c8ec:	1aeb      	subs	r3, r5, r3
    c8ee:	2b00      	cmp	r3, #0
    c8f0:	db05      	blt.n	c8fe <os_callout_tick+0x4a>
                TAILQ_REMOVE(&g_callout_list, c, c_next);
    c8f2:	69a3      	ldr	r3, [r4, #24]
    c8f4:	2b00      	cmp	r3, #0
    c8f6:	d0e2      	beq.n	c8be <os_callout_tick+0xa>
    c8f8:	69e2      	ldr	r2, [r4, #28]
    c8fa:	61da      	str	r2, [r3, #28]
    c8fc:	e7e2      	b.n	c8c4 <os_callout_tick+0x10>
                c = NULL;
    c8fe:	2400      	movs	r4, #0
    c900:	e7e5      	b.n	c8ce <os_callout_tick+0x1a>
            } else {
                c->c_ev.ev_cb(&c->c_ev);
    c902:	6863      	ldr	r3, [r4, #4]
    c904:	4620      	mov	r0, r4
    c906:	4798      	blx	r3
    c908:	e7e9      	b.n	c8de <os_callout_tick+0x2a>
            break;
        }
    }

    os_trace_api_ret(OS_TRACE_ID_CALLOUT_TICK);
}
    c90a:	bd38      	pop	{r3, r4, r5, pc}
    c90c:	20001324 	.word	0x20001324

0000c910 <os_callout_wakeup_ticks>:
 *
 * @return Number of ticks to first pending callout
 */
os_time_t
os_callout_wakeup_ticks(os_time_t now)
{
    c910:	b510      	push	{r4, lr}
    c912:	4604      	mov	r4, r0
    os_time_t rt;
    struct os_callout *c;

    OS_ASSERT_CRITICAL();
    c914:	f000 fde1 	bl	d4da <os_arch_in_critical>
    c918:	b130      	cbz	r0, c928 <os_callout_wakeup_ticks+0x18>

    c = TAILQ_FIRST(&g_callout_list);
    c91a:	4b0b      	ldr	r3, [pc, #44]	; (c948 <os_callout_wakeup_ticks+0x38>)
    c91c:	681b      	ldr	r3, [r3, #0]
    if (c != NULL) {
    c91e:	b17b      	cbz	r3, c940 <os_callout_wakeup_ticks+0x30>
        if (OS_TIME_TICK_GEQ(c->c_ticks, now)) {
    c920:	6958      	ldr	r0, [r3, #20]
    c922:	1b00      	subs	r0, r0, r4
    c924:	d40a      	bmi.n	c93c <os_callout_wakeup_ticks+0x2c>
    } else {
        rt = OS_TIMEOUT_NEVER;
    }

    return (rt);
}
    c926:	bd10      	pop	{r4, pc}
    OS_ASSERT_CRITICAL();
    c928:	f7ff fc38 	bl	c19c <hal_debugger_connected>
    c92c:	b100      	cbz	r0, c930 <os_callout_wakeup_ticks+0x20>
    c92e:	be01      	bkpt	0x0001
    c930:	2300      	movs	r3, #0
    c932:	461a      	mov	r2, r3
    c934:	4619      	mov	r1, r3
    c936:	4618      	mov	r0, r3
    c938:	f7ff fe0e 	bl	c558 <__assert_func>
            rt = 0;     /* callout time is in the past */
    c93c:	2000      	movs	r0, #0
    c93e:	e7f2      	b.n	c926 <os_callout_wakeup_ticks+0x16>
        rt = OS_TIMEOUT_NEVER;
    c940:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    return (rt);
    c944:	e7ef      	b.n	c926 <os_callout_wakeup_ticks+0x16>
    c946:	bf00      	nop
    c948:	20001324 	.word	0x20001324

0000c94c <os_dev_add>:
 *
 * @return 0 on success, non-zero on failure.
 */
static int
os_dev_add(struct os_dev *dev)
{
    c94c:	b430      	push	{r4, r5}
    struct os_dev *cur_dev;
    struct os_dev *prev_dev;

    /* If no devices present, insert into head */
    if (STAILQ_FIRST(&g_os_dev_list) == NULL) {
    c94e:	4b16      	ldr	r3, [pc, #88]	; (c9a8 <os_dev_add+0x5c>)
    c950:	681d      	ldr	r5, [r3, #0]
    c952:	b115      	cbz	r5, c95a <os_dev_add+0xe>
    /* Add devices to the list, sorted first by stage, then by
     * priority.  Keep sorted in this order for initialization
     * stage.
     */
    prev_dev = NULL;
    STAILQ_FOREACH(cur_dev, &g_os_dev_list, od_next) {
    c954:	462b      	mov	r3, r5
    prev_dev = NULL;
    c956:	2400      	movs	r4, #0
    c958:	e008      	b.n	c96c <os_dev_add+0x20>
        STAILQ_INSERT_HEAD(&g_os_dev_list, dev, od_next);
    c95a:	4603      	mov	r3, r0
    c95c:	f843 5f20 	str.w	r5, [r3, #32]!
    c960:	4a11      	ldr	r2, [pc, #68]	; (c9a8 <os_dev_add+0x5c>)
    c962:	6053      	str	r3, [r2, #4]
    c964:	6010      	str	r0, [r2, #0]
        return (0);
    c966:	e012      	b.n	c98e <os_dev_add+0x42>
        } else if (dev->od_stage < cur_dev->od_stage ||
                   ((dev->od_stage == cur_dev->od_stage) &&
                    (dev->od_priority < cur_dev->od_priority))) {
            break;
        }
        prev_dev = cur_dev;
    c968:	461c      	mov	r4, r3
    STAILQ_FOREACH(cur_dev, &g_os_dev_list, od_next) {
    c96a:	6a1b      	ldr	r3, [r3, #32]
    c96c:	b153      	cbz	r3, c984 <os_dev_add+0x38>
        if (dev == cur_dev) {
    c96e:	4283      	cmp	r3, r0
    c970:	d00d      	beq.n	c98e <os_dev_add+0x42>
        } else if (dev->od_stage < cur_dev->od_stage ||
    c972:	7e01      	ldrb	r1, [r0, #24]
    c974:	7e1a      	ldrb	r2, [r3, #24]
    c976:	4291      	cmp	r1, r2
    c978:	d304      	bcc.n	c984 <os_dev_add+0x38>
    c97a:	d1f5      	bne.n	c968 <os_dev_add+0x1c>
                    (dev->od_priority < cur_dev->od_priority))) {
    c97c:	7e41      	ldrb	r1, [r0, #25]
    c97e:	7e5a      	ldrb	r2, [r3, #25]
                   ((dev->od_stage == cur_dev->od_stage) &&
    c980:	4291      	cmp	r1, r2
    c982:	d2f1      	bcs.n	c968 <os_dev_add+0x1c>
    }

    if (prev_dev) {
    c984:	b15c      	cbz	r4, c99e <os_dev_add+0x52>
        STAILQ_INSERT_AFTER(&g_os_dev_list, prev_dev, dev, od_next);
    c986:	6a23      	ldr	r3, [r4, #32]
    c988:	6203      	str	r3, [r0, #32]
    c98a:	b11b      	cbz	r3, c994 <os_dev_add+0x48>
    c98c:	6220      	str	r0, [r4, #32]
    } else {
        STAILQ_INSERT_HEAD(&g_os_dev_list, dev, od_next);
    }

    return (0);
}
    c98e:	2000      	movs	r0, #0
    c990:	bc30      	pop	{r4, r5}
    c992:	4770      	bx	lr
        STAILQ_INSERT_AFTER(&g_os_dev_list, prev_dev, dev, od_next);
    c994:	f100 0320 	add.w	r3, r0, #32
    c998:	4a03      	ldr	r2, [pc, #12]	; (c9a8 <os_dev_add+0x5c>)
    c99a:	6053      	str	r3, [r2, #4]
    c99c:	e7f6      	b.n	c98c <os_dev_add+0x40>
        STAILQ_INSERT_HEAD(&g_os_dev_list, dev, od_next);
    c99e:	6205      	str	r5, [r0, #32]
    c9a0:	4b01      	ldr	r3, [pc, #4]	; (c9a8 <os_dev_add+0x5c>)
    c9a2:	6018      	str	r0, [r3, #0]
    c9a4:	e7f3      	b.n	c98e <os_dev_add+0x42>
    c9a6:	bf00      	nop
    c9a8:	2000132c 	.word	0x2000132c

0000c9ac <os_dev_initialize>:
 *
 * @return 0 on success, non-zero on failure.
 */
static int
os_dev_initialize(struct os_dev *dev)
{
    c9ac:	b510      	push	{r4, lr}
    c9ae:	4604      	mov	r4, r0
    int rc;

    rc = dev->od_init(dev, dev->od_init_arg);
    c9b0:	6903      	ldr	r3, [r0, #16]
    c9b2:	6941      	ldr	r1, [r0, #20]
    c9b4:	4798      	blx	r3
    if (rc != 0) {
    c9b6:	b128      	cbz	r0, c9c4 <os_dev_initialize+0x18>
        if (dev->od_flags & OS_DEV_F_INIT_CRITICAL) {
    c9b8:	7ee3      	ldrb	r3, [r4, #27]
    c9ba:	f013 0f08 	tst.w	r3, #8
    c9be:	d105      	bne.n	c9cc <os_dev_initialize+0x20>
            goto err;
        }
    } else {
        dev->od_flags |= OS_DEV_F_STATUS_READY;
    }
    return 0;
    c9c0:	2000      	movs	r0, #0
    c9c2:	e003      	b.n	c9cc <os_dev_initialize+0x20>
        dev->od_flags |= OS_DEV_F_STATUS_READY;
    c9c4:	7ee3      	ldrb	r3, [r4, #27]
    c9c6:	f043 0301 	orr.w	r3, r3, #1
    c9ca:	76e3      	strb	r3, [r4, #27]
err:
    return rc;
}
    c9cc:	bd10      	pop	{r4, pc}

0000c9ce <os_dev_init>:
{
    c9ce:	b410      	push	{r4}
    c9d0:	4604      	mov	r4, r0
    dev->od_name = name;
    c9d2:	61c1      	str	r1, [r0, #28]
    dev->od_stage = stage;
    c9d4:	7602      	strb	r2, [r0, #24]
    dev->od_priority = priority;
    c9d6:	7643      	strb	r3, [r0, #25]
    dev->od_flags = 0;
    c9d8:	2000      	movs	r0, #0
    c9da:	76e0      	strb	r0, [r4, #27]
    dev->od_open_ref = 0;
    c9dc:	76a0      	strb	r0, [r4, #26]
    dev->od_init = od_init;
    c9de:	9b01      	ldr	r3, [sp, #4]
    c9e0:	6123      	str	r3, [r4, #16]
    dev->od_init_arg = arg;
    c9e2:	9b02      	ldr	r3, [sp, #8]
    c9e4:	6163      	str	r3, [r4, #20]
    memset(&dev->od_handlers, 0, sizeof(dev->od_handlers));
    c9e6:	6020      	str	r0, [r4, #0]
    c9e8:	6060      	str	r0, [r4, #4]
    c9ea:	60a0      	str	r0, [r4, #8]
    c9ec:	60e0      	str	r0, [r4, #12]
}
    c9ee:	bc10      	pop	{r4}
    c9f0:	4770      	bx	lr
	...

0000c9f4 <os_dev_create>:

int
os_dev_create(struct os_dev *dev, const char *name, uint8_t stage,
        uint8_t priority, os_dev_init_func_t od_init, void *arg)
{
    c9f4:	b530      	push	{r4, r5, lr}
    c9f6:	b083      	sub	sp, #12
    c9f8:	4604      	mov	r4, r0
    int rc;

    rc = os_dev_init(dev, name, stage, priority, od_init, arg);
    c9fa:	9d07      	ldr	r5, [sp, #28]
    c9fc:	9501      	str	r5, [sp, #4]
    c9fe:	9d06      	ldr	r5, [sp, #24]
    ca00:	9500      	str	r5, [sp, #0]
    ca02:	f7ff ffe4 	bl	c9ce <os_dev_init>
    if (rc != 0) {
    ca06:	b108      	cbz	r0, ca0c <os_dev_create+0x18>
    if (g_os_started) {
        rc = os_dev_initialize(dev);
    }
err:
    return (rc);
}
    ca08:	b003      	add	sp, #12
    ca0a:	bd30      	pop	{r4, r5, pc}
    rc = os_dev_add(dev);
    ca0c:	4620      	mov	r0, r4
    ca0e:	f7ff ff9d 	bl	c94c <os_dev_add>
    if (rc != 0) {
    ca12:	2800      	cmp	r0, #0
    ca14:	d1f8      	bne.n	ca08 <os_dev_create+0x14>
    if (g_os_started) {
    ca16:	4b04      	ldr	r3, [pc, #16]	; (ca28 <os_dev_create+0x34>)
    ca18:	681b      	ldr	r3, [r3, #0]
    ca1a:	2b00      	cmp	r3, #0
    ca1c:	d0f4      	beq.n	ca08 <os_dev_create+0x14>
        rc = os_dev_initialize(dev);
    ca1e:	4620      	mov	r0, r4
    ca20:	f7ff ffc4 	bl	c9ac <os_dev_initialize>
    return (rc);
    ca24:	e7f0      	b.n	ca08 <os_dev_create+0x14>
    ca26:	bf00      	nop
    ca28:	20001320 	.word	0x20001320

0000ca2c <os_dev_initialize_all>:

int
os_dev_initialize_all(uint8_t stage)
{
    ca2c:	b538      	push	{r3, r4, r5, lr}
    ca2e:	4605      	mov	r5, r0
    struct os_dev *dev;
    int rc = 0;

    STAILQ_FOREACH(dev, &g_os_dev_list, od_next) {
    ca30:	4b08      	ldr	r3, [pc, #32]	; (ca54 <os_dev_initialize_all+0x28>)
    ca32:	681c      	ldr	r4, [r3, #0]
    int rc = 0;
    ca34:	2200      	movs	r2, #0
    STAILQ_FOREACH(dev, &g_os_dev_list, od_next) {
    ca36:	e000      	b.n	ca3a <os_dev_initialize_all+0xe>
    ca38:	6a24      	ldr	r4, [r4, #32]
    ca3a:	b144      	cbz	r4, ca4e <os_dev_initialize_all+0x22>
        if (dev->od_stage == stage) {
    ca3c:	7e23      	ldrb	r3, [r4, #24]
    ca3e:	42ab      	cmp	r3, r5
    ca40:	d1fa      	bne.n	ca38 <os_dev_initialize_all+0xc>
            rc = os_dev_initialize(dev);
    ca42:	4620      	mov	r0, r4
    ca44:	f7ff ffb2 	bl	c9ac <os_dev_initialize>
            if (rc) {
    ca48:	4602      	mov	r2, r0
    ca4a:	2800      	cmp	r0, #0
    ca4c:	d0f4      	beq.n	ca38 <os_dev_initialize_all+0xc>
            }
        }
    }

    return (rc);
}
    ca4e:	4610      	mov	r0, r2
    ca50:	bd38      	pop	{r3, r4, r5, pc}
    ca52:	bf00      	nop
    ca54:	2000132c 	.word	0x2000132c

0000ca58 <os_dev_lookup>:
    return (rc);
}

struct os_dev *
os_dev_lookup(const char *name)
{
    ca58:	b538      	push	{r3, r4, r5, lr}
    ca5a:	4605      	mov	r5, r0
    struct os_dev *dev;

    dev = NULL;
    STAILQ_FOREACH(dev, &g_os_dev_list, od_next) {
    ca5c:	4b05      	ldr	r3, [pc, #20]	; (ca74 <os_dev_lookup+0x1c>)
    ca5e:	681c      	ldr	r4, [r3, #0]
    ca60:	b134      	cbz	r4, ca70 <os_dev_lookup+0x18>
        if (!strcmp(dev->od_name, name)) {
    ca62:	4629      	mov	r1, r5
    ca64:	69e0      	ldr	r0, [r4, #28]
    ca66:	f000 feb4 	bl	d7d2 <strcmp>
    ca6a:	b108      	cbz	r0, ca70 <os_dev_lookup+0x18>
    STAILQ_FOREACH(dev, &g_os_dev_list, od_next) {
    ca6c:	6a24      	ldr	r4, [r4, #32]
    ca6e:	e7f7      	b.n	ca60 <os_dev_lookup+0x8>
            break;
        }
    }
    return (dev);
}
    ca70:	4620      	mov	r0, r4
    ca72:	bd38      	pop	{r3, r4, r5, pc}
    ca74:	2000132c 	.word	0x2000132c

0000ca78 <os_dev_open>:

struct os_dev *
os_dev_open(const char *devname, uint32_t timo, void *arg)
{
    ca78:	b570      	push	{r4, r5, r6, lr}
    ca7a:	460d      	mov	r5, r1
    ca7c:	4616      	mov	r6, r2
    struct os_dev *dev;
    os_sr_t sr;
    int rc;

    dev = os_dev_lookup(devname);
    ca7e:	f7ff ffeb 	bl	ca58 <os_dev_lookup>
    if (dev == NULL) {
    ca82:	4604      	mov	r4, r0
    ca84:	b1a0      	cbz	r0, cab0 <os_dev_open+0x38>
        return (NULL);
    }

    /* Device is not ready to be opened. */
    if ((dev->od_flags & OS_DEV_F_STATUS_READY) == 0) {
    ca86:	7ec3      	ldrb	r3, [r0, #27]
    ca88:	f013 0f01 	tst.w	r3, #1
    ca8c:	d012      	beq.n	cab4 <os_dev_open+0x3c>
        return (NULL);
    }

    if (dev->od_handlers.od_open) {
    ca8e:	6803      	ldr	r3, [r0, #0]
    ca90:	b11b      	cbz	r3, ca9a <os_dev_open+0x22>
        rc = dev->od_handlers.od_open(dev, timo, arg);
    ca92:	4632      	mov	r2, r6
    ca94:	4629      	mov	r1, r5
    ca96:	4798      	blx	r3
        if (rc != 0) {
    ca98:	b970      	cbnz	r0, cab8 <os_dev_open+0x40>
            goto err;
        }
    }

    OS_ENTER_CRITICAL(sr);
    ca9a:	f000 fd15 	bl	d4c8 <os_arch_save_sr>
    ++dev->od_open_ref;
    ca9e:	7ea3      	ldrb	r3, [r4, #26]
    caa0:	3301      	adds	r3, #1
    caa2:	76a3      	strb	r3, [r4, #26]
    dev->od_flags |= OS_DEV_F_STATUS_OPEN;
    caa4:	7ee3      	ldrb	r3, [r4, #27]
    caa6:	f043 0302 	orr.w	r3, r3, #2
    caaa:	76e3      	strb	r3, [r4, #27]
    OS_EXIT_CRITICAL(sr);
    caac:	f000 fd12 	bl	d4d4 <os_arch_restore_sr>

    return (dev);
err:
    return (NULL);
}
    cab0:	4620      	mov	r0, r4
    cab2:	bd70      	pop	{r4, r5, r6, pc}
        return (NULL);
    cab4:	2400      	movs	r4, #0
    cab6:	e7fb      	b.n	cab0 <os_dev_open+0x38>
    return (NULL);
    cab8:	2400      	movs	r4, #0
    caba:	e7f9      	b.n	cab0 <os_dev_open+0x38>

0000cabc <os_dev_reset>:
}

void
os_dev_reset(void)
{
    STAILQ_INIT(&g_os_dev_list);
    cabc:	4b02      	ldr	r3, [pc, #8]	; (cac8 <os_dev_reset+0xc>)
    cabe:	2200      	movs	r2, #0
    cac0:	601a      	str	r2, [r3, #0]
    cac2:	605b      	str	r3, [r3, #4]
}
    cac4:	4770      	bx	lr
    cac6:	bf00      	nop
    cac8:	2000132c 	.word	0x2000132c

0000cacc <os_eventq_init>:
static struct os_eventq os_eventq_main;

void
os_eventq_init(struct os_eventq *evq)
{
    memset(evq, 0, sizeof(*evq));
    cacc:	2200      	movs	r2, #0
    cace:	6002      	str	r2, [r0, #0]
    cad0:	6042      	str	r2, [r0, #4]
    STAILQ_INIT(&evq->evq_list);
    cad2:	4603      	mov	r3, r0
    cad4:	f843 2f08 	str.w	r2, [r3, #8]!
    cad8:	60c3      	str	r3, [r0, #12]
}
    cada:	4770      	bx	lr

0000cadc <os_eventq_inited>:

int
os_eventq_inited(const struct os_eventq *evq)
{
    return evq->evq_list.stqh_last != NULL;
    cadc:	68c0      	ldr	r0, [r0, #12]
}
    cade:	3800      	subs	r0, #0
    cae0:	bf18      	it	ne
    cae2:	2001      	movne	r0, #1
    cae4:	4770      	bx	lr

0000cae6 <os_eventq_put>:

void
os_eventq_put(struct os_eventq *evq, struct os_event *ev)
{
    cae6:	b570      	push	{r4, r5, r6, lr}
    int resched;
    os_sr_t sr;

    assert(evq != NULL && os_eventq_inited(evq));
    cae8:	b1f0      	cbz	r0, cb28 <os_eventq_put+0x42>
    caea:	460c      	mov	r4, r1
    caec:	4606      	mov	r6, r0
    caee:	f7ff fff5 	bl	cadc <os_eventq_inited>
    caf2:	b1c8      	cbz	r0, cb28 <os_eventq_put+0x42>

    os_trace_api_u32x2(OS_TRACE_ID_EVENTQ_PUT, (uint32_t)evq, (uint32_t)ev);

    OS_ENTER_CRITICAL(sr);
    caf4:	f000 fce8 	bl	d4c8 <os_arch_save_sr>
    caf8:	4605      	mov	r5, r0

    /* Do not queue if already queued */
    if (OS_EVENT_QUEUED(ev)) {
    cafa:	7823      	ldrb	r3, [r4, #0]
    cafc:	b9f3      	cbnz	r3, cb3c <os_eventq_put+0x56>
        os_trace_api_ret(OS_TRACE_ID_EVENTQ_PUT);
        return;
    }

    /* Queue the event */
    ev->ev_queued = 1;
    cafe:	2301      	movs	r3, #1
    cb00:	7023      	strb	r3, [r4, #0]
    STAILQ_INSERT_TAIL(&evq->evq_list, ev, ev_next);
    cb02:	2300      	movs	r3, #0
    cb04:	60e3      	str	r3, [r4, #12]
    cb06:	68f3      	ldr	r3, [r6, #12]
    cb08:	601c      	str	r4, [r3, #0]
    cb0a:	340c      	adds	r4, #12
    cb0c:	60f4      	str	r4, [r6, #12]

    resched = 0;
    if (evq->evq_task) {
    cb0e:	6870      	ldr	r0, [r6, #4]
    cb10:	b1d8      	cbz	r0, cb4a <os_eventq_put+0x64>
        /* If task waiting on event, wake it up.
         * Check if task is sleeping, because another event
         * queue may have woken this task up beforehand.
         */
        if (evq->evq_task->t_state == OS_TASK_SLEEP) {
    cb12:	7b03      	ldrb	r3, [r0, #12]
    cb14:	2b02      	cmp	r3, #2
    cb16:	d014      	beq.n	cb42 <os_eventq_put+0x5c>
    resched = 0;
    cb18:	2400      	movs	r4, #0
            resched = 1;
        }
        /* Either way, NULL out the task, because the task will
         * be awake upon exit of this function.
         */
        evq->evq_task = NULL;
    cb1a:	2300      	movs	r3, #0
    cb1c:	6073      	str	r3, [r6, #4]
    }

    OS_EXIT_CRITICAL(sr);
    cb1e:	4628      	mov	r0, r5
    cb20:	f000 fcd8 	bl	d4d4 <os_arch_restore_sr>

    if (resched) {
    cb24:	b99c      	cbnz	r4, cb4e <os_eventq_put+0x68>
        os_sched(NULL);
    }

    os_trace_api_ret(OS_TRACE_ID_EVENTQ_PUT);
}
    cb26:	bd70      	pop	{r4, r5, r6, pc}
    assert(evq != NULL && os_eventq_inited(evq));
    cb28:	f7ff fb38 	bl	c19c <hal_debugger_connected>
    cb2c:	b100      	cbz	r0, cb30 <os_eventq_put+0x4a>
    cb2e:	be01      	bkpt	0x0001
    cb30:	2300      	movs	r3, #0
    cb32:	461a      	mov	r2, r3
    cb34:	4619      	mov	r1, r3
    cb36:	4618      	mov	r0, r3
    cb38:	f7ff fd0e 	bl	c558 <__assert_func>
        OS_EXIT_CRITICAL(sr);
    cb3c:	f000 fcca 	bl	d4d4 <os_arch_restore_sr>
        return;
    cb40:	e7f1      	b.n	cb26 <os_eventq_put+0x40>
            os_sched_wakeup(evq->evq_task);
    cb42:	f000 fae5 	bl	d110 <os_sched_wakeup>
            resched = 1;
    cb46:	2401      	movs	r4, #1
    cb48:	e7e7      	b.n	cb1a <os_eventq_put+0x34>
    resched = 0;
    cb4a:	2400      	movs	r4, #0
    cb4c:	e7e7      	b.n	cb1e <os_eventq_put+0x38>
        os_sched(NULL);
    cb4e:	2000      	movs	r0, #0
    cb50:	f000 fb6a 	bl	d228 <os_sched>
    cb54:	e7e7      	b.n	cb26 <os_eventq_put+0x40>

0000cb56 <os_eventq_get_no_wait>:

struct os_event *
os_eventq_get_no_wait(struct os_eventq *evq)
{
    cb56:	4603      	mov	r3, r0
    struct os_event *ev;

    os_trace_api_u32(OS_TRACE_ID_EVENTQ_GET_NO_WAIT, (uint32_t)evq);

    ev = STAILQ_FIRST(&evq->evq_list);
    cb58:	6880      	ldr	r0, [r0, #8]
    if (ev) {
    cb5a:	b120      	cbz	r0, cb66 <os_eventq_get_no_wait+0x10>
        STAILQ_REMOVE(&evq->evq_list, ev, os_event, ev_next);
    cb5c:	68c2      	ldr	r2, [r0, #12]
    cb5e:	609a      	str	r2, [r3, #8]
    cb60:	b112      	cbz	r2, cb68 <os_eventq_get_no_wait+0x12>
        ev->ev_queued = 0;
    cb62:	2300      	movs	r3, #0
    cb64:	7003      	strb	r3, [r0, #0]
    }

    os_trace_api_ret_u32(OS_TRACE_ID_EVENTQ_GET_NO_WAIT, (uint32_t)ev);

    return ev;
}
    cb66:	4770      	bx	lr
        STAILQ_REMOVE(&evq->evq_list, ev, os_event, ev_next);
    cb68:	f103 0208 	add.w	r2, r3, #8
    cb6c:	60da      	str	r2, [r3, #12]
    cb6e:	e7f8      	b.n	cb62 <os_eventq_get_no_wait+0xc>

0000cb70 <os_eventq_dflt_get>:

struct os_eventq *
os_eventq_dflt_get(void)
{
    return &os_eventq_main;
}
    cb70:	4800      	ldr	r0, [pc, #0]	; (cb74 <os_eventq_dflt_get+0x4>)
    cb72:	4770      	bx	lr
    cb74:	20001334 	.word	0x20001334

0000cb78 <os_mempool_init_internal>:
    int i;
    uint8_t *block_addr;
    struct os_memblock *block_ptr;

    /* Check for valid parameters */
    if (!mp || (block_size == 0)) {
    cb78:	2800      	cmp	r0, #0
    cb7a:	d031      	beq.n	cbe0 <os_mempool_init_internal+0x68>
{
    cb7c:	b430      	push	{r4, r5}
    cb7e:	4604      	mov	r4, r0
    if (!mp || (block_size == 0)) {
    cb80:	2a00      	cmp	r2, #0
    cb82:	d02f      	beq.n	cbe4 <os_mempool_init_internal+0x6c>
        return OS_INVALID_PARM;
    }

    if ((!membuf) && (blocks != 0)) {
    cb84:	b1bb      	cbz	r3, cbb6 <os_mempool_init_internal+0x3e>
        return OS_INVALID_PARM;
    }

    if (membuf != NULL) {
    cb86:	b113      	cbz	r3, cb8e <os_mempool_init_internal+0x16>
        /* Blocks need to be sized properly and memory buffer should be
         * aligned
         */
        if (((uint32_t)membuf & (OS_ALIGNMENT - 1)) != 0) {
    cb88:	f013 0f03 	tst.w	r3, #3
    cb8c:	d12c      	bne.n	cbe8 <os_mempool_init_internal+0x70>
            return OS_MEM_NOT_ALIGNED;
        }
    }

    /* Initialize the memory pool structure */
    mp->mp_block_size = block_size;
    cb8e:	6022      	str	r2, [r4, #0]
    mp->mp_num_free = blocks;
    cb90:	80e1      	strh	r1, [r4, #6]
    mp->mp_min_free = blocks;
    cb92:	8121      	strh	r1, [r4, #8]
    mp->mp_flags = flags;
    cb94:	f89d 000c 	ldrb.w	r0, [sp, #12]
    cb98:	72a0      	strb	r0, [r4, #10]
    mp->mp_num_blocks = blocks;
    cb9a:	80a1      	strh	r1, [r4, #4]
    mp->mp_membuf_addr = (uint32_t)membuf;
    cb9c:	60e3      	str	r3, [r4, #12]
    mp->name = name;
    cb9e:	9802      	ldr	r0, [sp, #8]
    cba0:	61a0      	str	r0, [r4, #24]
    SLIST_FIRST(mp) = membuf;
    cba2:	6163      	str	r3, [r4, #20]

    if (blocks > 0) {
    cba4:	b199      	cbz	r1, cbce <os_mempool_init_internal+0x56>
        os_mempool_poison(mp, membuf);
        os_mempool_guard(mp, membuf);
        true_block_size = OS_MEMPOOL_TRUE_BLOCK_SIZE(mp);
    cba6:	f012 0f03 	tst.w	r2, #3
    cbaa:	d002      	beq.n	cbb2 <os_mempool_init_internal+0x3a>
    cbac:	f022 0203 	bic.w	r2, r2, #3
    cbb0:	3204      	adds	r2, #4

        /* Chain the memory blocks to the free list */
        block_addr = (uint8_t *)membuf;
        block_ptr = (struct os_memblock *)block_addr;
        for (i = 1; i < blocks; i++) {
    cbb2:	2001      	movs	r0, #1
    cbb4:	e007      	b.n	cbc6 <os_mempool_init_internal+0x4e>
    if ((!membuf) && (blocks != 0)) {
    cbb6:	2900      	cmp	r1, #0
    cbb8:	d0e5      	beq.n	cb86 <os_mempool_init_internal+0xe>
        return OS_INVALID_PARM;
    cbba:	2003      	movs	r0, #3
    cbbc:	e00e      	b.n	cbdc <os_mempool_init_internal+0x64>
            block_addr += true_block_size;
    cbbe:	189d      	adds	r5, r3, r2
            os_mempool_poison(mp, block_addr);
            os_mempool_guard(mp, block_addr);
            SLIST_NEXT(block_ptr, mb_next) = (struct os_memblock *)block_addr;
    cbc0:	601d      	str	r5, [r3, #0]
        for (i = 1; i < blocks; i++) {
    cbc2:	3001      	adds	r0, #1
            block_addr += true_block_size;
    cbc4:	462b      	mov	r3, r5
        for (i = 1; i < blocks; i++) {
    cbc6:	4281      	cmp	r1, r0
    cbc8:	dcf9      	bgt.n	cbbe <os_mempool_init_internal+0x46>
            block_ptr = (struct os_memblock *)block_addr;
        }

        /* Last one in the list should be NULL */
        SLIST_NEXT(block_ptr, mb_next) = NULL;
    cbca:	2200      	movs	r2, #0
    cbcc:	601a      	str	r2, [r3, #0]
    }

    STAILQ_INSERT_TAIL(&g_os_mempool_list, mp, mp_list);
    cbce:	2000      	movs	r0, #0
    cbd0:	6120      	str	r0, [r4, #16]
    cbd2:	4b06      	ldr	r3, [pc, #24]	; (cbec <os_mempool_init_internal+0x74>)
    cbd4:	685a      	ldr	r2, [r3, #4]
    cbd6:	6014      	str	r4, [r2, #0]
    cbd8:	3410      	adds	r4, #16
    cbda:	605c      	str	r4, [r3, #4]

    return OS_OK;
}
    cbdc:	bc30      	pop	{r4, r5}
    cbde:	4770      	bx	lr
        return OS_INVALID_PARM;
    cbe0:	2003      	movs	r0, #3
}
    cbe2:	4770      	bx	lr
        return OS_INVALID_PARM;
    cbe4:	2003      	movs	r0, #3
    cbe6:	e7f9      	b.n	cbdc <os_mempool_init_internal+0x64>
            return OS_MEM_NOT_ALIGNED;
    cbe8:	2004      	movs	r0, #4
    cbea:	e7f7      	b.n	cbdc <os_mempool_init_internal+0x64>
    cbec:	20001344 	.word	0x20001344

0000cbf0 <os_mempool_init>:

os_error_t
os_mempool_init(struct os_mempool *mp, uint16_t blocks, uint32_t block_size,
                void *membuf, char *name)
{
    cbf0:	b510      	push	{r4, lr}
    cbf2:	b082      	sub	sp, #8
    return os_mempool_init_internal(mp, blocks, block_size, membuf, name, 0);
    cbf4:	2400      	movs	r4, #0
    cbf6:	9401      	str	r4, [sp, #4]
    cbf8:	9c04      	ldr	r4, [sp, #16]
    cbfa:	9400      	str	r4, [sp, #0]
    cbfc:	f7ff ffbc 	bl	cb78 <os_mempool_init_internal>
}
    cc00:	b002      	add	sp, #8
    cc02:	bd10      	pop	{r4, pc}

0000cc04 <os_memblock_get>:
    return 1;
}

void *
os_memblock_get(struct os_mempool *mp)
{
    cc04:	b538      	push	{r3, r4, r5, lr}

    os_trace_api_u32(OS_TRACE_ID_MEMBLOCK_GET, (uint32_t)mp);

    /* Check to make sure they passed in a memory pool (or something) */
    block = NULL;
    if (mp) {
    cc06:	4604      	mov	r4, r0
    cc08:	b198      	cbz	r0, cc32 <os_memblock_get+0x2e>
        OS_ENTER_CRITICAL(sr);
    cc0a:	f000 fc5d 	bl	d4c8 <os_arch_save_sr>
        /* Check for any free */
        if (mp->mp_num_free) {
    cc0e:	88e3      	ldrh	r3, [r4, #6]
    cc10:	b153      	cbz	r3, cc28 <os_memblock_get+0x24>
            /* Get a free block */
            block = SLIST_FIRST(mp);
    cc12:	6965      	ldr	r5, [r4, #20]

            /* Set new free list head */
            SLIST_FIRST(mp) = SLIST_NEXT(block, mb_next);
    cc14:	682a      	ldr	r2, [r5, #0]
    cc16:	6162      	str	r2, [r4, #20]

            /* Decrement number free by 1 */
            mp->mp_num_free--;
    cc18:	3b01      	subs	r3, #1
    cc1a:	b29b      	uxth	r3, r3
    cc1c:	80e3      	strh	r3, [r4, #6]
            if (mp->mp_min_free > mp->mp_num_free) {
    cc1e:	8922      	ldrh	r2, [r4, #8]
    cc20:	4293      	cmp	r3, r2
    cc22:	d202      	bcs.n	cc2a <os_memblock_get+0x26>
                mp->mp_min_free = mp->mp_num_free;
    cc24:	8123      	strh	r3, [r4, #8]
    cc26:	e000      	b.n	cc2a <os_memblock_get+0x26>
    block = NULL;
    cc28:	2500      	movs	r5, #0
            }
        }
        OS_EXIT_CRITICAL(sr);
    cc2a:	f000 fc53 	bl	d4d4 <os_arch_restore_sr>
    }

    os_trace_api_ret_u32(OS_TRACE_ID_MEMBLOCK_GET, (uint32_t)block);

    return (void *)block;
}
    cc2e:	4628      	mov	r0, r5
    cc30:	bd38      	pop	{r3, r4, r5, pc}
    block = NULL;
    cc32:	4605      	mov	r5, r0
    return (void *)block;
    cc34:	e7fb      	b.n	cc2e <os_memblock_get+0x2a>
	...

0000cc38 <os_mempool_module_init>:
}

void
os_mempool_module_init(void)
{
    STAILQ_INIT(&g_os_mempool_list);
    cc38:	4b02      	ldr	r3, [pc, #8]	; (cc44 <os_mempool_module_init+0xc>)
    cc3a:	2200      	movs	r2, #0
    cc3c:	601a      	str	r2, [r3, #0]
    cc3e:	605b      	str	r3, [r3, #4]
}
    cc40:	4770      	bx	lr
    cc42:	bf00      	nop
    cc44:	20001344 	.word	0x20001344

0000cc48 <os_msys_register>:
static struct os_sanity_check os_msys_sc;
#endif

int
os_msys_register(struct os_mbuf_pool *new_pool)
{
    cc48:	b430      	push	{r4, r5}
    struct os_mbuf_pool *prev;

    /* We want to have order from smallest to biggest mempool. */
    prev = NULL;
    pool = NULL;
    STAILQ_FOREACH(pool, &g_msys_pool_list, omp_next) {
    cc4a:	4b11      	ldr	r3, [pc, #68]	; (cc90 <os_msys_register+0x48>)
    cc4c:	681d      	ldr	r5, [r3, #0]
    cc4e:	462b      	mov	r3, r5
    prev = NULL;
    cc50:	2400      	movs	r4, #0
    STAILQ_FOREACH(pool, &g_msys_pool_list, omp_next) {
    cc52:	b133      	cbz	r3, cc62 <os_msys_register+0x1a>
        if (new_pool->omp_databuf_len < pool->omp_databuf_len) {
    cc54:	8801      	ldrh	r1, [r0, #0]
    cc56:	881a      	ldrh	r2, [r3, #0]
    cc58:	4291      	cmp	r1, r2
    cc5a:	d302      	bcc.n	cc62 <os_msys_register+0x1a>
            break;
        }
        prev = pool;
    cc5c:	461c      	mov	r4, r3
    STAILQ_FOREACH(pool, &g_msys_pool_list, omp_next) {
    cc5e:	689b      	ldr	r3, [r3, #8]
    cc60:	e7f7      	b.n	cc52 <os_msys_register+0xa>
    }

    if (prev) {
    cc62:	b15c      	cbz	r4, cc7c <os_msys_register+0x34>
        STAILQ_INSERT_AFTER(&g_msys_pool_list, prev, new_pool, omp_next);
    cc64:	68a3      	ldr	r3, [r4, #8]
    cc66:	6083      	str	r3, [r0, #8]
    cc68:	b11b      	cbz	r3, cc72 <os_msys_register+0x2a>
    cc6a:	60a0      	str	r0, [r4, #8]
    } else {
        STAILQ_INSERT_HEAD(&g_msys_pool_list, new_pool, omp_next);
    }

    return (0);
}
    cc6c:	2000      	movs	r0, #0
    cc6e:	bc30      	pop	{r4, r5}
    cc70:	4770      	bx	lr
        STAILQ_INSERT_AFTER(&g_msys_pool_list, prev, new_pool, omp_next);
    cc72:	f100 0308 	add.w	r3, r0, #8
    cc76:	4a06      	ldr	r2, [pc, #24]	; (cc90 <os_msys_register+0x48>)
    cc78:	6053      	str	r3, [r2, #4]
    cc7a:	e7f6      	b.n	cc6a <os_msys_register+0x22>
        STAILQ_INSERT_HEAD(&g_msys_pool_list, new_pool, omp_next);
    cc7c:	6085      	str	r5, [r0, #8]
    cc7e:	b115      	cbz	r5, cc86 <os_msys_register+0x3e>
    cc80:	4b03      	ldr	r3, [pc, #12]	; (cc90 <os_msys_register+0x48>)
    cc82:	6018      	str	r0, [r3, #0]
    cc84:	e7f2      	b.n	cc6c <os_msys_register+0x24>
    cc86:	f100 0308 	add.w	r3, r0, #8
    cc8a:	4a01      	ldr	r2, [pc, #4]	; (cc90 <os_msys_register+0x48>)
    cc8c:	6053      	str	r3, [r2, #4]
    cc8e:	e7f7      	b.n	cc80 <os_msys_register+0x38>
    cc90:	20000104 	.word	0x20000104

0000cc94 <os_msys_init_once>:

static void
os_msys_init_once(void *data, struct os_mempool *mempool,
                  struct os_mbuf_pool *mbuf_pool,
                  int block_count, int block_size, char *name)
{
    cc94:	b530      	push	{r4, r5, lr}
    cc96:	b083      	sub	sp, #12
    cc98:	4614      	mov	r4, r2
    int rc;

    rc = mem_init_mbuf_pool(data, mempool, mbuf_pool, block_count, block_size,
    cc9a:	9d07      	ldr	r5, [sp, #28]
    cc9c:	9501      	str	r5, [sp, #4]
    cc9e:	9d06      	ldr	r5, [sp, #24]
    cca0:	9500      	str	r5, [sp, #0]
    cca2:	f001 ff6f 	bl	eb84 <mem_init_mbuf_pool>
                            name);
    SYSINIT_PANIC_ASSERT(rc == 0);
    cca6:	b928      	cbnz	r0, ccb4 <os_msys_init_once+0x20>

    rc = os_msys_register(mbuf_pool);
    cca8:	4620      	mov	r0, r4
    ccaa:	f7ff ffcd 	bl	cc48 <os_msys_register>
    SYSINIT_PANIC_ASSERT(rc == 0);
    ccae:	b970      	cbnz	r0, ccce <os_msys_init_once+0x3a>
}
    ccb0:	b003      	add	sp, #12
    ccb2:	bd30      	pop	{r4, r5, pc}
    SYSINIT_PANIC_ASSERT(rc == 0);
    ccb4:	f7ff fa72 	bl	c19c <hal_debugger_connected>
    ccb8:	b100      	cbz	r0, ccbc <os_msys_init_once+0x28>
    ccba:	be01      	bkpt	0x0001
    ccbc:	2000      	movs	r0, #0
    ccbe:	9000      	str	r0, [sp, #0]
    ccc0:	4b09      	ldr	r3, [pc, #36]	; (cce8 <os_msys_init_once+0x54>)
    ccc2:	681d      	ldr	r5, [r3, #0]
    ccc4:	4603      	mov	r3, r0
    ccc6:	4602      	mov	r2, r0
    ccc8:	4601      	mov	r1, r0
    ccca:	47a8      	blx	r5
    cccc:	e7ec      	b.n	cca8 <os_msys_init_once+0x14>
    SYSINIT_PANIC_ASSERT(rc == 0);
    ccce:	f7ff fa65 	bl	c19c <hal_debugger_connected>
    ccd2:	b100      	cbz	r0, ccd6 <os_msys_init_once+0x42>
    ccd4:	be01      	bkpt	0x0001
    ccd6:	2000      	movs	r0, #0
    ccd8:	9000      	str	r0, [sp, #0]
    ccda:	4b03      	ldr	r3, [pc, #12]	; (cce8 <os_msys_init_once+0x54>)
    ccdc:	681c      	ldr	r4, [r3, #0]
    ccde:	4603      	mov	r3, r0
    cce0:	4602      	mov	r2, r0
    cce2:	4601      	mov	r1, r0
    cce4:	47a0      	blx	r4
}
    cce6:	e7e3      	b.n	ccb0 <os_msys_init_once+0x1c>
    cce8:	20000130 	.word	0x20000130

0000ccec <os_msys_reset>:
    STAILQ_INIT(&g_msys_pool_list);
    ccec:	4b02      	ldr	r3, [pc, #8]	; (ccf8 <os_msys_reset+0xc>)
    ccee:	2200      	movs	r2, #0
    ccf0:	601a      	str	r2, [r3, #0]
    ccf2:	605b      	str	r3, [r3, #4]
}
    ccf4:	4770      	bx	lr
    ccf6:	bf00      	nop
    ccf8:	20000104 	.word	0x20000104

0000ccfc <os_msys_init>:

void
os_msys_init(void)
{
    ccfc:	b500      	push	{lr}
    ccfe:	b083      	sub	sp, #12
    int rc;

    os_msys_reset();
    cd00:	f7ff fff4 	bl	ccec <os_msys_reset>

    (void)os_msys_init_once;
    (void)rc;

#if MYNEWT_VAL(MSYS_1_BLOCK_COUNT) > 0
    os_msys_init_once(os_msys_1_data,
    cd04:	4b06      	ldr	r3, [pc, #24]	; (cd20 <os_msys_init+0x24>)
    cd06:	9301      	str	r3, [sp, #4]
    cd08:	f44f 7392 	mov.w	r3, #292	; 0x124
    cd0c:	9300      	str	r3, [sp, #0]
    cd0e:	230c      	movs	r3, #12
    cd10:	4a04      	ldr	r2, [pc, #16]	; (cd24 <os_msys_init+0x28>)
    cd12:	4905      	ldr	r1, [pc, #20]	; (cd28 <os_msys_init+0x2c>)
    cd14:	4805      	ldr	r0, [pc, #20]	; (cd2c <os_msys_init+0x30>)
    cd16:	f7ff ffbd 	bl	cc94 <os_msys_init_once>
    os_msys_sc.sc_checkin_itvl =
        OS_TICKS_PER_SEC * MYNEWT_VAL(MSYS_SANITY_TIMEOUT) / 1000;
    rc = os_sanity_check_register(&os_msys_sc);
    SYSINIT_PANIC_ASSERT(rc == 0);
#endif
}
    cd1a:	b003      	add	sp, #12
    cd1c:	f85d fb04 	ldr.w	pc, [sp], #4
    cd20:	000119b0 	.word	0x000119b0
    cd24:	200020fc 	.word	0x200020fc
    cd28:	20002108 	.word	0x20002108
    cd2c:	2000134c 	.word	0x2000134c

0000cd30 <os_mutex_init>:
os_error_t
os_mutex_init(struct os_mutex *mu)
{
    os_error_t ret;

    if (!mu) {
    cd30:	4603      	mov	r3, r0
    cd32:	b128      	cbz	r0, cd40 <os_mutex_init+0x10>
    }

    os_trace_api_u32(OS_TRACE_ID_MUTEX_INIT, (uint32_t)mu);

    /* Initialize to 0 */
    mu->mu_prio = 0;
    cd34:	2000      	movs	r0, #0
    cd36:	7158      	strb	r0, [r3, #5]
    mu->mu_level = 0;
    cd38:	80d8      	strh	r0, [r3, #6]
    mu->mu_owner = NULL;
    cd3a:	6098      	str	r0, [r3, #8]
    SLIST_FIRST(&mu->mu_head) = NULL;
    cd3c:	6018      	str	r0, [r3, #0]

    ret = OS_OK;
    cd3e:	4770      	bx	lr
        ret = OS_INVALID_PARM;
    cd40:	2003      	movs	r0, #3

done:
    os_trace_api_ret_u32(OS_TRACE_ID_MUTEX_INIT, (uint32_t)ret);
    return ret;
}
    cd42:	4770      	bx	lr

0000cd44 <os_mutex_release>:

os_error_t
os_mutex_release(struct os_mutex *mu)
{
    cd44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    os_error_t ret;

    os_trace_api_u32(OS_TRACE_ID_MUTEX_RELEASE, (uint32_t)mu);

    /* Check if OS is started */
    if (!g_os_started) {
    cd46:	4b2e      	ldr	r3, [pc, #184]	; (ce00 <os_mutex_release+0xbc>)
    cd48:	681b      	ldr	r3, [r3, #0]
    cd4a:	2b00      	cmp	r3, #0
    cd4c:	d050      	beq.n	cdf0 <os_mutex_release+0xac>
    cd4e:	4604      	mov	r4, r0
        ret = OS_NOT_STARTED;
        goto done;
    }

    /* Check for valid mutex */
    if (!mu) {
    cd50:	2800      	cmp	r0, #0
    cd52:	d04f      	beq.n	cdf4 <os_mutex_release+0xb0>
        ret = OS_INVALID_PARM;
        goto done;
    }

    /* We better own this mutex! */
    current = os_sched_get_current_task();
    cd54:	f000 f988 	bl	d068 <os_sched_get_current_task>
    cd58:	4605      	mov	r5, r0
    if ((mu->mu_level == 0) || (mu->mu_owner != current)) {
    cd5a:	88e3      	ldrh	r3, [r4, #6]
    cd5c:	2b00      	cmp	r3, #0
    cd5e:	d04b      	beq.n	cdf8 <os_mutex_release+0xb4>
    cd60:	68a2      	ldr	r2, [r4, #8]
    cd62:	4282      	cmp	r2, r0
    cd64:	d14a      	bne.n	cdfc <os_mutex_release+0xb8>
        ret = OS_BAD_MUTEX;
        goto done;
    }

    /* Don't release if nested, just decrement nesting level */
    if (mu->mu_level != 1) {
    cd66:	2b01      	cmp	r3, #1
    cd68:	d003      	beq.n	cd72 <os_mutex_release+0x2e>
        --mu->mu_level;
    cd6a:	3b01      	subs	r3, #1
    cd6c:	80e3      	strh	r3, [r4, #6]
        ret = OS_OK;
    cd6e:	2000      	movs	r0, #0
        goto done;
    cd70:	e03f      	b.n	cdf2 <os_mutex_release+0xae>
    }

    OS_ENTER_CRITICAL(sr);
    cd72:	f000 fba9 	bl	d4c8 <os_arch_save_sr>
    cd76:	4607      	mov	r7, r0

    /* Decrement nesting level (this effectively sets nesting level to 0) */
    --mu->mu_level;
    cd78:	88e3      	ldrh	r3, [r4, #6]
    cd7a:	3b01      	subs	r3, #1
    cd7c:	80e3      	strh	r3, [r4, #6]

    /* Restore owner task's priority; resort list if different  */
    if (current->t_prio != mu->mu_prio) {
    cd7e:	7aea      	ldrb	r2, [r5, #11]
    cd80:	7963      	ldrb	r3, [r4, #5]
    cd82:	429a      	cmp	r2, r3
    cd84:	d11e      	bne.n	cdc4 <os_mutex_release+0x80>
        current->t_prio = mu->mu_prio;
        os_sched_resort(current);
    }

    /* Check if tasks are waiting for the mutex */
    rdy = SLIST_FIRST(&mu->mu_head);
    cd86:	6826      	ldr	r6, [r4, #0]
    if (rdy) {
    cd88:	b146      	cbz	r6, cd9c <os_mutex_release+0x58>
        /* There is one waiting. Wake it up */
        assert(rdy->t_obj);
    cd8a:	69f3      	ldr	r3, [r6, #28]
    cd8c:	b1fb      	cbz	r3, cdce <os_mutex_release+0x8a>
        os_sched_wakeup(rdy);
    cd8e:	4630      	mov	r0, r6
    cd90:	f000 f9be 	bl	d110 <os_sched_wakeup>

        /* Set mutex internals */
        mu->mu_level = 1;
    cd94:	2301      	movs	r3, #1
    cd96:	80e3      	strh	r3, [r4, #6]
        mu->mu_prio = rdy->t_prio;
    cd98:	7af3      	ldrb	r3, [r6, #11]
    cd9a:	7163      	strb	r3, [r4, #5]
    }

    /* Set new owner of mutex (or NULL if not owned) */
    mu->mu_owner = rdy;
    cd9c:	60a6      	str	r6, [r4, #8]
    if (rdy) {
    cd9e:	b116      	cbz	r6, cda6 <os_mutex_release+0x62>
        rdy->t_lockcnt++;
    cda0:	7bb3      	ldrb	r3, [r6, #14]
    cda2:	3301      	adds	r3, #1
    cda4:	73b3      	strb	r3, [r6, #14]
    }
    --current->t_lockcnt;
    cda6:	7bab      	ldrb	r3, [r5, #14]
    cda8:	3b01      	subs	r3, #1
    cdaa:	73ab      	strb	r3, [r5, #14]

    /* Do we need to re-schedule? */
    resched = 0;
    rdy = os_sched_next_task();
    cdac:	f000 fa36 	bl	d21c <os_sched_next_task>
    cdb0:	4604      	mov	r4, r0
    if (rdy != current) {
    cdb2:	4285      	cmp	r5, r0
    cdb4:	d015      	beq.n	cde2 <os_mutex_release+0x9e>
        resched = 1;
    cdb6:	2501      	movs	r5, #1
    }
    OS_EXIT_CRITICAL(sr);
    cdb8:	4638      	mov	r0, r7
    cdba:	f000 fb8b 	bl	d4d4 <os_arch_restore_sr>

    /* Re-schedule if needed */
    if (resched) {
    cdbe:	b995      	cbnz	r5, cde6 <os_mutex_release+0xa2>
        os_sched(rdy);
    }

    ret = OS_OK;
    cdc0:	2000      	movs	r0, #0
    cdc2:	e016      	b.n	cdf2 <os_mutex_release+0xae>
        current->t_prio = mu->mu_prio;
    cdc4:	72eb      	strb	r3, [r5, #11]
        os_sched_resort(current);
    cdc6:	4628      	mov	r0, r5
    cdc8:	f000 fa40 	bl	d24c <os_sched_resort>
    cdcc:	e7db      	b.n	cd86 <os_mutex_release+0x42>
        assert(rdy->t_obj);
    cdce:	f7ff f9e5 	bl	c19c <hal_debugger_connected>
    cdd2:	b100      	cbz	r0, cdd6 <os_mutex_release+0x92>
    cdd4:	be01      	bkpt	0x0001
    cdd6:	2300      	movs	r3, #0
    cdd8:	461a      	mov	r2, r3
    cdda:	4619      	mov	r1, r3
    cddc:	4618      	mov	r0, r3
    cdde:	f7ff fbbb 	bl	c558 <__assert_func>
    resched = 0;
    cde2:	2500      	movs	r5, #0
    cde4:	e7e8      	b.n	cdb8 <os_mutex_release+0x74>
        os_sched(rdy);
    cde6:	4620      	mov	r0, r4
    cde8:	f000 fa1e 	bl	d228 <os_sched>
    ret = OS_OK;
    cdec:	2000      	movs	r0, #0
    cdee:	e000      	b.n	cdf2 <os_mutex_release+0xae>
        ret = OS_NOT_STARTED;
    cdf0:	2009      	movs	r0, #9

done:
    os_trace_api_ret_u32(OS_TRACE_ID_MUTEX_RELEASE, (uint32_t)ret);
    return ret;
}
    cdf2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        ret = OS_INVALID_PARM;
    cdf4:	2003      	movs	r0, #3
    cdf6:	e7fc      	b.n	cdf2 <os_mutex_release+0xae>
        ret = OS_BAD_MUTEX;
    cdf8:	2005      	movs	r0, #5
    cdfa:	e7fa      	b.n	cdf2 <os_mutex_release+0xae>
    cdfc:	2005      	movs	r0, #5
    cdfe:	e7f8      	b.n	cdf2 <os_mutex_release+0xae>
    ce00:	20001320 	.word	0x20001320

0000ce04 <os_mutex_pend>:
    struct os_task *last;

    os_trace_api_u32x2(OS_TRACE_ID_MUTEX_PEND, (uint32_t)mu, (uint32_t)timeout);

    /* OS must be started when calling this function */
    if (!g_os_started) {
    ce04:	4b36      	ldr	r3, [pc, #216]	; (cee0 <os_mutex_pend+0xdc>)
    ce06:	681b      	ldr	r3, [r3, #0]
    ce08:	2b00      	cmp	r3, #0
    ce0a:	d065      	beq.n	ced8 <os_mutex_pend+0xd4>
{
    ce0c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    ce10:	4605      	mov	r5, r0
    ce12:	460f      	mov	r7, r1
        ret = OS_NOT_STARTED;
        goto done;
    }

    /* Check for valid mutex */
    if (!mu) {
    ce14:	2800      	cmp	r0, #0
    ce16:	d061      	beq.n	cedc <os_mutex_pend+0xd8>
        ret = OS_INVALID_PARM;
        goto done;
    }

    OS_ENTER_CRITICAL(sr);
    ce18:	f000 fb56 	bl	d4c8 <os_arch_save_sr>
    ce1c:	4680      	mov	r8, r0

    /* Is this owned? */
    current = os_sched_get_current_task();
    ce1e:	f000 f923 	bl	d068 <os_sched_get_current_task>
    ce22:	4604      	mov	r4, r0
    if (mu->mu_level == 0) {
    ce24:	88ea      	ldrh	r2, [r5, #6]
    ce26:	b19a      	cbz	r2, ce50 <os_mutex_pend+0x4c>
        ret = OS_OK;
        goto done;
    }

    /* Are we owner? */
    if (mu->mu_owner == current) {
    ce28:	68ab      	ldr	r3, [r5, #8]
    ce2a:	4283      	cmp	r3, r0
    ce2c:	d01d      	beq.n	ce6a <os_mutex_pend+0x66>
        ret = OS_OK;
        goto done;
    }

    /* Mutex is not owned by us. If timeout is 0, return immediately */
    if (timeout == 0) {
    ce2e:	b31f      	cbz	r7, ce78 <os_mutex_pend+0x74>
        ret = OS_TIMEOUT;
        goto done;
    }

    /* Change priority of owner if needed */
    if (mu->mu_owner->t_prio > current->t_prio) {
    ce30:	7ad9      	ldrb	r1, [r3, #11]
    ce32:	7ac2      	ldrb	r2, [r0, #11]
    ce34:	4291      	cmp	r1, r2
    ce36:	d824      	bhi.n	ce82 <os_mutex_pend+0x7e>
        os_sched_resort(mu->mu_owner);
    }

    /* Link current task to tasks waiting for mutex */
    last = NULL;
    if (!SLIST_EMPTY(&mu->mu_head)) {
    ce38:	6828      	ldr	r0, [r5, #0]
    ce3a:	b360      	cbz	r0, ce96 <os_mutex_pend+0x92>
        /* Insert in priority order */
        SLIST_FOREACH(entry, &mu->mu_head, t_obj_list) {
    ce3c:	4603      	mov	r3, r0
    last = NULL;
    ce3e:	2100      	movs	r1, #0
        SLIST_FOREACH(entry, &mu->mu_head, t_obj_list) {
    ce40:	b323      	cbz	r3, ce8c <os_mutex_pend+0x88>
            if (current->t_prio < entry->t_prio) {
    ce42:	7ae6      	ldrb	r6, [r4, #11]
    ce44:	7ada      	ldrb	r2, [r3, #11]
    ce46:	4296      	cmp	r6, r2
    ce48:	d320      	bcc.n	ce8c <os_mutex_pend+0x88>
                break;
            }
            last = entry;
    ce4a:	4619      	mov	r1, r3
        SLIST_FOREACH(entry, &mu->mu_head, t_obj_list) {
    ce4c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    ce4e:	e7f7      	b.n	ce40 <os_mutex_pend+0x3c>
        mu->mu_owner = current;
    ce50:	60a8      	str	r0, [r5, #8]
        mu->mu_prio  = current->t_prio;
    ce52:	7ac3      	ldrb	r3, [r0, #11]
    ce54:	716b      	strb	r3, [r5, #5]
        current->t_lockcnt++;
    ce56:	7b83      	ldrb	r3, [r0, #14]
    ce58:	3301      	adds	r3, #1
    ce5a:	7383      	strb	r3, [r0, #14]
        mu->mu_level = 1;
    ce5c:	2301      	movs	r3, #1
    ce5e:	80eb      	strh	r3, [r5, #6]
        OS_EXIT_CRITICAL(sr);
    ce60:	4640      	mov	r0, r8
    ce62:	f000 fb37 	bl	d4d4 <os_arch_restore_sr>
        ret = OS_OK;
    ce66:	2000      	movs	r0, #0
        goto done;
    ce68:	e032      	b.n	ced0 <os_mutex_pend+0xcc>
        ++mu->mu_level;
    ce6a:	3201      	adds	r2, #1
    ce6c:	80ea      	strh	r2, [r5, #6]
        OS_EXIT_CRITICAL(sr);
    ce6e:	4640      	mov	r0, r8
    ce70:	f000 fb30 	bl	d4d4 <os_arch_restore_sr>
        ret = OS_OK;
    ce74:	2000      	movs	r0, #0
        goto done;
    ce76:	e02b      	b.n	ced0 <os_mutex_pend+0xcc>
        OS_EXIT_CRITICAL(sr);
    ce78:	4640      	mov	r0, r8
    ce7a:	f000 fb2b 	bl	d4d4 <os_arch_restore_sr>
        ret = OS_TIMEOUT;
    ce7e:	2006      	movs	r0, #6
        goto done;
    ce80:	e026      	b.n	ced0 <os_mutex_pend+0xcc>
        mu->mu_owner->t_prio = current->t_prio;
    ce82:	72da      	strb	r2, [r3, #11]
        os_sched_resort(mu->mu_owner);
    ce84:	68a8      	ldr	r0, [r5, #8]
    ce86:	f000 f9e1 	bl	d24c <os_sched_resort>
    ce8a:	e7d5      	b.n	ce38 <os_mutex_pend+0x34>
        }
    }

    if (last) {
    ce8c:	b119      	cbz	r1, ce96 <os_mutex_pend+0x92>
        SLIST_INSERT_AFTER(last, current, t_obj_list);
    ce8e:	6ccb      	ldr	r3, [r1, #76]	; 0x4c
    ce90:	64e3      	str	r3, [r4, #76]	; 0x4c
    ce92:	64cc      	str	r4, [r1, #76]	; 0x4c
    ce94:	e001      	b.n	ce9a <os_mutex_pend+0x96>
    } else {
        SLIST_INSERT_HEAD(&mu->mu_head, current, t_obj_list);
    ce96:	64e0      	str	r0, [r4, #76]	; 0x4c
    ce98:	602c      	str	r4, [r5, #0]
    }

    /* Set mutex pointer in task */
    current->t_obj = mu;
    ce9a:	61e5      	str	r5, [r4, #28]
    current->t_flags |= OS_TASK_FLAG_MUTEX_WAIT;
    ce9c:	7b63      	ldrb	r3, [r4, #13]
    ce9e:	f043 0304 	orr.w	r3, r3, #4
    cea2:	7363      	strb	r3, [r4, #13]
    os_sched_sleep(current, timeout);
    cea4:	4639      	mov	r1, r7
    cea6:	4620      	mov	r0, r4
    cea8:	f000 f8ea 	bl	d080 <os_sched_sleep>
    OS_EXIT_CRITICAL(sr);
    ceac:	4640      	mov	r0, r8
    ceae:	f000 fb11 	bl	d4d4 <os_arch_restore_sr>

    os_sched(NULL);
    ceb2:	2000      	movs	r0, #0
    ceb4:	f000 f9b8 	bl	d228 <os_sched>

    OS_ENTER_CRITICAL(sr);
    ceb8:	f000 fb06 	bl	d4c8 <os_arch_save_sr>
    current->t_flags &= ~OS_TASK_FLAG_MUTEX_WAIT;
    cebc:	7b63      	ldrb	r3, [r4, #13]
    cebe:	f023 0304 	bic.w	r3, r3, #4
    cec2:	7363      	strb	r3, [r4, #13]
    OS_EXIT_CRITICAL(sr);
    cec4:	f000 fb06 	bl	d4d4 <os_arch_restore_sr>

    /* If we are owner we did not time out. */
    if (mu->mu_owner == current) {
    cec8:	68ab      	ldr	r3, [r5, #8]
    ceca:	42a3      	cmp	r3, r4
    cecc:	d002      	beq.n	ced4 <os_mutex_pend+0xd0>
        ret = OS_OK;
    } else {
        ret = OS_TIMEOUT;
    cece:	2006      	movs	r0, #6
    }

done:
    os_trace_api_ret_u32(OS_TRACE_ID_MUTEX_PEND, (uint32_t)ret);
    return ret;
}
    ced0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        ret = OS_OK;
    ced4:	2000      	movs	r0, #0
    ced6:	e7fb      	b.n	ced0 <os_mutex_pend+0xcc>
        ret = OS_NOT_STARTED;
    ced8:	2009      	movs	r0, #9
}
    ceda:	4770      	bx	lr
        ret = OS_INVALID_PARM;
    cedc:	2003      	movs	r0, #3
    cede:	e7f7      	b.n	ced0 <os_mutex_pend+0xcc>
    cee0:	20001320 	.word	0x20001320

0000cee4 <os_sanity_check_list_lock>:
 *
 * @return 0 on success, error code on failure.
 */
static int
os_sanity_check_list_lock(void)
{
    cee4:	b508      	push	{r3, lr}
    int rc;

    if (!g_os_started) {
    cee6:	4b05      	ldr	r3, [pc, #20]	; (cefc <os_sanity_check_list_lock+0x18>)
    cee8:	6818      	ldr	r0, [r3, #0]
    ceea:	b900      	cbnz	r0, ceee <os_sanity_check_list_lock+0xa>
    }

    return (0);
err:
    return (rc);
}
    ceec:	bd08      	pop	{r3, pc}
    rc = os_mutex_pend(&g_os_sanity_check_mu, OS_WAIT_FOREVER);
    ceee:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    cef2:	4803      	ldr	r0, [pc, #12]	; (cf00 <os_sanity_check_list_lock+0x1c>)
    cef4:	f7ff ff86 	bl	ce04 <os_mutex_pend>
    if (rc != OS_OK) {
    cef8:	e7f8      	b.n	ceec <os_sanity_check_list_lock+0x8>
    cefa:	bf00      	nop
    cefc:	20001320 	.word	0x20001320
    cf00:	20002128 	.word	0x20002128

0000cf04 <os_sanity_check_list_unlock>:
 *
 * @return 0 on success, error code on failure
 */
static int
os_sanity_check_list_unlock(void)
{
    cf04:	b508      	push	{r3, lr}
    int rc;

    if (!g_os_started) {
    cf06:	4b04      	ldr	r3, [pc, #16]	; (cf18 <os_sanity_check_list_unlock+0x14>)
    cf08:	6818      	ldr	r0, [r3, #0]
    cf0a:	b900      	cbnz	r0, cf0e <os_sanity_check_list_unlock+0xa>
    }

    return (0);
err:
    return (rc);
}
    cf0c:	bd08      	pop	{r3, pc}
    rc = os_mutex_release(&g_os_sanity_check_mu);
    cf0e:	4803      	ldr	r0, [pc, #12]	; (cf1c <os_sanity_check_list_unlock+0x18>)
    cf10:	f7ff ff18 	bl	cd44 <os_mutex_release>
    if (rc != 0) {
    cf14:	e7fa      	b.n	cf0c <os_sanity_check_list_unlock+0x8>
    cf16:	bf00      	nop
    cf18:	20001320 	.word	0x20001320
    cf1c:	20002128 	.word	0x20002128

0000cf20 <os_sanity_check_init>:
{
    cf20:	4603      	mov	r3, r0
    memset(sc, 0, sizeof(*sc));
    cf22:	2000      	movs	r0, #0
    cf24:	6018      	str	r0, [r3, #0]
    cf26:	6058      	str	r0, [r3, #4]
    cf28:	6098      	str	r0, [r3, #8]
    cf2a:	60d8      	str	r0, [r3, #12]
    cf2c:	6118      	str	r0, [r3, #16]
}
    cf2e:	4770      	bx	lr

0000cf30 <os_sanity_check_register>:
}


int
os_sanity_check_register(struct os_sanity_check *sc)
{
    cf30:	b510      	push	{r4, lr}
    cf32:	4604      	mov	r4, r0
    int rc;

    rc = os_sanity_check_list_lock();
    cf34:	f7ff ffd6 	bl	cee4 <os_sanity_check_list_lock>
    if (rc != OS_OK) {
    cf38:	b100      	cbz	r0, cf3c <os_sanity_check_register+0xc>
    }

    return (0);
err:
    return (rc);
}
    cf3a:	bd10      	pop	{r4, pc}
    SLIST_INSERT_HEAD(&g_os_sanity_check_list, sc, sc_next);
    cf3c:	4b03      	ldr	r3, [pc, #12]	; (cf4c <os_sanity_check_register+0x1c>)
    cf3e:	681a      	ldr	r2, [r3, #0]
    cf40:	6122      	str	r2, [r4, #16]
    cf42:	601c      	str	r4, [r3, #0]
    rc = os_sanity_check_list_unlock();
    cf44:	f7ff ffde 	bl	cf04 <os_sanity_check_list_unlock>
    if (rc != OS_OK) {
    cf48:	e7f7      	b.n	cf3a <os_sanity_check_register+0xa>
    cf4a:	bf00      	nop
    cf4c:	20002124 	.word	0x20002124

0000cf50 <os_sanity_run>:
 * Goes through the sanity check list, and performs sanity checks.  If any of
 * these checks failed, or tasks have not checked in, it resets the processor.
 */
void
os_sanity_run(void)
{
    cf50:	b510      	push	{r4, lr}
    struct os_sanity_check *sc;
    int rc;

    rc = os_sanity_check_list_lock();
    cf52:	f7ff ffc7 	bl	cee4 <os_sanity_check_list_lock>
    if (rc != 0) {
    cf56:	b910      	cbnz	r0, cf5e <os_sanity_run+0xe>
        assert(0);
    }

    SLIST_FOREACH(sc, &g_os_sanity_check_list, sc_next) {
    cf58:	4b1d      	ldr	r3, [pc, #116]	; (cfd0 <os_sanity_run+0x80>)
    cf5a:	681c      	ldr	r4, [r3, #0]
    cf5c:	e012      	b.n	cf84 <os_sanity_run+0x34>
        assert(0);
    cf5e:	f7ff f91d 	bl	c19c <hal_debugger_connected>
    cf62:	b100      	cbz	r0, cf66 <os_sanity_run+0x16>
    cf64:	be01      	bkpt	0x0001
    cf66:	2300      	movs	r3, #0
    cf68:	461a      	mov	r2, r3
    cf6a:	4619      	mov	r1, r3
    cf6c:	4618      	mov	r0, r3
    cf6e:	f7ff faf3 	bl	c558 <__assert_func>
                sc->sc_checkin_last = os_time_get();
                continue;
            }
        }

        if (OS_TIME_TICK_GT(os_time_get(),
    cf72:	f000 fa59 	bl	d428 <os_time_get>
    cf76:	6823      	ldr	r3, [r4, #0]
    cf78:	6862      	ldr	r2, [r4, #4]
    cf7a:	4413      	add	r3, r2
    cf7c:	1ac0      	subs	r0, r0, r3
    cf7e:	2800      	cmp	r0, #0
    cf80:	dc0d      	bgt.n	cf9e <os_sanity_run+0x4e>
    SLIST_FOREACH(sc, &g_os_sanity_check_list, sc_next) {
    cf82:	6924      	ldr	r4, [r4, #16]
    cf84:	b1ac      	cbz	r4, cfb2 <os_sanity_run+0x62>
        if (sc->sc_func) {
    cf86:	68a3      	ldr	r3, [r4, #8]
    cf88:	2b00      	cmp	r3, #0
    cf8a:	d0f2      	beq.n	cf72 <os_sanity_run+0x22>
            rc = sc->sc_func(sc, sc->sc_arg);
    cf8c:	68e1      	ldr	r1, [r4, #12]
    cf8e:	4620      	mov	r0, r4
    cf90:	4798      	blx	r3
            if (rc == OS_OK) {
    cf92:	2800      	cmp	r0, #0
    cf94:	d1ed      	bne.n	cf72 <os_sanity_run+0x22>
                sc->sc_checkin_last = os_time_get();
    cf96:	f000 fa47 	bl	d428 <os_time_get>
    cf9a:	6020      	str	r0, [r4, #0]
                continue;
    cf9c:	e7f1      	b.n	cf82 <os_sanity_run+0x32>
                    sc->sc_checkin_last + sc->sc_checkin_itvl)) {
            assert(0);
    cf9e:	f7ff f8fd 	bl	c19c <hal_debugger_connected>
    cfa2:	b100      	cbz	r0, cfa6 <os_sanity_run+0x56>
    cfa4:	be01      	bkpt	0x0001
    cfa6:	2300      	movs	r3, #0
    cfa8:	461a      	mov	r2, r3
    cfaa:	4619      	mov	r1, r3
    cfac:	4618      	mov	r0, r3
    cfae:	f7ff fad3 	bl	c558 <__assert_func>
        }
    }

    rc = os_sanity_check_list_unlock();
    cfb2:	f7ff ffa7 	bl	cf04 <os_sanity_check_list_unlock>
    if (rc != 0) {
    cfb6:	b900      	cbnz	r0, cfba <os_sanity_run+0x6a>
        assert(0);
    }
}
    cfb8:	bd10      	pop	{r4, pc}
        assert(0);
    cfba:	f7ff f8ef 	bl	c19c <hal_debugger_connected>
    cfbe:	b100      	cbz	r0, cfc2 <os_sanity_run+0x72>
    cfc0:	be01      	bkpt	0x0001
    cfc2:	2300      	movs	r3, #0
    cfc4:	461a      	mov	r2, r3
    cfc6:	4619      	mov	r1, r3
    cfc8:	4618      	mov	r0, r3
    cfca:	f7ff fac5 	bl	c558 <__assert_func>
    cfce:	bf00      	nop
    cfd0:	20002124 	.word	0x20002124

0000cfd4 <os_sanity_init>:

int
os_sanity_init(void)
{
    cfd4:	b508      	push	{r3, lr}
    int rc;

    rc = os_mutex_init(&g_os_sanity_check_mu);
    cfd6:	4802      	ldr	r0, [pc, #8]	; (cfe0 <os_sanity_init+0xc>)
    cfd8:	f7ff feaa 	bl	cd30 <os_mutex_init>
    }

    return (0);
err:
    return (rc);
}
    cfdc:	bd08      	pop	{r3, pc}
    cfde:	bf00      	nop
    cfe0:	20002128 	.word	0x20002128

0000cfe4 <os_sched_insert>:
{
    struct os_task *entry;
    os_sr_t sr;
    os_error_t rc;

    if (t->t_state != OS_TASK_READY) {
    cfe4:	7b03      	ldrb	r3, [r0, #12]
    cfe6:	2b01      	cmp	r3, #1
    cfe8:	d001      	beq.n	cfee <os_sched_insert+0xa>
    }
    OS_EXIT_CRITICAL(sr);

    return (0);
err:
    return (rc);
    cfea:	2002      	movs	r0, #2
}
    cfec:	4770      	bx	lr
{
    cfee:	b510      	push	{r4, lr}
    cff0:	4604      	mov	r4, r0
    OS_ENTER_CRITICAL(sr);
    cff2:	f000 fa69 	bl	d4c8 <os_arch_save_sr>
    TAILQ_FOREACH(entry, &g_os_run_list, t_os_list) {
    cff6:	4b0f      	ldr	r3, [pc, #60]	; (d034 <os_sched_insert+0x50>)
    cff8:	681b      	ldr	r3, [r3, #0]
    cffa:	b12b      	cbz	r3, d008 <os_sched_insert+0x24>
        if (t->t_prio < entry->t_prio) {
    cffc:	7ae1      	ldrb	r1, [r4, #11]
    cffe:	7ada      	ldrb	r2, [r3, #11]
    d000:	4291      	cmp	r1, r2
    d002:	d301      	bcc.n	d008 <os_sched_insert+0x24>
    TAILQ_FOREACH(entry, &g_os_run_list, t_os_list) {
    d004:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    d006:	e7f8      	b.n	cffa <os_sched_insert+0x16>
    if (entry) {
    d008:	b153      	cbz	r3, d020 <os_sched_insert+0x3c>
        TAILQ_INSERT_BEFORE(entry, (struct os_task *) t, t_os_list);
    d00a:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    d00c:	64a2      	str	r2, [r4, #72]	; 0x48
    d00e:	6463      	str	r3, [r4, #68]	; 0x44
    d010:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    d012:	6014      	str	r4, [r2, #0]
    d014:	3444      	adds	r4, #68	; 0x44
    d016:	649c      	str	r4, [r3, #72]	; 0x48
    OS_EXIT_CRITICAL(sr);
    d018:	f000 fa5c 	bl	d4d4 <os_arch_restore_sr>
    return (0);
    d01c:	2000      	movs	r0, #0
}
    d01e:	bd10      	pop	{r4, pc}
        TAILQ_INSERT_TAIL(&g_os_run_list, (struct os_task *) t, t_os_list);
    d020:	2300      	movs	r3, #0
    d022:	6463      	str	r3, [r4, #68]	; 0x44
    d024:	4b03      	ldr	r3, [pc, #12]	; (d034 <os_sched_insert+0x50>)
    d026:	685a      	ldr	r2, [r3, #4]
    d028:	64a2      	str	r2, [r4, #72]	; 0x48
    d02a:	6014      	str	r4, [r2, #0]
    d02c:	3444      	adds	r4, #68	; 0x44
    d02e:	605c      	str	r4, [r3, #4]
    d030:	e7f2      	b.n	d018 <os_sched_insert+0x34>
    d032:	bf00      	nop
    d034:	2000010c 	.word	0x2000010c

0000d038 <os_sched_ctx_sw_hook>:

void
os_sched_ctx_sw_hook(struct os_task *next_t)
{
    d038:	b410      	push	{r4}
    stack = g_current_task->t_stackbottom;
    for (i = 0; i < MYNEWT_VAL(OS_CTX_SW_STACK_GUARD); i++) {
        assert(stack[i] == OS_STACK_PATTERN);
    }
#endif
    next_t->t_ctx_sw_cnt++;
    d03a:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
    d03c:	3301      	adds	r3, #1
    d03e:	63c3      	str	r3, [r0, #60]	; 0x3c
#if MYNEWT_VAL(OS_TASK_RUN_TIME_CPUTIME)
    ticks = os_cputime_get32();
#else
    ticks = g_os_time;
    d040:	4b06      	ldr	r3, [pc, #24]	; (d05c <os_sched_ctx_sw_hook+0x24>)
    d042:	6818      	ldr	r0, [r3, #0]
#endif
    g_current_task->t_run_time += ticks - g_os_last_ctx_sw_time;
    d044:	4b06      	ldr	r3, [pc, #24]	; (d060 <os_sched_ctx_sw_hook+0x28>)
    d046:	681c      	ldr	r4, [r3, #0]
    d048:	4906      	ldr	r1, [pc, #24]	; (d064 <os_sched_ctx_sw_hook+0x2c>)
    d04a:	680b      	ldr	r3, [r1, #0]
    d04c:	1ac2      	subs	r2, r0, r3
    d04e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    d050:	4413      	add	r3, r2
    d052:	63a3      	str	r3, [r4, #56]	; 0x38
    g_os_last_ctx_sw_time = ticks;
    d054:	6008      	str	r0, [r1, #0]
}
    d056:	bc10      	pop	{r4}
    d058:	4770      	bx	lr
    d05a:	bf00      	nop
    d05c:	20002178 	.word	0x20002178
    d060:	20002134 	.word	0x20002134
    d064:	20002138 	.word	0x20002138

0000d068 <os_sched_get_current_task>:

struct os_task *
os_sched_get_current_task(void)
{
    return (g_current_task);
}
    d068:	4b01      	ldr	r3, [pc, #4]	; (d070 <os_sched_get_current_task+0x8>)
    d06a:	6818      	ldr	r0, [r3, #0]
    d06c:	4770      	bx	lr
    d06e:	bf00      	nop
    d070:	20002134 	.word	0x20002134

0000d074 <os_sched_set_current_task>:
 * @param t Pointer to currently running task.
 */
void
os_sched_set_current_task(struct os_task *t)
{
    g_current_task = t;
    d074:	4b01      	ldr	r3, [pc, #4]	; (d07c <os_sched_set_current_task+0x8>)
    d076:	6018      	str	r0, [r3, #0]
}
    d078:	4770      	bx	lr
    d07a:	bf00      	nop
    d07c:	20002134 	.word	0x20002134

0000d080 <os_sched_sleep>:
 * NOTE: must be called with interrupts disabled! This function does not call
 * the scheduler
 */
int
os_sched_sleep(struct os_task *t, os_time_t nticks)
{
    d080:	b538      	push	{r3, r4, r5, lr}
    d082:	4604      	mov	r4, r0
    d084:	460d      	mov	r5, r1
    struct os_task *entry;

    entry = NULL;

    TAILQ_REMOVE(&g_os_run_list, t, t_os_list);
    d086:	6c43      	ldr	r3, [r0, #68]	; 0x44
    d088:	b183      	cbz	r3, d0ac <os_sched_sleep+0x2c>
    d08a:	6c82      	ldr	r2, [r0, #72]	; 0x48
    d08c:	649a      	str	r2, [r3, #72]	; 0x48
    d08e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    d090:	6c62      	ldr	r2, [r4, #68]	; 0x44
    d092:	601a      	str	r2, [r3, #0]
    t->t_state = OS_TASK_SLEEP;
    d094:	2302      	movs	r3, #2
    d096:	7323      	strb	r3, [r4, #12]
    t->t_next_wakeup = os_time_get() + nticks;
    d098:	f000 f9c6 	bl	d428 <os_time_get>
    d09c:	4428      	add	r0, r5
    d09e:	6360      	str	r0, [r4, #52]	; 0x34
    if (nticks == OS_TIMEOUT_NEVER) {
    d0a0:	f1b5 3fff 	cmp.w	r5, #4294967295	; 0xffffffff
    d0a4:	d006      	beq.n	d0b4 <os_sched_sleep+0x34>
        t->t_flags |= OS_TASK_FLAG_NO_TIMEOUT;
        TAILQ_INSERT_TAIL(&g_os_sleep_list, t, t_os_list);
    } else {
        TAILQ_FOREACH(entry, &g_os_sleep_list, t_os_list) {
    d0a6:	4b18      	ldr	r3, [pc, #96]	; (d108 <os_sched_sleep+0x88>)
    d0a8:	681b      	ldr	r3, [r3, #0]
    d0aa:	e011      	b.n	d0d0 <os_sched_sleep+0x50>
    TAILQ_REMOVE(&g_os_run_list, t, t_os_list);
    d0ac:	6c82      	ldr	r2, [r0, #72]	; 0x48
    d0ae:	4b17      	ldr	r3, [pc, #92]	; (d10c <os_sched_sleep+0x8c>)
    d0b0:	605a      	str	r2, [r3, #4]
    d0b2:	e7ec      	b.n	d08e <os_sched_sleep+0xe>
        t->t_flags |= OS_TASK_FLAG_NO_TIMEOUT;
    d0b4:	7b63      	ldrb	r3, [r4, #13]
    d0b6:	f043 0301 	orr.w	r3, r3, #1
    d0ba:	7363      	strb	r3, [r4, #13]
        TAILQ_INSERT_TAIL(&g_os_sleep_list, t, t_os_list);
    d0bc:	2300      	movs	r3, #0
    d0be:	6463      	str	r3, [r4, #68]	; 0x44
    d0c0:	4b11      	ldr	r3, [pc, #68]	; (d108 <os_sched_sleep+0x88>)
    d0c2:	685a      	ldr	r2, [r3, #4]
    d0c4:	64a2      	str	r2, [r4, #72]	; 0x48
    d0c6:	6014      	str	r4, [r2, #0]
    d0c8:	3444      	adds	r4, #68	; 0x44
    d0ca:	605c      	str	r4, [r3, #4]
    d0cc:	e011      	b.n	d0f2 <os_sched_sleep+0x72>
        TAILQ_FOREACH(entry, &g_os_sleep_list, t_os_list) {
    d0ce:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    d0d0:	b13b      	cbz	r3, d0e2 <os_sched_sleep+0x62>
            if ((entry->t_flags & OS_TASK_FLAG_NO_TIMEOUT) ||
    d0d2:	7b5a      	ldrb	r2, [r3, #13]
    d0d4:	f012 0f01 	tst.w	r2, #1
    d0d8:	d103      	bne.n	d0e2 <os_sched_sleep+0x62>
                    OS_TIME_TICK_GT(entry->t_next_wakeup, t->t_next_wakeup)) {
    d0da:	6b5a      	ldr	r2, [r3, #52]	; 0x34
    d0dc:	1a12      	subs	r2, r2, r0
            if ((entry->t_flags & OS_TASK_FLAG_NO_TIMEOUT) ||
    d0de:	2a00      	cmp	r2, #0
    d0e0:	ddf5      	ble.n	d0ce <os_sched_sleep+0x4e>
                break;
            }
        }
        if (entry) {
    d0e2:	b143      	cbz	r3, d0f6 <os_sched_sleep+0x76>
            TAILQ_INSERT_BEFORE(entry, t, t_os_list);
    d0e4:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    d0e6:	64a2      	str	r2, [r4, #72]	; 0x48
    d0e8:	6463      	str	r3, [r4, #68]	; 0x44
    d0ea:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    d0ec:	6014      	str	r4, [r2, #0]
    d0ee:	3444      	adds	r4, #68	; 0x44
    d0f0:	649c      	str	r4, [r3, #72]	; 0x48
        }
    }

    os_trace_task_stop_ready(t, OS_TASK_SLEEP);
    return (0);
}
    d0f2:	2000      	movs	r0, #0
    d0f4:	bd38      	pop	{r3, r4, r5, pc}
            TAILQ_INSERT_TAIL(&g_os_sleep_list, t, t_os_list);
    d0f6:	2300      	movs	r3, #0
    d0f8:	6463      	str	r3, [r4, #68]	; 0x44
    d0fa:	4b03      	ldr	r3, [pc, #12]	; (d108 <os_sched_sleep+0x88>)
    d0fc:	685a      	ldr	r2, [r3, #4]
    d0fe:	64a2      	str	r2, [r4, #72]	; 0x48
    d100:	6014      	str	r4, [r2, #0]
    d102:	3444      	adds	r4, #68	; 0x44
    d104:	605c      	str	r4, [r3, #4]
    d106:	e7f4      	b.n	d0f2 <os_sched_sleep+0x72>
    d108:	20000114 	.word	0x20000114
    d10c:	2000010c 	.word	0x2000010c

0000d110 <os_sched_wakeup>:
 *
 * NOTE: This function must be called with interrupts disabled.
 */
int
os_sched_wakeup(struct os_task *t)
{
    d110:	b508      	push	{r3, lr}
    struct os_task_obj *os_obj;

    assert(t->t_state == OS_TASK_SLEEP);
    d112:	7b03      	ldrb	r3, [r0, #12]
    d114:	2b02      	cmp	r3, #2
    d116:	d121      	bne.n	d15c <os_sched_wakeup+0x4c>

    /* Remove self from object list if waiting on one */
    if (t->t_obj) {
    d118:	69c2      	ldr	r2, [r0, #28]
    d11a:	b162      	cbz	r2, d136 <os_sched_wakeup+0x26>
        os_obj = (struct os_task_obj *)t->t_obj;
        assert(!SLIST_EMPTY(&os_obj->obj_head));
    d11c:	6813      	ldr	r3, [r2, #0]
    d11e:	b33b      	cbz	r3, d170 <os_sched_wakeup+0x60>
        SLIST_REMOVE(&os_obj->obj_head, t, os_task, t_obj_list);
    d120:	4283      	cmp	r3, r0
    d122:	d02f      	beq.n	d184 <os_sched_wakeup+0x74>
    d124:	461a      	mov	r2, r3
    d126:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    d128:	4283      	cmp	r3, r0
    d12a:	d1fb      	bne.n	d124 <os_sched_wakeup+0x14>
    d12c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    d12e:	64d3      	str	r3, [r2, #76]	; 0x4c
        SLIST_NEXT(t, t_obj_list) = NULL;
    d130:	2300      	movs	r3, #0
    d132:	64c3      	str	r3, [r0, #76]	; 0x4c
        t->t_obj = NULL;
    d134:	61c3      	str	r3, [r0, #28]
    }

    /* Remove task from sleep list */
    t->t_state = OS_TASK_READY;
    d136:	2301      	movs	r3, #1
    d138:	7303      	strb	r3, [r0, #12]
    t->t_next_wakeup = 0;
    d13a:	2300      	movs	r3, #0
    d13c:	6343      	str	r3, [r0, #52]	; 0x34
    t->t_flags &= ~OS_TASK_FLAG_NO_TIMEOUT;
    d13e:	7b43      	ldrb	r3, [r0, #13]
    d140:	f023 0301 	bic.w	r3, r3, #1
    d144:	7343      	strb	r3, [r0, #13]
    TAILQ_REMOVE(&g_os_sleep_list, t, t_os_list);
    d146:	6c43      	ldr	r3, [r0, #68]	; 0x44
    d148:	b1fb      	cbz	r3, d18a <os_sched_wakeup+0x7a>
    d14a:	6c82      	ldr	r2, [r0, #72]	; 0x48
    d14c:	649a      	str	r2, [r3, #72]	; 0x48
    d14e:	6c83      	ldr	r3, [r0, #72]	; 0x48
    d150:	6c42      	ldr	r2, [r0, #68]	; 0x44
    d152:	601a      	str	r2, [r3, #0]
    os_sched_insert(t);
    d154:	f7ff ff46 	bl	cfe4 <os_sched_insert>

    os_trace_task_start_ready(t);

    return (0);
}
    d158:	2000      	movs	r0, #0
    d15a:	bd08      	pop	{r3, pc}
    assert(t->t_state == OS_TASK_SLEEP);
    d15c:	f7ff f81e 	bl	c19c <hal_debugger_connected>
    d160:	b100      	cbz	r0, d164 <os_sched_wakeup+0x54>
    d162:	be01      	bkpt	0x0001
    d164:	2300      	movs	r3, #0
    d166:	461a      	mov	r2, r3
    d168:	4619      	mov	r1, r3
    d16a:	4618      	mov	r0, r3
    d16c:	f7ff f9f4 	bl	c558 <__assert_func>
        assert(!SLIST_EMPTY(&os_obj->obj_head));
    d170:	f7ff f814 	bl	c19c <hal_debugger_connected>
    d174:	b100      	cbz	r0, d178 <os_sched_wakeup+0x68>
    d176:	be01      	bkpt	0x0001
    d178:	2300      	movs	r3, #0
    d17a:	461a      	mov	r2, r3
    d17c:	4619      	mov	r1, r3
    d17e:	4618      	mov	r0, r3
    d180:	f7ff f9ea 	bl	c558 <__assert_func>
        SLIST_REMOVE(&os_obj->obj_head, t, os_task, t_obj_list);
    d184:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    d186:	6013      	str	r3, [r2, #0]
    d188:	e7d2      	b.n	d130 <os_sched_wakeup+0x20>
    TAILQ_REMOVE(&g_os_sleep_list, t, t_os_list);
    d18a:	6c82      	ldr	r2, [r0, #72]	; 0x48
    d18c:	4b01      	ldr	r3, [pc, #4]	; (d194 <os_sched_wakeup+0x84>)
    d18e:	605a      	str	r2, [r3, #4]
    d190:	e7dd      	b.n	d14e <os_sched_wakeup+0x3e>
    d192:	bf00      	nop
    d194:	20000114 	.word	0x20000114

0000d198 <os_sched_os_timer_exp>:
 * removed from the sleep list and added to the run list.
 *
 */
void
os_sched_os_timer_exp(void)
{
    d198:	b570      	push	{r4, r5, r6, lr}
    struct os_task *t;
    struct os_task *next;
    os_time_t now;
    os_sr_t sr;

    now = os_time_get();
    d19a:	f000 f945 	bl	d428 <os_time_get>
    d19e:	4605      	mov	r5, r0

    OS_ENTER_CRITICAL(sr);
    d1a0:	f000 f992 	bl	d4c8 <os_arch_save_sr>
    d1a4:	4606      	mov	r6, r0

    /*
     * Wakeup any tasks that have their sleep timer expired
     */
    t = TAILQ_FIRST(&g_os_sleep_list);
    d1a6:	4b0a      	ldr	r3, [pc, #40]	; (d1d0 <os_sched_os_timer_exp+0x38>)
    d1a8:	6818      	ldr	r0, [r3, #0]
    while (t) {
    d1aa:	e002      	b.n	d1b2 <os_sched_os_timer_exp+0x1a>
        if (t->t_flags & OS_TASK_FLAG_NO_TIMEOUT) {
            break;
        }
        next = TAILQ_NEXT(t, t_os_list);
        if (OS_TIME_TICK_GEQ(now, t->t_next_wakeup)) {
            os_sched_wakeup(t);
    d1ac:	f7ff ffb0 	bl	d110 <os_sched_wakeup>
        } else {
            break;
        }
        t = next;
    d1b0:	4620      	mov	r0, r4
    while (t) {
    d1b2:	b140      	cbz	r0, d1c6 <os_sched_os_timer_exp+0x2e>
        if (t->t_flags & OS_TASK_FLAG_NO_TIMEOUT) {
    d1b4:	7b43      	ldrb	r3, [r0, #13]
    d1b6:	f013 0f01 	tst.w	r3, #1
    d1ba:	d104      	bne.n	d1c6 <os_sched_os_timer_exp+0x2e>
        next = TAILQ_NEXT(t, t_os_list);
    d1bc:	6c44      	ldr	r4, [r0, #68]	; 0x44
        if (OS_TIME_TICK_GEQ(now, t->t_next_wakeup)) {
    d1be:	6b43      	ldr	r3, [r0, #52]	; 0x34
    d1c0:	1aeb      	subs	r3, r5, r3
    d1c2:	2b00      	cmp	r3, #0
    d1c4:	daf2      	bge.n	d1ac <os_sched_os_timer_exp+0x14>
    }

    OS_EXIT_CRITICAL(sr);
    d1c6:	4630      	mov	r0, r6
    d1c8:	f000 f984 	bl	d4d4 <os_arch_restore_sr>
}
    d1cc:	bd70      	pop	{r4, r5, r6, pc}
    d1ce:	bf00      	nop
    d1d0:	20000114 	.word	0x20000114

0000d1d4 <os_sched_wakeup_ticks>:
 * Return the number of ticks until the first sleep timer expires.If there are
 * no such tasks then return OS_TIMEOUT_NEVER instead.
 */
os_time_t
os_sched_wakeup_ticks(os_time_t now)
{
    d1d4:	b510      	push	{r4, lr}
    d1d6:	4604      	mov	r4, r0
    os_time_t rt;
    struct os_task *t;

    OS_ASSERT_CRITICAL();
    d1d8:	f000 f97f 	bl	d4da <os_arch_in_critical>
    d1dc:	b150      	cbz	r0, d1f4 <os_sched_wakeup_ticks+0x20>

    t = TAILQ_FIRST(&g_os_sleep_list);
    d1de:	4b0e      	ldr	r3, [pc, #56]	; (d218 <os_sched_wakeup_ticks+0x44>)
    d1e0:	681b      	ldr	r3, [r3, #0]
    if (t == NULL || (t->t_flags & OS_TASK_FLAG_NO_TIMEOUT)) {
    d1e2:	b19b      	cbz	r3, d20c <os_sched_wakeup_ticks+0x38>
    d1e4:	7b5a      	ldrb	r2, [r3, #13]
    d1e6:	f012 0f01 	tst.w	r2, #1
    d1ea:	d112      	bne.n	d212 <os_sched_wakeup_ticks+0x3e>
        rt = OS_TIMEOUT_NEVER;
    } else if (OS_TIME_TICK_GEQ(t->t_next_wakeup, now)) {
    d1ec:	6b58      	ldr	r0, [r3, #52]	; 0x34
    d1ee:	1b00      	subs	r0, r0, r4
    d1f0:	d40a      	bmi.n	d208 <os_sched_wakeup_ticks+0x34>
        rt = t->t_next_wakeup - now;
    } else {
        rt = 0;     /* wakeup time was in the past */
    }
    return (rt);
}
    d1f2:	bd10      	pop	{r4, pc}
    OS_ASSERT_CRITICAL();
    d1f4:	f7fe ffd2 	bl	c19c <hal_debugger_connected>
    d1f8:	b100      	cbz	r0, d1fc <os_sched_wakeup_ticks+0x28>
    d1fa:	be01      	bkpt	0x0001
    d1fc:	2300      	movs	r3, #0
    d1fe:	461a      	mov	r2, r3
    d200:	4619      	mov	r1, r3
    d202:	4618      	mov	r0, r3
    d204:	f7ff f9a8 	bl	c558 <__assert_func>
        rt = 0;     /* wakeup time was in the past */
    d208:	2000      	movs	r0, #0
    d20a:	e7f2      	b.n	d1f2 <os_sched_wakeup_ticks+0x1e>
        rt = OS_TIMEOUT_NEVER;
    d20c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    d210:	e7ef      	b.n	d1f2 <os_sched_wakeup_ticks+0x1e>
    d212:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    return (rt);
    d216:	e7ec      	b.n	d1f2 <os_sched_wakeup_ticks+0x1e>
    d218:	20000114 	.word	0x20000114

0000d21c <os_sched_next_task>:
 */
struct os_task *
os_sched_next_task(void)
{
    return (TAILQ_FIRST(&g_os_run_list));
}
    d21c:	4b01      	ldr	r3, [pc, #4]	; (d224 <os_sched_next_task+0x8>)
    d21e:	6818      	ldr	r0, [r3, #0]
    d220:	4770      	bx	lr
    d222:	bf00      	nop
    d224:	2000010c 	.word	0x2000010c

0000d228 <os_sched>:
{
    d228:	b538      	push	{r3, r4, r5, lr}
    d22a:	4604      	mov	r4, r0
    OS_ENTER_CRITICAL(sr);
    d22c:	f000 f94c 	bl	d4c8 <os_arch_save_sr>
    d230:	4605      	mov	r5, r0
    if (!next_t) {
    d232:	b134      	cbz	r4, d242 <os_sched+0x1a>
    os_arch_ctx_sw(next_t);
    d234:	4620      	mov	r0, r4
    d236:	f000 f93d 	bl	d4b4 <os_arch_ctx_sw>
    OS_EXIT_CRITICAL(sr);
    d23a:	4628      	mov	r0, r5
    d23c:	f000 f94a 	bl	d4d4 <os_arch_restore_sr>
}
    d240:	bd38      	pop	{r3, r4, r5, pc}
        next_t = os_sched_next_task();
    d242:	f7ff ffeb 	bl	d21c <os_sched_next_task>
    d246:	4604      	mov	r4, r0
    d248:	e7f4      	b.n	d234 <os_sched+0xc>
	...

0000d24c <os_sched_resort>:
 * NOTE: this function expects interrupts to be disabled so they
 * are not disabled here.
 */
void
os_sched_resort(struct os_task *t)
{
    d24c:	b508      	push	{r3, lr}
    if (t->t_state == OS_TASK_READY) {
    d24e:	7b03      	ldrb	r3, [r0, #12]
    d250:	2b01      	cmp	r3, #1
    d252:	d000      	beq.n	d256 <os_sched_resort+0xa>
        TAILQ_REMOVE(&g_os_run_list, t, t_os_list);
        os_sched_insert(t);
    }
}
    d254:	bd08      	pop	{r3, pc}
        TAILQ_REMOVE(&g_os_run_list, t, t_os_list);
    d256:	6c43      	ldr	r3, [r0, #68]	; 0x44
    d258:	b13b      	cbz	r3, d26a <os_sched_resort+0x1e>
    d25a:	6c82      	ldr	r2, [r0, #72]	; 0x48
    d25c:	649a      	str	r2, [r3, #72]	; 0x48
    d25e:	6c83      	ldr	r3, [r0, #72]	; 0x48
    d260:	6c42      	ldr	r2, [r0, #68]	; 0x44
    d262:	601a      	str	r2, [r3, #0]
        os_sched_insert(t);
    d264:	f7ff febe 	bl	cfe4 <os_sched_insert>
}
    d268:	e7f4      	b.n	d254 <os_sched_resort+0x8>
        TAILQ_REMOVE(&g_os_run_list, t, t_os_list);
    d26a:	6c82      	ldr	r2, [r0, #72]	; 0x48
    d26c:	4b01      	ldr	r3, [pc, #4]	; (d274 <os_sched_resort+0x28>)
    d26e:	605a      	str	r2, [r3, #4]
    d270:	e7f5      	b.n	d25e <os_sched_resort+0x12>
    d272:	bf00      	nop
    d274:	2000010c 	.word	0x2000010c

0000d278 <_clear_stack>:
static void
_clear_stack(os_stack_t *stack_bottom, int size)
{
    int i;

    for (i = 0; i < size; i++) {
    d278:	2300      	movs	r3, #0
    d27a:	428b      	cmp	r3, r1
    d27c:	da04      	bge.n	d288 <_clear_stack+0x10>
        stack_bottom[i] = OS_STACK_PATTERN;
    d27e:	4a03      	ldr	r2, [pc, #12]	; (d28c <_clear_stack+0x14>)
    d280:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
    for (i = 0; i < size; i++) {
    d284:	3301      	adds	r3, #1
    d286:	e7f8      	b.n	d27a <_clear_stack+0x2>
    }
}
    d288:	4770      	bx	lr
    d28a:	bf00      	nop
    d28c:	deadbeef 	.word	0xdeadbeef

0000d290 <os_task_stacktop_get>:
}

os_stack_t *
os_task_stacktop_get(struct os_task *t)
{
    return &t->t_stackbottom[t->t_stacksize];
    d290:	6843      	ldr	r3, [r0, #4]
    d292:	8900      	ldrh	r0, [r0, #8]
}
    d294:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    d298:	4770      	bx	lr
	...

0000d29c <os_task_init>:
{
    d29c:	e92d 42f0 	stmdb	sp!, {r4, r5, r6, r7, r9, lr}
    d2a0:	4604      	mov	r4, r0
    d2a2:	460d      	mov	r5, r1
    d2a4:	4617      	mov	r7, r2
    d2a6:	461e      	mov	r6, r3
    d2a8:	f8bd 9024 	ldrh.w	r9, [sp, #36]	; 0x24
    memset(t, 0, sizeof(*t));
    d2ac:	2250      	movs	r2, #80	; 0x50
    d2ae:	2100      	movs	r1, #0
    d2b0:	f000 fa73 	bl	d79a <memset>
    t->t_func = func;
    d2b4:	6167      	str	r7, [r4, #20]
    t->t_arg = arg;
    d2b6:	61a6      	str	r6, [r4, #24]
    OS_ENTER_CRITICAL(sr);
    d2b8:	f000 f906 	bl	d4c8 <os_arch_save_sr>
    rc = g_task_id;
    d2bc:	4b2e      	ldr	r3, [pc, #184]	; (d378 <os_task_init+0xdc>)
    d2be:	781e      	ldrb	r6, [r3, #0]
    g_task_id++;
    d2c0:	1c72      	adds	r2, r6, #1
    d2c2:	701a      	strb	r2, [r3, #0]
    OS_EXIT_CRITICAL(sr);
    d2c4:	f000 f906 	bl	d4d4 <os_arch_restore_sr>
    t->t_taskid = os_task_next_id();
    d2c8:	72a6      	strb	r6, [r4, #10]
    t->t_prio = prio;
    d2ca:	f89d 3018 	ldrb.w	r3, [sp, #24]
    d2ce:	72e3      	strb	r3, [r4, #11]
    t->t_state = OS_TASK_READY;
    d2d0:	2301      	movs	r3, #1
    d2d2:	7323      	strb	r3, [r4, #12]
    t->t_name = name;
    d2d4:	6125      	str	r5, [r4, #16]
    t->t_next_wakeup = 0;
    d2d6:	2300      	movs	r3, #0
    d2d8:	6363      	str	r3, [r4, #52]	; 0x34
    rc = os_sanity_check_init(&t->t_sanity_check);
    d2da:	f104 0620 	add.w	r6, r4, #32
    d2de:	4630      	mov	r0, r6
    d2e0:	f7ff fe1e 	bl	cf20 <os_sanity_check_init>
    if (rc != OS_OK) {
    d2e4:	4605      	mov	r5, r0
    d2e6:	2800      	cmp	r0, #0
    d2e8:	d139      	bne.n	d35e <os_task_init+0xc2>
    if (sanity_itvl != OS_WAIT_FOREVER) {
    d2ea:	9b07      	ldr	r3, [sp, #28]
    d2ec:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    d2f0:	d005      	beq.n	d2fe <os_task_init+0x62>
        sc->sc_checkin_itvl = sanity_itvl;
    d2f2:	6263      	str	r3, [r4, #36]	; 0x24
        rc = os_sanity_check_register(sc);
    d2f4:	4630      	mov	r0, r6
    d2f6:	f7ff fe1b 	bl	cf30 <os_sanity_check_register>
        if (rc != OS_OK) {
    d2fa:	4605      	mov	r5, r0
    d2fc:	bb78      	cbnz	r0, d35e <os_task_init+0xc2>
    _clear_stack(stack_bottom, stack_size);
    d2fe:	4649      	mov	r1, r9
    d300:	9808      	ldr	r0, [sp, #32]
    d302:	f7ff ffb9 	bl	d278 <_clear_stack>
    t->t_stackbottom = stack_bottom;
    d306:	9b08      	ldr	r3, [sp, #32]
    d308:	6063      	str	r3, [r4, #4]
    t->t_stacksize = stack_size;
    d30a:	f8a4 9008 	strh.w	r9, [r4, #8]
    t->t_stackptr = os_arch_task_stack_init(t, os_task_stacktop_get(t),
    d30e:	4620      	mov	r0, r4
    d310:	f7ff ffbe 	bl	d290 <os_task_stacktop_get>
    d314:	4601      	mov	r1, r0
    d316:	464a      	mov	r2, r9
    d318:	4620      	mov	r0, r4
    d31a:	f000 f8e3 	bl	d4e4 <os_arch_task_stack_init>
    d31e:	6020      	str	r0, [r4, #0]
    STAILQ_FOREACH(task, &g_os_task_list, t_os_task_list) {
    d320:	4b16      	ldr	r3, [pc, #88]	; (d37c <os_task_init+0xe0>)
    d322:	681b      	ldr	r3, [r3, #0]
    d324:	b17b      	cbz	r3, d346 <os_task_init+0xaa>
        assert(t->t_prio != task->t_prio);
    d326:	7ae1      	ldrb	r1, [r4, #11]
    d328:	7ada      	ldrb	r2, [r3, #11]
    d32a:	4291      	cmp	r1, r2
    d32c:	d001      	beq.n	d332 <os_task_init+0x96>
    STAILQ_FOREACH(task, &g_os_task_list, t_os_task_list) {
    d32e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    d330:	e7f8      	b.n	d324 <os_task_init+0x88>
        assert(t->t_prio != task->t_prio);
    d332:	f7fe ff33 	bl	c19c <hal_debugger_connected>
    d336:	b100      	cbz	r0, d33a <os_task_init+0x9e>
    d338:	be01      	bkpt	0x0001
    d33a:	2300      	movs	r3, #0
    d33c:	461a      	mov	r2, r3
    d33e:	4619      	mov	r1, r3
    d340:	4618      	mov	r0, r3
    d342:	f7ff f909 	bl	c558 <__assert_func>
    STAILQ_INSERT_TAIL(&g_os_task_list, t, t_os_task_list);
    d346:	6423      	str	r3, [r4, #64]	; 0x40
    d348:	4b0c      	ldr	r3, [pc, #48]	; (d37c <os_task_init+0xe0>)
    d34a:	685a      	ldr	r2, [r3, #4]
    d34c:	6014      	str	r4, [r2, #0]
    d34e:	f104 0240 	add.w	r2, r4, #64	; 0x40
    d352:	605a      	str	r2, [r3, #4]
    rc = os_sched_insert(t);
    d354:	4620      	mov	r0, r4
    d356:	f7ff fe45 	bl	cfe4 <os_sched_insert>
    d35a:	4605      	mov	r5, r0
    if (rc != OS_OK) {
    d35c:	b110      	cbz	r0, d364 <os_task_init+0xc8>
}
    d35e:	4628      	mov	r0, r5
    d360:	e8bd 82f0 	ldmia.w	sp!, {r4, r5, r6, r7, r9, pc}
    if (os_started()) {
    d364:	f7ff f9b8 	bl	c6d8 <os_started>
    d368:	b908      	cbnz	r0, d36e <os_task_init+0xd2>
    return (0);
    d36a:	4605      	mov	r5, r0
    d36c:	e7f7      	b.n	d35e <os_task_init+0xc2>
        os_sched(NULL);
    d36e:	2000      	movs	r0, #0
    d370:	f7ff ff5a 	bl	d228 <os_sched>
    d374:	e7f3      	b.n	d35e <os_task_init+0xc2>
    d376:	bf00      	nop
    d378:	20002144 	.word	0x20002144
    d37c:	2000213c 	.word	0x2000213c

0000d380 <os_deltatime>:
} basetod;

static void
os_deltatime(os_time_t delta, const struct os_timeval *base,
    struct os_timeval *result)
{
    d380:	b430      	push	{r4, r5}
    struct os_timeval tvdelta;

    tvdelta.tv_sec = delta / OS_TICKS_PER_SEC;
    d382:	09c3      	lsrs	r3, r0, #7
    tvdelta.tv_usec = (delta % OS_TICKS_PER_SEC) * OS_USEC_PER_TICK;
    d384:	f000 007f 	and.w	r0, r0, #127	; 0x7f
    os_timeradd(base, &tvdelta, result);
    d388:	e9d1 4500 	ldrd	r4, r5, [r1]
    d38c:	18e4      	adds	r4, r4, r3
    d38e:	f145 0500 	adc.w	r5, r5, #0
    d392:	e9c2 4500 	strd	r4, r5, [r2]
    d396:	688b      	ldr	r3, [r1, #8]
    d398:	f641 6184 	movw	r1, #7812	; 0x1e84
    d39c:	fb01 3000 	mla	r0, r1, r0, r3
    d3a0:	6090      	str	r0, [r2, #8]
    d3a2:	4b07      	ldr	r3, [pc, #28]	; (d3c0 <os_deltatime+0x40>)
    d3a4:	4298      	cmp	r0, r3
    d3a6:	dd09      	ble.n	d3bc <os_deltatime+0x3c>
    d3a8:	1c61      	adds	r1, r4, #1
    d3aa:	f145 0300 	adc.w	r3, r5, #0
    d3ae:	6011      	str	r1, [r2, #0]
    d3b0:	6053      	str	r3, [r2, #4]
    d3b2:	f5a0 2074 	sub.w	r0, r0, #999424	; 0xf4000
    d3b6:	f5a0 7010 	sub.w	r0, r0, #576	; 0x240
    d3ba:	6090      	str	r0, [r2, #8]
}
    d3bc:	bc30      	pop	{r4, r5}
    d3be:	4770      	bx	lr
    d3c0:	000f423f 	.word	0x000f423f

0000d3c4 <os_time_tick>:
}

#if MYNEWT_VAL(OS_SCHEDULING)
static void
os_time_tick(int ticks)
{
    d3c4:	b570      	push	{r4, r5, r6, lr}
    os_sr_t sr;
    os_time_t delta, prev_os_time;

    assert(ticks >= 0);
    d3c6:	1e04      	subs	r4, r0, #0
    d3c8:	db0d      	blt.n	d3e6 <os_time_tick+0x22>

    OS_ENTER_CRITICAL(sr);
    d3ca:	f000 f87d 	bl	d4c8 <os_arch_save_sr>
    d3ce:	4605      	mov	r5, r0
    prev_os_time = g_os_time;
    d3d0:	4913      	ldr	r1, [pc, #76]	; (d420 <os_time_tick+0x5c>)
    d3d2:	680a      	ldr	r2, [r1, #0]
    g_os_time += ticks;
    d3d4:	18a3      	adds	r3, r4, r2
    d3d6:	600b      	str	r3, [r1, #0]

    /*
     * Update 'basetod' when 'g_os_time' crosses the 0x00000000 and
     * 0x80000000 thresholds.
     */
    if ((prev_os_time ^ g_os_time) >> 31) {
    d3d8:	ea93 0f02 	teq	r3, r2
    d3dc:	d40d      	bmi.n	d3fa <os_time_tick+0x36>
        delta = g_os_time - basetod.ostime;
        os_deltatime(delta, &basetod.uptime, &basetod.uptime);
        os_deltatime(delta, &basetod.utctime, &basetod.utctime);
        basetod.ostime = g_os_time;
    }
    OS_EXIT_CRITICAL(sr);
    d3de:	4628      	mov	r0, r5
    d3e0:	f000 f878 	bl	d4d4 <os_arch_restore_sr>
}
    d3e4:	bd70      	pop	{r4, r5, r6, pc}
    assert(ticks >= 0);
    d3e6:	f7fe fed9 	bl	c19c <hal_debugger_connected>
    d3ea:	b100      	cbz	r0, d3ee <os_time_tick+0x2a>
    d3ec:	be01      	bkpt	0x0001
    d3ee:	2300      	movs	r3, #0
    d3f0:	461a      	mov	r2, r3
    d3f2:	4619      	mov	r1, r3
    d3f4:	4618      	mov	r0, r3
    d3f6:	f7ff f8af 	bl	c558 <__assert_func>
        delta = g_os_time - basetod.ostime;
    d3fa:	4e0a      	ldr	r6, [pc, #40]	; (d424 <os_time_tick+0x60>)
    d3fc:	4631      	mov	r1, r6
    d3fe:	f851 4b08 	ldr.w	r4, [r1], #8
    d402:	1b1c      	subs	r4, r3, r4
        os_deltatime(delta, &basetod.uptime, &basetod.uptime);
    d404:	460a      	mov	r2, r1
    d406:	4620      	mov	r0, r4
    d408:	f7ff ffba 	bl	d380 <os_deltatime>
        os_deltatime(delta, &basetod.utctime, &basetod.utctime);
    d40c:	f106 0118 	add.w	r1, r6, #24
    d410:	460a      	mov	r2, r1
    d412:	4620      	mov	r0, r4
    d414:	f7ff ffb4 	bl	d380 <os_deltatime>
        basetod.ostime = g_os_time;
    d418:	4b01      	ldr	r3, [pc, #4]	; (d420 <os_time_tick+0x5c>)
    d41a:	681b      	ldr	r3, [r3, #0]
    d41c:	6033      	str	r3, [r6, #0]
    d41e:	e7de      	b.n	d3de <os_time_tick+0x1a>
    d420:	20002178 	.word	0x20002178
    d424:	20002148 	.word	0x20002148

0000d428 <os_time_get>:
}
    d428:	4b01      	ldr	r3, [pc, #4]	; (d430 <os_time_get+0x8>)
    d42a:	6818      	ldr	r0, [r3, #0]
    d42c:	4770      	bx	lr
    d42e:	bf00      	nop
    d430:	20002178 	.word	0x20002178

0000d434 <os_time_advance>:

void
os_time_advance(int ticks)
{
    d434:	b510      	push	{r4, lr}
    assert(ticks >= 0);
    d436:	1e04      	subs	r4, r0, #0
    d438:	db02      	blt.n	d440 <os_time_advance+0xc>

    if (ticks > 0) {
    d43a:	2c00      	cmp	r4, #0
    d43c:	dc0a      	bgt.n	d454 <os_time_advance+0x20>
            os_callout_tick();
            os_sched_os_timer_exp();
            os_sched(NULL);
        }
    }
}
    d43e:	bd10      	pop	{r4, pc}
    assert(ticks >= 0);
    d440:	f7fe feac 	bl	c19c <hal_debugger_connected>
    d444:	b100      	cbz	r0, d448 <os_time_advance+0x14>
    d446:	be01      	bkpt	0x0001
    d448:	2300      	movs	r3, #0
    d44a:	461a      	mov	r2, r3
    d44c:	4619      	mov	r1, r3
    d44e:	4618      	mov	r0, r3
    d450:	f7ff f882 	bl	c558 <__assert_func>
        if (!os_started()) {
    d454:	f7ff f940 	bl	c6d8 <os_started>
    d458:	b920      	cbnz	r0, d464 <os_time_advance+0x30>
            g_os_time += ticks;
    d45a:	4b08      	ldr	r3, [pc, #32]	; (d47c <os_time_advance+0x48>)
    d45c:	6818      	ldr	r0, [r3, #0]
    d45e:	4420      	add	r0, r4
    d460:	6018      	str	r0, [r3, #0]
    d462:	e7ec      	b.n	d43e <os_time_advance+0xa>
            os_time_tick(ticks);
    d464:	4620      	mov	r0, r4
    d466:	f7ff ffad 	bl	d3c4 <os_time_tick>
            os_callout_tick();
    d46a:	f7ff fa23 	bl	c8b4 <os_callout_tick>
            os_sched_os_timer_exp();
    d46e:	f7ff fe93 	bl	d198 <os_sched_os_timer_exp>
            os_sched(NULL);
    d472:	2000      	movs	r0, #0
    d474:	f7ff fed8 	bl	d228 <os_sched>
}
    d478:	e7e1      	b.n	d43e <os_time_advance+0xa>
    d47a:	bf00      	nop
    d47c:	20002178 	.word	0x20002178

0000d480 <os_time_delay>:
void
os_time_delay(os_time_t osticks)
{
    os_sr_t sr;

    if (osticks > 0) {
    d480:	b900      	cbnz	r0, d484 <os_time_delay+0x4>
    d482:	4770      	bx	lr
{
    d484:	b538      	push	{r3, r4, r5, lr}
    d486:	4604      	mov	r4, r0
        OS_ENTER_CRITICAL(sr);
    d488:	f000 f81e 	bl	d4c8 <os_arch_save_sr>
    d48c:	4605      	mov	r5, r0
        os_sched_sleep(os_sched_get_current_task(), (os_time_t)osticks);
    d48e:	f7ff fdeb 	bl	d068 <os_sched_get_current_task>
    d492:	4621      	mov	r1, r4
    d494:	f7ff fdf4 	bl	d080 <os_sched_sleep>
        OS_EXIT_CRITICAL(sr);
    d498:	4628      	mov	r0, r5
    d49a:	f000 f81b 	bl	d4d4 <os_arch_restore_sr>
        os_sched(NULL);
    d49e:	2000      	movs	r0, #0
    d4a0:	f7ff fec2 	bl	d228 <os_sched>
    }
}
    d4a4:	bd38      	pop	{r3, r4, r5, pc}

0000d4a6 <os_arch_task_return_handler>:
{
    /*
     * If you are stuck here it means that task finished by
     * simple return which is not supported.
     */
    while (1);
    d4a6:	e7fe      	b.n	d4a6 <os_arch_task_return_handler>

0000d4a8 <timer_handler>:
{
    d4a8:	b508      	push	{r3, lr}
    os_time_advance(1);
    d4aa:	2001      	movs	r0, #1
    d4ac:	f7ff ffc2 	bl	d434 <os_time_advance>
}
    d4b0:	bd08      	pop	{r3, pc}
	...

0000d4b4 <os_arch_ctx_sw>:
{
    d4b4:	b508      	push	{r3, lr}
    os_sched_ctx_sw_hook(t);
    d4b6:	f7ff fdbf 	bl	d038 <os_sched_ctx_sw_hook>
    SCB->ICSR = SCB_ICSR_PENDSVSET_Msk;
    d4ba:	4b02      	ldr	r3, [pc, #8]	; (d4c4 <os_arch_ctx_sw+0x10>)
    d4bc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    d4c0:	605a      	str	r2, [r3, #4]
}
    d4c2:	bd08      	pop	{r3, pc}
    d4c4:	e000ed00 	.word	0xe000ed00

0000d4c8 <os_arch_save_sr>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
    d4c8:	f3ef 8010 	mrs	r0, PRIMASK
    isr_ctx = __get_PRIMASK() & 1;
    d4cc:	f000 0001 	and.w	r0, r0, #1
  __ASM volatile ("cpsid i" : : : "memory");
    d4d0:	b672      	cpsid	i
}
    d4d2:	4770      	bx	lr

0000d4d4 <os_arch_restore_sr>:
    if (!isr_ctx) {
    d4d4:	b900      	cbnz	r0, d4d8 <os_arch_restore_sr+0x4>
  __ASM volatile ("cpsie i" : : : "memory");
    d4d6:	b662      	cpsie	i
}
    d4d8:	4770      	bx	lr

0000d4da <os_arch_in_critical>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
    d4da:	f3ef 8010 	mrs	r0, PRIMASK
}
    d4de:	f000 0001 	and.w	r0, r0, #1
    d4e2:	4770      	bx	lr

0000d4e4 <os_arch_task_stack_init>:
}

os_stack_t *
os_arch_task_stack_init(struct os_task *t, os_stack_t *stack_top, int size)
{
    d4e4:	b570      	push	{r4, r5, r6, lr}
    d4e6:	4606      	mov	r6, r0
    d4e8:	460c      	mov	r4, r1
    int i;
    os_stack_t *s;
    struct stack_frame *sf;

    /* Get stack frame pointer */
    s = (os_stack_t *) ((uint8_t *) stack_top - sizeof(*sf));
    d4ea:	f1a1 0540 	sub.w	r5, r1, #64	; 0x40

    /* Zero out R1-R3, R12 */
    for (i = 9; i < 13; ++i) {
    d4ee:	2309      	movs	r3, #9
    d4f0:	e003      	b.n	d4fa <os_arch_task_stack_init+0x16>
        s[i] = 0;
    d4f2:	2200      	movs	r2, #0
    d4f4:	f845 2023 	str.w	r2, [r5, r3, lsl #2]
    for (i = 9; i < 13; ++i) {
    d4f8:	3301      	adds	r3, #1
    d4fa:	2b0c      	cmp	r3, #12
    d4fc:	ddf9      	ble.n	d4f2 <os_arch_task_stack_init+0xe>
    }

    /* Set registers R4 - R11 on stack. */
    os_arch_init_task_stack(s);
    d4fe:	4628      	mov	r0, r5
    d500:	f000 f8c0 	bl	d684 <os_arch_init_task_stack>

    /* Set remaining portions of stack frame */
    sf = (struct stack_frame *) s;
    sf->xpsr = INITIAL_xPSR;
    d504:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
    d508:	f844 3c04 	str.w	r3, [r4, #-4]
    sf->pc = (uint32_t)t->t_func;
    d50c:	6973      	ldr	r3, [r6, #20]
    d50e:	f844 3c08 	str.w	r3, [r4, #-8]
    sf->r0 = (uint32_t)t->t_arg;
    d512:	69b3      	ldr	r3, [r6, #24]
    d514:	f844 3c20 	str.w	r3, [r4, #-32]
    /* Set function to cache returns from tasks. */
    sf->lr = (uint32_t)os_arch_task_return_handler;
    d518:	4b02      	ldr	r3, [pc, #8]	; (d524 <os_arch_task_stack_init+0x40>)
    d51a:	f844 3c0c 	str.w	r3, [r4, #-12]
#if MYNEWT_VAL(HARDFLOAT)
    sf->exc_lr = INITIAL_LR;
#endif

    return (s);
}
    d51e:	4628      	mov	r0, r5
    d520:	bd70      	pop	{r4, r5, r6, pc}
    d522:	bf00      	nop
    d524:	0000d4a7 	.word	0x0000d4a7

0000d528 <os_arch_init>:

void
os_arch_init(void)
{
    d528:	b508      	push	{r3, lr}
    /*
     * Trap on divide-by-zero.
     */
    SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
    d52a:	4a04      	ldr	r2, [pc, #16]	; (d53c <os_arch_init+0x14>)
    d52c:	6953      	ldr	r3, [r2, #20]
    d52e:	f043 0310 	orr.w	r3, r3, #16
    d532:	6153      	str	r3, [r2, #20]
    os_init_idle_task();
    d534:	f7ff f8d6 	bl	c6e4 <os_init_idle_task>
}
    d538:	bd08      	pop	{r3, pc}
    d53a:	bf00      	nop
    d53c:	e000ed00 	.word	0xe000ed00

0000d540 <os_arch_os_init>:
    SVC_Call(os_arch_init);
}

os_error_t
os_arch_os_init(void)
{
    d540:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    d542:	f3ef 8405 	mrs	r4, IPSR
    os_error_t err;
    int i;

    /* Cannot be called within an ISR */
    err = OS_ERR_IN_ISR;
    if (__get_IPSR() == 0) {
    d546:	b90c      	cbnz	r4, d54c <os_arch_os_init+0xc>
        err = OS_OK;

        /* Drop priority for all interrupts */
        for (i = 0; i < sizeof(NVIC->IP); i++) {
    d548:	2400      	movs	r4, #0
    d54a:	e009      	b.n	d560 <os_arch_os_init+0x20>
    err = OS_ERR_IN_ISR;
    d54c:	2007      	movs	r0, #7
    d54e:	e02e      	b.n	d5ae <os_arch_os_init+0x6e>
            NVIC->IP[i] = -1;
    d550:	f104 4560 	add.w	r5, r4, #3758096384	; 0xe0000000
    d554:	f505 4561 	add.w	r5, r5, #57600	; 0xe100
    d558:	26ff      	movs	r6, #255	; 0xff
    d55a:	f885 6300 	strb.w	r6, [r5, #768]	; 0x300
        for (i = 0; i < sizeof(NVIC->IP); i++) {
    d55e:	3401      	adds	r4, #1
    d560:	2cef      	cmp	r4, #239	; 0xef
    d562:	d9f5      	bls.n	d550 <os_arch_os_init+0x10>
         * Install default interrupt handler for all interrupts except Reset,
         * which'll print out system state at the time of the interrupt, and
         * few other regs which should help in trying to figure out what went
         * wrong.
         */
        for (i = -NVIC_USER_IRQ_OFFSET + 2;
    d564:	f06f 040d 	mvn.w	r4, #13
    d568:	e007      	b.n	d57a <os_arch_os_init+0x3a>
             i < NVIC_NUM_VECTORS - NVIC_USER_IRQ_OFFSET; i++) {
            NVIC_SetVector(i, (uint32_t)os_default_irq_asm);
    d56a:	b265      	sxtb	r5, r4
  uint32_t vectors = (uint32_t )SCB->VTOR;
    d56c:	4e12      	ldr	r6, [pc, #72]	; (d5b8 <os_arch_os_init+0x78>)
    d56e:	68b6      	ldr	r6, [r6, #8]
  (* (int *) (vectors + ((int32_t)IRQn + NVIC_USER_IRQ_OFFSET) * 4)) = vector;
    d570:	3510      	adds	r5, #16
    d572:	4f12      	ldr	r7, [pc, #72]	; (d5bc <os_arch_os_init+0x7c>)
    d574:	f846 7025 	str.w	r7, [r6, r5, lsl #2]
             i < NVIC_NUM_VECTORS - NVIC_USER_IRQ_OFFSET; i++) {
    d578:	3401      	adds	r4, #1
        for (i = -NVIC_USER_IRQ_OFFSET + 2;
    d57a:	2c25      	cmp	r4, #37	; 0x25
    d57c:	ddf5      	ble.n	d56a <os_arch_os_init+0x2a>
  uint32_t vectors = (uint32_t )SCB->VTOR;
    d57e:	4c0e      	ldr	r4, [pc, #56]	; (d5b8 <os_arch_os_init+0x78>)
    d580:	68a5      	ldr	r5, [r4, #8]
  (* (int *) (vectors + ((int32_t)IRQn + NVIC_USER_IRQ_OFFSET) * 4)) = vector;
    d582:	4e0f      	ldr	r6, [pc, #60]	; (d5c0 <os_arch_os_init+0x80>)
    d584:	62ee      	str	r6, [r5, #44]	; 0x2c
  uint32_t vectors = (uint32_t )SCB->VTOR;
    d586:	68a5      	ldr	r5, [r4, #8]
  (* (int *) (vectors + ((int32_t)IRQn + NVIC_USER_IRQ_OFFSET) * 4)) = vector;
    d588:	4e0e      	ldr	r6, [pc, #56]	; (d5c4 <os_arch_os_init+0x84>)
    d58a:	63ae      	str	r6, [r5, #56]	; 0x38
  uint32_t vectors = (uint32_t )SCB->VTOR;
    d58c:	68a5      	ldr	r5, [r4, #8]
  (* (int *) (vectors + ((int32_t)IRQn + NVIC_USER_IRQ_OFFSET) * 4)) = vector;
    d58e:	4e0e      	ldr	r6, [pc, #56]	; (d5c8 <os_arch_os_init+0x88>)
    d590:	63ee      	str	r6, [r5, #60]	; 0x3c
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    d592:	25e0      	movs	r5, #224	; 0xe0
    d594:	f884 5022 	strb.w	r5, [r4, #34]	; 0x22
    d598:	2520      	movs	r5, #32
    d59a:	77e5      	strb	r5, [r4, #31]
  __ASM volatile ("MRS %0, control" : "=r" (result) );
    d59c:	f3ef 8414 	mrs	r4, CONTROL

        /* Set the SVC interrupt to priority 0 (highest configurable) */
        NVIC_SetPriority(SVCall_IRQn, SVC_PRIO);

        /* Check if privileged or not */
        if ((__get_CONTROL() & 1) == 0) {
    d5a0:	f014 0f01 	tst.w	r4, #1
    d5a4:	d004      	beq.n	d5b0 <os_arch_os_init+0x70>
    SVC_Call(os_arch_init);
    d5a6:	f8df c024 	ldr.w	ip, [pc, #36]	; d5cc <os_arch_os_init+0x8c>
    d5aa:	df00      	svc	0
        err = OS_OK;
    d5ac:	2000      	movs	r0, #0
            svc_os_arch_init();
        }
    }

    return err;
}
    d5ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            os_arch_init();
    d5b0:	f7ff ffba 	bl	d528 <os_arch_init>
        err = OS_OK;
    d5b4:	2000      	movs	r0, #0
    d5b6:	e7fa      	b.n	d5ae <os_arch_os_init+0x6e>
    d5b8:	e000ed00 	.word	0xe000ed00
    d5bc:	0000d707 	.word	0x0000d707
    d5c0:	0000d68b 	.word	0x0000d68b
    d5c4:	0000d6d1 	.word	0x0000d6d1
    d5c8:	0000d6fb 	.word	0x0000d6fb
    d5cc:	0000d529 	.word	0x0000d529

0000d5d0 <os_arch_start>:

uint32_t
os_arch_start(void)
{
    d5d0:	b510      	push	{r4, lr}
    struct os_task *t;

    /* Get the highest priority ready to run to set the current task */
    t = os_sched_next_task();
    d5d2:	f7ff fe23 	bl	d21c <os_sched_next_task>
    d5d6:	4604      	mov	r4, r0
    os_sched_set_current_task(t);
    d5d8:	f7ff fd4c 	bl	d074 <os_sched_set_current_task>

    /* Adjust PSP so it looks like this task just took an exception */
    __set_PSP((uint32_t)t->t_stackptr + offsetof(struct stack_frame, r0));
    d5dc:	6823      	ldr	r3, [r4, #0]
    d5de:	3320      	adds	r3, #32
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
    d5e0:	f383 8809 	msr	PSP, r3

    /* Intitialize and start system clock timer */
    os_tick_init(OS_TICKS_PER_SEC, OS_TICK_PRIO);
    d5e4:	2106      	movs	r1, #6
    d5e6:	2080      	movs	r0, #128	; 0x80
    d5e8:	f002 fcc2 	bl	ff70 <os_tick_init>

    /* Mark the OS as started, right before we run our first task */
    g_os_started = 1;
    d5ec:	4b03      	ldr	r3, [pc, #12]	; (d5fc <os_arch_start+0x2c>)
    d5ee:	2201      	movs	r2, #1
    d5f0:	601a      	str	r2, [r3, #0]

    /* Perform context switch */
    os_arch_ctx_sw(t);
    d5f2:	4620      	mov	r0, r4
    d5f4:	f7ff ff5e 	bl	d4b4 <os_arch_ctx_sw>

    return (uint32_t)(t->t_arg);
}
    d5f8:	69a0      	ldr	r0, [r4, #24]
    d5fa:	bd10      	pop	{r4, pc}
    d5fc:	20001320 	.word	0x20001320

0000d600 <os_arch_os_start>:
 *
 * @return os_error_t
 */
os_error_t
os_arch_os_start(void)
{
    d600:	b510      	push	{r4, lr}
     * privileged or un-privileged mode.
     *
     * We switch to using "empty" part of idle task's stack until
     * the svc_os_arch_start() executes SVC, and we will never return.
     */
    os_set_env(g_idle_task.t_stackptr - 1);
    d602:	4815      	ldr	r0, [pc, #84]	; (d658 <os_arch_os_start+0x58>)
    d604:	6800      	ldr	r0, [r0, #0]
    d606:	3804      	subs	r0, #4
    d608:	f000 f832 	bl	d670 <os_set_env>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    d60c:	f3ef 8405 	mrs	r4, IPSR

    err = OS_ERR_IN_ISR;
    if (__get_IPSR() == 0) {
    d610:	b9ec      	cbnz	r4, d64e <os_arch_os_start+0x4e>
  __ASM volatile ("MRS %0, control" : "=r" (result) );
    d612:	f3ef 8414 	mrs	r4, CONTROL
         * The following switch statement is really just a sanity check to
         * insure that the os initialization routine was called prior to the
         * os start routine.
         */
        err = OS_OK;
        switch (__get_CONTROL() & 0x03) {
    d616:	f004 0403 	and.w	r4, r4, #3
    d61a:	2c02      	cmp	r4, #2
    d61c:	d00d      	beq.n	d63a <os_arch_os_start+0x3a>
    d61e:	d803      	bhi.n	d628 <os_arch_os_start+0x28>
    d620:	2c01      	cmp	r4, #1
    d622:	d80f      	bhi.n	d644 <os_arch_os_start+0x44>
    d624:	2008      	movs	r0, #8
            svc_os_arch_start();
        }
    }

    return err;
}
    d626:	bd10      	pop	{r4, pc}
        switch (__get_CONTROL() & 0x03) {
    d628:	2c03      	cmp	r4, #3
    d62a:	d10b      	bne.n	d644 <os_arch_os_start+0x44>
            if  ((os_flags & 1) == OS_RUN_PRIV) {
    d62c:	4c0b      	ldr	r4, [pc, #44]	; (d65c <os_arch_os_start+0x5c>)
    d62e:	6824      	ldr	r4, [r4, #0]
    d630:	f014 0f01 	tst.w	r4, #1
    d634:	d106      	bne.n	d644 <os_arch_os_start+0x44>
                err = OS_ERR_PRIV;
    d636:	2008      	movs	r0, #8
    d638:	e7f5      	b.n	d626 <os_arch_os_start+0x26>
            if ((os_flags & 1) == OS_RUN_UNPRIV) {
    d63a:	4c08      	ldr	r4, [pc, #32]	; (d65c <os_arch_os_start+0x5c>)
    d63c:	6824      	ldr	r4, [r4, #0]
    d63e:	f014 0f01 	tst.w	r4, #1
    d642:	d106      	bne.n	d652 <os_arch_os_start+0x52>
    SVC_Call(os_arch_start);
    d644:	f8df c018 	ldr.w	ip, [pc, #24]	; d660 <os_arch_os_start+0x60>
    d648:	df00      	svc	0
}
    d64a:	2000      	movs	r0, #0
    d64c:	e7eb      	b.n	d626 <os_arch_os_start+0x26>
    err = OS_ERR_IN_ISR;
    d64e:	2007      	movs	r0, #7
    d650:	e7e9      	b.n	d626 <os_arch_os_start+0x26>
                err = OS_ERR_PRIV;
    d652:	2008      	movs	r0, #8
    d654:	e7e7      	b.n	d626 <os_arch_os_start+0x26>
    d656:	bf00      	nop
    d658:	20000174 	.word	0x20000174
    d65c:	2000217c 	.word	0x2000217c
    d660:	0000d5d1 	.word	0x0000d5d1

0000d664 <os_mbuf_pool_init>:

int
os_mbuf_pool_init(struct os_mbuf_pool *omp, struct os_mempool *mp,
                  uint16_t buf_len, uint16_t nbufs)
{
    omp->omp_databuf_len = buf_len - sizeof(struct os_mbuf);
    d664:	3a10      	subs	r2, #16
    d666:	8002      	strh	r2, [r0, #0]
    omp->omp_pool = mp;
    d668:	6041      	str	r1, [r0, #4]

    return (0);
}
    d66a:	2000      	movs	r0, #0
    d66c:	4770      	bx	lr
	...

0000d670 <os_set_env>:
        .global os_set_env
os_set_env:
        .fnstart
        .cantunwind

        MSR     PSP,R0
    d670:	f380 8809 	msr	PSP, r0
        LDR     R0,=os_flags
    d674:	482b      	ldr	r0, [pc, #172]	; (d724 <os_default_irq_asm+0x1e>)
        LDRB    R0,[R0]
    d676:	7800      	ldrb	r0, [r0, #0]
        ADDS    R0, R0, #2
    d678:	3002      	adds	r0, #2
        MSR     CONTROL,R0
    d67a:	f380 8814 	msr	CONTROL, r0
        ISB
    d67e:	f3bf 8f6f 	isb	sy
        BX      LR
    d682:	4770      	bx	lr

0000d684 <os_arch_init_task_stack>:
        .type   os_arch_init_task_stack, %function
        .global os_arch_init_task_stack
os_arch_init_task_stack:
        .fnstart

        STMIA   R0,{R4-R11}
    d684:	e880 0ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp}
        BX      LR
    d688:	4770      	bx	lr

0000d68a <SVC_Handler>:
        PUSH    {R4,LR}
        BL      os_trace_isr_enter
        POP     {R4,LR}
#endif

        MRS     R0,PSP                  /* Read PSP */
    d68a:	f3ef 8009 	mrs	r0, PSP
        LDR     R1,[R0,#24]             /* Read Saved PC from Stack */
    d68e:	6981      	ldr	r1, [r0, #24]
        LDRB    R1,[R1,#-2]             /* Load SVC Number */
    d690:	f811 1c02 	ldrb.w	r1, [r1, #-2]
        CBNZ    R1,SVC_User
    d694:	b951      	cbnz	r1, d6ac <SVC_User>

        LDM     R0,{R0-R3,R12}          /* Read R0-R3,R12 from stack */
    d696:	e890 100f 	ldmia.w	r0, {r0, r1, r2, r3, ip}
        PUSH    {R4,LR}                 /* Save EXC_RETURN */
    d69a:	b510      	push	{r4, lr}
        BLX     R12                     /* Call SVC Function */
    d69c:	47e0      	blx	ip
        POP     {R4,LR}                 /* Restore EXC_RETURN */
    d69e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

        MRS     R12,PSP                 /* Read PSP */
    d6a2:	f3ef 8c09 	mrs	ip, PSP
        STM     R12,{R0-R2}             /* Store return values */
    d6a6:	e88c 0007 	stmia.w	ip, {r0, r1, r2}
        PUSH    {R4,LR}
        BL      os_trace_isr_exit
        POP     {R4,LR}
#endif

        BX      LR                      /* Return from interrupt */
    d6aa:	4770      	bx	lr

0000d6ac <SVC_User>:

        /*------------------- User SVC ------------------------------*/
SVC_User:
        PUSH    {R4,LR}                 /* Save EXC_RETURN */
    d6ac:	b510      	push	{r4, lr}
        LDR     R2,=SVC_Count
    d6ae:	4a1e      	ldr	r2, [pc, #120]	; (d728 <os_default_irq_asm+0x22>)
        LDR     R2,[R2]
    d6b0:	6812      	ldr	r2, [r2, #0]
        CMP     R1,R2
    d6b2:	4291      	cmp	r1, r2
        BHI     SVC_Done                /* Overflow */
    d6b4:	d809      	bhi.n	d6ca <SVC_Done>

        LDR     R4,=SVC_Table-4
    d6b6:	4c1d      	ldr	r4, [pc, #116]	; (d72c <os_default_irq_asm+0x26>)
        LDR     R4,[R4,R1,LSL #2]       /* Load SVC Function Address */
    d6b8:	f854 4021 	ldr.w	r4, [r4, r1, lsl #2]

        LDM     R0,{R0-R3,R12}          /* Read R0-R3,R12 from stack */
    d6bc:	e890 100f 	ldmia.w	r0, {r0, r1, r2, r3, ip}
        BLX     R4                      /* Call SVC Function */
    d6c0:	47a0      	blx	r4

        MRS     R12,PSP
    d6c2:	f3ef 8c09 	mrs	ip, PSP
        STM     R12,{R0-R3}             /* Function return values */
    d6c6:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}

0000d6ca <SVC_Done>:
SVC_Done:
#if MYNEWT_VAL(OS_SYSVIEW)
        BL      os_trace_isr_exit
#endif
        POP     {R4,LR}                 /* Restore EXC_RETURN */
    d6ca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        BX      LR                      /* Return from interrupt */
    d6ce:	4770      	bx	lr

0000d6d0 <PendSV_Handler>:
        .global PendSV_Handler
PendSV_Handler:
        .fnstart
        .cantunwind

        LDR     R3,=g_os_run_list       /* Get highest priority task ready to run */
    d6d0:	4b17      	ldr	r3, [pc, #92]	; (d730 <os_default_irq_asm+0x2a>)
        LDR     R2,[R3]                 /* Store in R2 */
    d6d2:	681a      	ldr	r2, [r3, #0]
        LDR     R3,=g_current_task      /* Get current task */
    d6d4:	4b17      	ldr	r3, [pc, #92]	; (d734 <os_default_irq_asm+0x2e>)
        LDR     R1,[R3]                 /* Current task in R1 */
    d6d6:	6819      	ldr	r1, [r3, #0]
        CMP     R1,R2
    d6d8:	4291      	cmp	r1, r2
        IT      EQ
    d6da:	bf08      	it	eq
        BXEQ    LR                      /* RETI, no task switch */
    d6dc:	4770      	bxeq	lr

        MRS     R12,PSP                 /* Read PSP */
    d6de:	f3ef 8c09 	mrs	ip, PSP
        TST     LR,#0x10                /* is it extended frame? */
        IT      EQ
        VSTMDBEQ R12!,{S16-S31}         /* yes; push the regs */
        STMDB   R12!,{R4-R11,LR}        /* Save Old context */
#else
        STMDB   R12!,{R4-R11}           /* Save Old context */
    d6e2:	e92c 0ff0 	stmdb	ip!, {r4, r5, r6, r7, r8, r9, sl, fp}
#endif
        STR     R12,[R1,#0]             /* Update stack pointer in current task */
    d6e6:	f8c1 c000 	str.w	ip, [r1]
        STR     R2,[R3]                 /* g_current_task = highest ready */
    d6ea:	601a      	str	r2, [r3, #0]

        LDR     R12,[R2,#0]             /* get stack pointer of task we will start */
    d6ec:	f8d2 c000 	ldr.w	ip, [r2]
        ITTE    EQ
        VLDMIAEQ R12!,{S16-S31}         /* yes; pull the regs */
        MVNEQ   LR,#~0xFFFFFFED         /* BX treats it as extended */
        MVNNE   LR,#~0xFFFFFFFD         /* BX treats is as basic frame */
#else
        LDMIA   R12!,{R4-R11}           /* Restore New Context */
    d6f0:	e8bc 0ff0 	ldmia.w	ip!, {r4, r5, r6, r7, r8, r9, sl, fp}
#endif
        MSR     PSP,R12                 /* Write PSP */
    d6f4:	f38c 8809 	msr	PSP, ip
        MOV     R0, R2
        BL      os_trace_task_start_exec
        POP     {R4,LR}
#endif

        BX      LR                      /* Return to Thread Mode */
    d6f8:	4770      	bx	lr

0000d6fa <SysTick_Handler>:
        .global SysTick_Handler
SysTick_Handler:
        .fnstart
        .cantunwind

        PUSH    {R4,LR}                 /* Save EXC_RETURN */
    d6fa:	b510      	push	{r4, lr}
#if MYNEWT_VAL(OS_SYSVIEW)
        BL      os_trace_isr_enter
#endif
        BL      timer_handler
    d6fc:	f7ff fed4 	bl	d4a8 <timer_handler>
#if MYNEWT_VAL(OS_SYSVIEW)
        BL      os_trace_isr_exit
#endif
        POP     {R4,LR}                 /* Restore EXC_RETURN */
    d700:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        BX      LR
    d704:	4770      	bx	lr

0000d706 <os_default_irq_asm>:

        /*
         * LR = 0xfffffff9 if we were using MSP as SP
         * LR = 0xfffffffd if we were using PSP as SP
         */
        TST     LR,#4
    d706:	f01e 0f04 	tst.w	lr, #4
        ITE     EQ
    d70a:	bf0c      	ite	eq
        MRSEQ   R3,MSP
    d70c:	f3ef 8308 	mrseq	r3, MSP
        MRSNE   R3,PSP
    d710:	f3ef 8309 	mrsne	r3, PSP
        PUSH    {R3-R11,LR}
    d714:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
        MOV     R0, SP
    d718:	4668      	mov	r0, sp
        BL      os_default_irq
    d71a:	f7fe ff3f 	bl	c59c <os_default_irq>
        POP     {R3-R11,LR}                 /* Restore EXC_RETURN */
    d71e:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
        PUSH    {R4,LR}
        BL      os_trace_isr_exit
        POP     {R4,LR}
#endif

        BX      LR
    d722:	4770      	bx	lr
        LDR     R0,=os_flags
    d724:	2000217c 	.word	0x2000217c
        LDR     R2,=SVC_Count
    d728:	00000000 	.word	0x00000000
        LDR     R4,=SVC_Table-4
    d72c:	fffffffc 	.word	0xfffffffc
        LDR     R3,=g_os_run_list       /* Get highest priority task ready to run */
    d730:	2000010c 	.word	0x2000010c
        LDR     R3,=g_current_task      /* Get current task */
    d734:	20002134 	.word	0x20002134

0000d738 <memcmp>:
int memcmp(const void *s1, const void *s2, size_t n)
{
    int d = 0;

#if defined(ARCH_cortex_m3) || defined(ARCH_cortex_m4) || defined(ARCH_cortex_m7) || defined(ARCH_cortex_m33)
    asm (".syntax unified                   \n"
    d738:	b470      	push	{r4, r5, r6}
    d73a:	f04f 0500 	mov.w	r5, #0
    d73e:	f022 0603 	bic.w	r6, r2, #3
    d742:	e005      	b.n	d750 <test1>

0000d744 <loop1>:
    d744:	5943      	ldr	r3, [r0, r5]
    d746:	594c      	ldr	r4, [r1, r5]
    d748:	42a3      	cmp	r3, r4
    d74a:	d104      	bne.n	d756 <res1>
    d74c:	f105 0504 	add.w	r5, r5, #4

0000d750 <test1>:
    d750:	42b5      	cmp	r5, r6
    d752:	d1f7      	bne.n	d744 <loop1>
    d754:	e00d      	b.n	d772 <test2>

0000d756 <res1>:
    d756:	ba1b      	rev	r3, r3
    d758:	ba24      	rev	r4, r4
    d75a:	1b1b      	subs	r3, r3, r4
    d75c:	bf8c      	ite	hi
    d75e:	2301      	movhi	r3, #1
    d760:	f04f 33ff 	movls.w	r3, #4294967295	; 0xffffffff
    d764:	e009      	b.n	d77a <done>

0000d766 <loop2>:
    d766:	5d43      	ldrb	r3, [r0, r5]
    d768:	5d4c      	ldrb	r4, [r1, r5]
    d76a:	1b1b      	subs	r3, r3, r4
    d76c:	d105      	bne.n	d77a <done>
    d76e:	f105 0501 	add.w	r5, r5, #1

0000d772 <test2>:
    d772:	4295      	cmp	r5, r2
    d774:	d1f7      	bne.n	d766 <loop2>
    d776:	f04f 0300 	mov.w	r3, #0

0000d77a <done>:
    d77a:	4618      	mov	r0, r3
    d77c:	bc70      	pop	{r4, r5, r6}
			break;
	}
#endif

	return d;
}
    d77e:	4770      	bx	lr

0000d780 <memcpy>:
#if defined(__ARM_FEATURE_UNALIGNED)
        /*
         * We can speed up a bit by moving 32-bit words if unaligned access is
         * supported (e.g. Cortex-M3/4/7/33).
         */
        asm (".syntax unified           \n"
    d780:	e001      	b.n	d786 <test1>

0000d782 <loop1>:
    d782:	588b      	ldr	r3, [r1, r2]
    d784:	5083      	str	r3, [r0, r2]

0000d786 <test1>:
    d786:	3a04      	subs	r2, #4
    d788:	d5fb      	bpl.n	d782 <loop1>
    d78a:	f102 0204 	add.w	r2, r2, #4
             "       bpl  loop1         \n"
             "       add  r2, #4        \n"
            );
#endif

        asm (".syntax unified           \n"
    d78e:	e001      	b.n	d794 <test2>

0000d790 <loop2>:
    d790:	5c8b      	ldrb	r3, [r1, r2]
    d792:	5483      	strb	r3, [r0, r2]

0000d794 <test2>:
    d794:	3a01      	subs	r2, #1
    d796:	d5fb      	bpl.n	d790 <loop2>
		*q++ = *p++;
	}
#endif

	return dst;
}
    d798:	4770      	bx	lr

0000d79a <memset>:
#if defined(__arm__)
#include <mcu/cmsis_nvic.h>
#endif

void *memset(void *dst, int c, size_t n)
{
    d79a:	b430      	push	{r4, r5}
	asm volatile ("cld ; rep ; stosq ; movl %3,%%ecx ; rep ; stosb"
		      :"+c" (nq), "+D" (q)
		      : "a" ((unsigned char)c * 0x0101010101010101U),
			"r" ((uint32_t) n & 7));
#elif defined(__arm__)
    asm volatile (".syntax unified                          \n"
    d79c:	4605      	mov	r5, r0
    d79e:	b2c9      	uxtb	r1, r1
    d7a0:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
    d7a4:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
    d7a8:	18ab      	adds	r3, r5, r2
    d7aa:	2403      	movs	r4, #3
    d7ac:	4023      	ands	r3, r4
    d7ae:	1ad3      	subs	r3, r2, r3
    d7b0:	d40b      	bmi.n	d7ca <memset+0x30>
    d7b2:	e001      	b.n	d7b8 <memset+0x1e>
    d7b4:	3a01      	subs	r2, #1
    d7b6:	54a9      	strb	r1, [r5, r2]
    d7b8:	429a      	cmp	r2, r3
    d7ba:	d1fb      	bne.n	d7b4 <memset+0x1a>
    d7bc:	e000      	b.n	d7c0 <memset+0x26>
    d7be:	50a9      	str	r1, [r5, r2]
    d7c0:	3a04      	subs	r2, #4
    d7c2:	d5fc      	bpl.n	d7be <memset+0x24>
    d7c4:	3204      	adds	r2, #4
    d7c6:	e000      	b.n	d7ca <memset+0x30>
    d7c8:	54a9      	strb	r1, [r5, r2]
    d7ca:	3a01      	subs	r2, #1
    d7cc:	d5fc      	bpl.n	d7c8 <memset+0x2e>
		*q++ = c;
	}
#endif

	return dst;
}
    d7ce:	bc30      	pop	{r4, r5}
    d7d0:	4770      	bx	lr

0000d7d2 <strcmp>:
 */

#include <string.h>

int strcmp(const char *s1, const char *s2)
{
    d7d2:	b410      	push	{r4}
    d7d4:	4604      	mov	r4, r0
	const unsigned char *c2 = (const unsigned char *)s2;
	unsigned char ch;
	int d = 0;

	while (1) {
		d = (int)(ch = *c1++) - (int)*c2++;
    d7d6:	7822      	ldrb	r2, [r4, #0]
    d7d8:	3401      	adds	r4, #1
    d7da:	7808      	ldrb	r0, [r1, #0]
    d7dc:	3101      	adds	r1, #1
		if (d || !ch)
    d7de:	1a10      	subs	r0, r2, r0
    d7e0:	d101      	bne.n	d7e6 <strcmp+0x14>
    d7e2:	2a00      	cmp	r2, #0
    d7e4:	d1f7      	bne.n	d7d6 <strcmp+0x4>
			break;
	}

	return d;
}
    d7e6:	bc10      	pop	{r4}
    d7e8:	4770      	bx	lr

0000d7ea <strlen>:

#include <string.h>

size_t strlen(const char *s)
{
	const char *ss = s;
    d7ea:	4603      	mov	r3, r0
	while (*ss)
    d7ec:	781a      	ldrb	r2, [r3, #0]
    d7ee:	b10a      	cbz	r2, d7f4 <strlen+0xa>
		ss++;
    d7f0:	3301      	adds	r3, #1
    d7f2:	e7fb      	b.n	d7ec <strlen+0x2>
	return ss - s;
}
    d7f4:	1a18      	subs	r0, r3, r0
    d7f6:	4770      	bx	lr

0000d7f8 <add_ascii_num_with_char>:
 * Helper function for terminal escape sequences with number parameter.
 * It adds ascii encoded number plus one character.
 */
static char *
add_ascii_num_with_char(char *str, unsigned int num, char c)
{
    d7f8:	b470      	push	{r4, r5, r6}
    char *p = str;
    d7fa:	4604      	mov	r4, r0
    char *s;
    char tmp;

    /* Put digits in reverse order first. */
    do {
        *p++ = (num % 10) + '0';
    d7fc:	4b10      	ldr	r3, [pc, #64]	; (d840 <add_ascii_num_with_char+0x48>)
    d7fe:	fba3 5301 	umull	r5, r3, r3, r1
    d802:	08db      	lsrs	r3, r3, #3
    d804:	461e      	mov	r6, r3
    d806:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    d80a:	eba1 0343 	sub.w	r3, r1, r3, lsl #1
    d80e:	4625      	mov	r5, r4
    d810:	3401      	adds	r4, #1
    d812:	3330      	adds	r3, #48	; 0x30
    d814:	702b      	strb	r3, [r5, #0]
        num /= 10;
    d816:	460b      	mov	r3, r1
    d818:	4631      	mov	r1, r6
    } while (num);
    d81a:	2b09      	cmp	r3, #9
    d81c:	d8ee      	bhi.n	d7fc <add_ascii_num_with_char+0x4>
    s = str;
    str = p;
    --p;
    d81e:	462b      	mov	r3, r5
    d820:	e005      	b.n	d82e <add_ascii_num_with_char+0x36>
    /* Revers order of characters, to get correct number representation */
    while (s < p) {
       tmp = *s;
    d822:	7801      	ldrb	r1, [r0, #0]
       *s++ = *p;
    d824:	781e      	ldrb	r6, [r3, #0]
    d826:	f800 6b01 	strb.w	r6, [r0], #1
       *p-- = tmp;
    d82a:	f803 1901 	strb.w	r1, [r3], #-1
    while (s < p) {
    d82e:	4283      	cmp	r3, r0
    d830:	d8f7      	bhi.n	d822 <add_ascii_num_with_char+0x2a>
    }

    *str++ = c;
    d832:	7022      	strb	r2, [r4, #0]
    *str = '\0';
    d834:	2300      	movs	r3, #0
    d836:	7063      	strb	r3, [r4, #1]

    return str;
}
    d838:	1ca8      	adds	r0, r5, #2
    d83a:	bc70      	pop	{r4, r5, r6}
    d83c:	4770      	bx	lr
    d83e:	bf00      	nop
    d840:	cccccccd 	.word	0xcccccccd

0000d844 <console_handle_line>:
    esc_state &= ~ESC_ANSI;
}

static void
console_handle_line(void)
{
    d844:	b508      	push	{r3, lr}
    cur = 0;
    d846:	2300      	movs	r3, #0
    d848:	4a08      	ldr	r2, [pc, #32]	; (d86c <console_handle_line+0x28>)
    d84a:	8013      	strh	r3, [r2, #0]
    trailing_chars = 0;
    d84c:	4a08      	ldr	r2, [pc, #32]	; (d870 <console_handle_line+0x2c>)
    d84e:	8013      	strh	r3, [r2, #0]
    os_eventq_put(lines_queue, current_line_ev);
    d850:	4b08      	ldr	r3, [pc, #32]	; (d874 <console_handle_line+0x30>)
    d852:	6819      	ldr	r1, [r3, #0]
    d854:	4b08      	ldr	r3, [pc, #32]	; (d878 <console_handle_line+0x34>)
    d856:	6818      	ldr	r0, [r3, #0]
    d858:	f7ff f945 	bl	cae6 <os_eventq_put>

#if MYNEWT_VAL(CONSOLE_COMPAT)
    if (console_compat_rx_cb) {
    d85c:	4b07      	ldr	r3, [pc, #28]	; (d87c <console_handle_line+0x38>)
    d85e:	681b      	ldr	r3, [r3, #0]
    d860:	b103      	cbz	r3, d864 <console_handle_line+0x20>
        console_compat_rx_cb();
    d862:	4798      	blx	r3
    }
#endif

    current_line_ev = NULL;
    d864:	4b03      	ldr	r3, [pc, #12]	; (d874 <console_handle_line+0x30>)
    d866:	2200      	movs	r2, #0
    d868:	601a      	str	r2, [r3, #0]
}
    d86a:	bd08      	pop	{r3, pc}
    d86c:	200021b0 	.word	0x200021b0
    d870:	200021ca 	.word	0x200021ca
    d874:	200021b4 	.word	0x200021b4
    d878:	200021c0 	.word	0x200021c0
    d87c:	2000219c 	.word	0x2000219c

0000d880 <console_filter_out>:
{
    d880:	b508      	push	{r3, lr}
    if (g_console_silence) {
    d882:	4b0b      	ldr	r3, [pc, #44]	; (d8b0 <console_filter_out+0x30>)
    d884:	781b      	ldrb	r3, [r3, #0]
    d886:	b95b      	cbnz	r3, d8a0 <console_filter_out+0x20>
    if (prompt_has_focus || g_is_output_nlip) {
    d888:	4b0a      	ldr	r3, [pc, #40]	; (d8b4 <console_filter_out+0x34>)
    d88a:	781b      	ldrb	r3, [r3, #0]
    d88c:	b94b      	cbnz	r3, d8a2 <console_filter_out+0x22>
    console_is_midline = c != '\n' && c != '\r';
    d88e:	280a      	cmp	r0, #10
    d890:	d00c      	beq.n	d8ac <console_filter_out+0x2c>
    d892:	280d      	cmp	r0, #13
    d894:	d008      	beq.n	d8a8 <console_filter_out+0x28>
    d896:	2201      	movs	r2, #1
    d898:	4b07      	ldr	r3, [pc, #28]	; (d8b8 <console_filter_out+0x38>)
    d89a:	601a      	str	r2, [r3, #0]
        c = console_out_nolock(c);
    d89c:	f000 fd7c 	bl	e398 <console_out_nolock>
}
    d8a0:	bd08      	pop	{r3, pc}
        return console_out_nolock(c);
    d8a2:	f000 fd79 	bl	e398 <console_out_nolock>
    d8a6:	e7fb      	b.n	d8a0 <console_filter_out+0x20>
    console_is_midline = c != '\n' && c != '\r';
    d8a8:	2200      	movs	r2, #0
    d8aa:	e7f5      	b.n	d898 <console_filter_out+0x18>
    d8ac:	2200      	movs	r2, #0
    d8ae:	e7f3      	b.n	d898 <console_filter_out+0x18>
    d8b0:	200021bd 	.word	0x200021bd
    d8b4:	200021bf 	.word	0x200021bf
    d8b8:	200021a0 	.word	0x200021a0

0000d8bc <console_filter_write>:
{
    d8bc:	b570      	push	{r4, r5, r6, lr}
    d8be:	4606      	mov	r6, r0
    d8c0:	460d      	mov	r5, r1
    for (i = 0; i < cnt; i++) {
    d8c2:	2400      	movs	r4, #0
    d8c4:	42ac      	cmp	r4, r5
    d8c6:	da07      	bge.n	d8d8 <console_filter_write+0x1c>
        if (console_filter_out((int)str[i]) == EOF) {
    d8c8:	5d30      	ldrb	r0, [r6, r4]
    d8ca:	f7ff ffd9 	bl	d880 <console_filter_out>
    d8ce:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
    d8d2:	d001      	beq.n	d8d8 <console_filter_write+0x1c>
    for (i = 0; i < cnt; i++) {
    d8d4:	3401      	adds	r4, #1
    d8d6:	e7f5      	b.n	d8c4 <console_filter_write+0x8>
}
    d8d8:	bd70      	pop	{r4, r5, r6, pc}
	...

0000d8dc <console_append_char>:
    return handled;
}

static int
console_append_char(char *line, uint8_t byte)
{
    d8dc:	b508      	push	{r3, lr}
    if (cur + trailing_chars >= MYNEWT_VAL(CONSOLE_MAX_INPUT_LEN) - 1) {
    d8de:	4b0d      	ldr	r3, [pc, #52]	; (d914 <console_append_char+0x38>)
    d8e0:	881b      	ldrh	r3, [r3, #0]
    d8e2:	4a0d      	ldr	r2, [pc, #52]	; (d918 <console_append_char+0x3c>)
    d8e4:	8812      	ldrh	r2, [r2, #0]
    d8e6:	4413      	add	r3, r2
    d8e8:	2bfe      	cmp	r3, #254	; 0xfe
    d8ea:	dc0e      	bgt.n	d90a <console_append_char+0x2e>
        return 0;
    }

    line[cur + trailing_chars] = byte;
    d8ec:	54c1      	strb	r1, [r0, r3]

    if (byte == '\0') {
    d8ee:	b171      	cbz	r1, d90e <console_append_char+0x32>
        return 1;
    }

    if (echo) {
    d8f0:	4b0a      	ldr	r3, [pc, #40]	; (d91c <console_append_char+0x40>)
    d8f2:	681b      	ldr	r3, [r3, #0]
    d8f4:	b92b      	cbnz	r3, d902 <console_append_char+0x26>
        /* Echo back to console */
        console_switch_to_prompt();
        console_out_nolock(byte);
        console_switch_to_logs();
    }
    ++cur;
    d8f6:	4a07      	ldr	r2, [pc, #28]	; (d914 <console_append_char+0x38>)
    d8f8:	8813      	ldrh	r3, [r2, #0]
    d8fa:	3301      	adds	r3, #1
    d8fc:	8013      	strh	r3, [r2, #0]
    return 1;
    d8fe:	2001      	movs	r0, #1
}
    d900:	bd08      	pop	{r3, pc}
        console_out_nolock(byte);
    d902:	4608      	mov	r0, r1
    d904:	f000 fd48 	bl	e398 <console_out_nolock>
        console_switch_to_logs();
    d908:	e7f5      	b.n	d8f6 <console_append_char+0x1a>
        return 0;
    d90a:	2000      	movs	r0, #0
    d90c:	e7f8      	b.n	d900 <console_append_char+0x24>
        return 1;
    d90e:	2001      	movs	r0, #1
    d910:	e7f6      	b.n	d900 <console_append_char+0x24>
    d912:	bf00      	nop
    d914:	200021b0 	.word	0x200021b0
    d918:	200021ca 	.word	0x200021ca
    d91c:	2000011c 	.word	0x2000011c

0000d920 <console_write_nolock>:
{
    d920:	b570      	push	{r4, r5, r6, lr}
    d922:	4606      	mov	r6, r0
    d924:	460d      	mov	r5, r1
    for (i = 0; i < cnt; i++) {
    d926:	2400      	movs	r4, #0
    d928:	42ac      	cmp	r4, r5
    d92a:	da07      	bge.n	d93c <console_write_nolock+0x1c>
        if (console_out_nolock((int)str[i]) == EOF) {
    d92c:	5d30      	ldrb	r0, [r6, r4]
    d92e:	f000 fd33 	bl	e398 <console_out_nolock>
    d932:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
    d936:	d001      	beq.n	d93c <console_write_nolock+0x1c>
    for (i = 0; i < cnt; i++) {
    d938:	3401      	adds	r4, #1
    d93a:	e7f5      	b.n	d928 <console_write_nolock+0x8>
}
    d93c:	bd70      	pop	{r4, r5, r6, pc}
	...

0000d940 <handle_end>:
    if (trailing_chars) {
    d940:	4b11      	ldr	r3, [pc, #68]	; (d988 <handle_end+0x48>)
    d942:	8819      	ldrh	r1, [r3, #0]
    d944:	b901      	cbnz	r1, d948 <handle_end+0x8>
    d946:	4770      	bx	lr
{
    d948:	b510      	push	{r4, lr}
    d94a:	b084      	sub	sp, #16
    char seq[14] = CSI;
    d94c:	f645 331b 	movw	r3, #23323	; 0x5b1b
    d950:	9300      	str	r3, [sp, #0]
    d952:	2300      	movs	r3, #0
    d954:	9301      	str	r3, [sp, #4]
    d956:	9302      	str	r3, [sp, #8]
    d958:	f8ad 300c 	strh.w	r3, [sp, #12]
    if (count) {
    d95c:	b949      	cbnz	r1, d972 <handle_end+0x32>
        cur += trailing_chars;
    d95e:	490b      	ldr	r1, [pc, #44]	; (d98c <handle_end+0x4c>)
    d960:	4a09      	ldr	r2, [pc, #36]	; (d988 <handle_end+0x48>)
    d962:	880b      	ldrh	r3, [r1, #0]
    d964:	8810      	ldrh	r0, [r2, #0]
    d966:	4403      	add	r3, r0
    d968:	800b      	strh	r3, [r1, #0]
        trailing_chars = 0;
    d96a:	2300      	movs	r3, #0
    d96c:	8013      	strh	r3, [r2, #0]
}
    d96e:	b004      	add	sp, #16
    d970:	bd10      	pop	{r4, pc}
        p = add_ascii_num_with_char(seq + 2, count, 'C');
    d972:	466c      	mov	r4, sp
    d974:	2243      	movs	r2, #67	; 0x43
    d976:	f10d 0002 	add.w	r0, sp, #2
    d97a:	f7ff ff3d 	bl	d7f8 <add_ascii_num_with_char>
        console_write_nolock(seq, p - seq);
    d97e:	1b01      	subs	r1, r0, r4
    d980:	4620      	mov	r0, r4
    d982:	f7ff ffcd 	bl	d920 <console_write_nolock>
    d986:	e7ea      	b.n	d95e <handle_end+0x1e>
    d988:	200021ca 	.word	0x200021ca
    d98c:	200021b0 	.word	0x200021b0

0000d990 <handle_home>:
    if (cur) {
    d990:	4b11      	ldr	r3, [pc, #68]	; (d9d8 <handle_home+0x48>)
    d992:	8819      	ldrh	r1, [r3, #0]
    d994:	b901      	cbnz	r1, d998 <handle_home+0x8>
    d996:	4770      	bx	lr
{
    d998:	b510      	push	{r4, lr}
    d99a:	b084      	sub	sp, #16
    char seq[14] = CSI;
    d99c:	f645 331b 	movw	r3, #23323	; 0x5b1b
    d9a0:	9300      	str	r3, [sp, #0]
    d9a2:	2300      	movs	r3, #0
    d9a4:	9301      	str	r3, [sp, #4]
    d9a6:	9302      	str	r3, [sp, #8]
    d9a8:	f8ad 300c 	strh.w	r3, [sp, #12]
    if (count) {
    d9ac:	b949      	cbnz	r1, d9c2 <handle_home+0x32>
        trailing_chars += cur;
    d9ae:	490b      	ldr	r1, [pc, #44]	; (d9dc <handle_home+0x4c>)
    d9b0:	4a09      	ldr	r2, [pc, #36]	; (d9d8 <handle_home+0x48>)
    d9b2:	880b      	ldrh	r3, [r1, #0]
    d9b4:	8810      	ldrh	r0, [r2, #0]
    d9b6:	4403      	add	r3, r0
    d9b8:	800b      	strh	r3, [r1, #0]
        cur = 0;
    d9ba:	2300      	movs	r3, #0
    d9bc:	8013      	strh	r3, [r2, #0]
}
    d9be:	b004      	add	sp, #16
    d9c0:	bd10      	pop	{r4, pc}
        p = add_ascii_num_with_char(seq + 2, count, 'D');
    d9c2:	466c      	mov	r4, sp
    d9c4:	2244      	movs	r2, #68	; 0x44
    d9c6:	f10d 0002 	add.w	r0, sp, #2
    d9ca:	f7ff ff15 	bl	d7f8 <add_ascii_num_with_char>
        console_write_nolock(seq, p - seq);
    d9ce:	1b01      	subs	r1, r0, r4
    d9d0:	4620      	mov	r0, r4
    d9d2:	f7ff ffa5 	bl	d920 <console_write_nolock>
    d9d6:	e7ea      	b.n	d9ae <handle_home+0x1e>
    d9d8:	200021b0 	.word	0x200021b0
    d9dc:	200021ca 	.word	0x200021ca

0000d9e0 <del_char>:
{
    d9e0:	b530      	push	{r4, r5, lr}
    d9e2:	b085      	sub	sp, #20
    d9e4:	4604      	mov	r4, r0
    left = trailing_chars;
    d9e6:	4b17      	ldr	r3, [pc, #92]	; (da44 <del_char+0x64>)
    d9e8:	881b      	ldrh	r3, [r3, #0]
    while (left-- > 1) {
    d9ea:	1e5d      	subs	r5, r3, #1
    d9ec:	2b01      	cmp	r3, #1
    d9ee:	dd06      	ble.n	d9fe <del_char+0x1e>
        *pos = *(pos + 1);
    d9f0:	7860      	ldrb	r0, [r4, #1]
    d9f2:	f804 0b01 	strb.w	r0, [r4], #1
        console_out_nolock(*(pos++));
    d9f6:	f000 fccf 	bl	e398 <console_out_nolock>
    while (left-- > 1) {
    d9fa:	462b      	mov	r3, r5
    d9fc:	e7f5      	b.n	d9ea <del_char+0xa>
    if (trailing_chars) {
    d9fe:	4b11      	ldr	r3, [pc, #68]	; (da44 <del_char+0x64>)
    da00:	881b      	ldrh	r3, [r3, #0]
    da02:	b90b      	cbnz	r3, da08 <del_char+0x28>
}
    da04:	b005      	add	sp, #20
    da06:	bd30      	pop	{r4, r5, pc}
        console_out_nolock(' ');
    da08:	2020      	movs	r0, #32
    da0a:	f000 fcc5 	bl	e398 <console_out_nolock>
        cursor_backward(trailing_chars);
    da0e:	4b0d      	ldr	r3, [pc, #52]	; (da44 <del_char+0x64>)
    da10:	8819      	ldrh	r1, [r3, #0]
    char seq[14] = CSI;
    da12:	f645 331b 	movw	r3, #23323	; 0x5b1b
    da16:	9300      	str	r3, [sp, #0]
    da18:	2300      	movs	r3, #0
    da1a:	9301      	str	r3, [sp, #4]
    da1c:	9302      	str	r3, [sp, #8]
    da1e:	f8ad 300c 	strh.w	r3, [sp, #12]
    if (count) {
    da22:	b921      	cbnz	r1, da2e <del_char+0x4e>
        trailing_chars--;
    da24:	4a07      	ldr	r2, [pc, #28]	; (da44 <del_char+0x64>)
    da26:	8813      	ldrh	r3, [r2, #0]
    da28:	3b01      	subs	r3, #1
    da2a:	8013      	strh	r3, [r2, #0]
}
    da2c:	e7ea      	b.n	da04 <del_char+0x24>
        p = add_ascii_num_with_char(seq + 2, count, 'D');
    da2e:	466c      	mov	r4, sp
    da30:	2244      	movs	r2, #68	; 0x44
    da32:	f10d 0002 	add.w	r0, sp, #2
    da36:	f7ff fedf 	bl	d7f8 <add_ascii_num_with_char>
        console_write_nolock(seq, p - seq);
    da3a:	1b01      	subs	r1, r0, r4
    da3c:	4620      	mov	r0, r4
    da3e:	f7ff ff6f 	bl	d920 <console_write_nolock>
    da42:	e7ef      	b.n	da24 <del_char+0x44>
    da44:	200021ca 	.word	0x200021ca

0000da48 <handle_delete>:
{
    da48:	b508      	push	{r3, lr}
    if (trailing_chars) {
    da4a:	4b05      	ldr	r3, [pc, #20]	; (da60 <handle_delete+0x18>)
    da4c:	881b      	ldrh	r3, [r3, #0]
    da4e:	b903      	cbnz	r3, da52 <handle_delete+0xa>
}
    da50:	bd08      	pop	{r3, pc}
        del_char(&line[cur]);
    da52:	4b04      	ldr	r3, [pc, #16]	; (da64 <handle_delete+0x1c>)
    da54:	881b      	ldrh	r3, [r3, #0]
    da56:	4418      	add	r0, r3
    da58:	f7ff ffc2 	bl	d9e0 <del_char>
}
    da5c:	e7f8      	b.n	da50 <handle_delete+0x8>
    da5e:	bf00      	nop
    da60:	200021ca 	.word	0x200021ca
    da64:	200021b0 	.word	0x200021b0

0000da68 <handle_ansi>:
{
    da68:	4603      	mov	r3, r0
    if (esc_state & ESC_ANSI_FIRST) {
    da6a:	4a5e      	ldr	r2, [pc, #376]	; (dbe4 <handle_ansi+0x17c>)
    da6c:	6812      	ldr	r2, [r2, #0]
    da6e:	f012 0f04 	tst.w	r2, #4
    da72:	d025      	beq.n	dac0 <handle_ansi+0x58>
        esc_state &= ~ESC_ANSI_FIRST;
    da74:	f022 0204 	bic.w	r2, r2, #4
    da78:	485a      	ldr	r0, [pc, #360]	; (dbe4 <handle_ansi+0x17c>)
    da7a:	6002      	str	r2, [r0, #0]
        if (!isdigit(byte)) {
    da7c:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    da80:	2809      	cmp	r0, #9
    da82:	d912      	bls.n	daaa <handle_ansi+0x42>
            ansi_val = 1;
    da84:	4a58      	ldr	r2, [pc, #352]	; (dbe8 <handle_ansi+0x180>)
    da86:	2001      	movs	r0, #1
    da88:	6010      	str	r0, [r2, #0]
{
    da8a:	b510      	push	{r4, lr}
    da8c:	b084      	sub	sp, #16
    switch (byte) {
    da8e:	2b48      	cmp	r3, #72	; 0x48
    da90:	d840      	bhi.n	db14 <handle_ansi+0xac>
    da92:	2b43      	cmp	r3, #67	; 0x43
    da94:	f0c0 8093 	bcc.w	dbbe <handle_ansi+0x156>
    da98:	3b43      	subs	r3, #67	; 0x43
    da9a:	2b05      	cmp	r3, #5
    da9c:	f200 808f 	bhi.w	dbbe <handle_ansi+0x156>
    daa0:	e8df f003 	tbb	[pc, r3]
    daa4:	948d4668 	.word	0x948d4668
    daa8:	8a8d      	.short	0x8a8d
        esc_state |= ESC_ANSI_VAL;
    daaa:	f042 0208 	orr.w	r2, r2, #8
    daae:	494d      	ldr	r1, [pc, #308]	; (dbe4 <handle_ansi+0x17c>)
    dab0:	600a      	str	r2, [r1, #0]
        ansi_val = byte - '0';
    dab2:	3b30      	subs	r3, #48	; 0x30
    dab4:	4a4c      	ldr	r2, [pc, #304]	; (dbe8 <handle_ansi+0x180>)
    dab6:	6013      	str	r3, [r2, #0]
        ansi_val_2 = 0;
    dab8:	4b4c      	ldr	r3, [pc, #304]	; (dbec <handle_ansi+0x184>)
    daba:	2200      	movs	r2, #0
    dabc:	601a      	str	r2, [r3, #0]
        return;
    dabe:	4770      	bx	lr
    if (esc_state & ESC_ANSI_VAL) {
    dac0:	f012 0f08 	tst.w	r2, #8
    dac4:	d0e1      	beq.n	da8a <handle_ansi+0x22>
        if (isdigit(byte)) {
    dac6:	3830      	subs	r0, #48	; 0x30
    dac8:	2809      	cmp	r0, #9
    daca:	d906      	bls.n	dada <handle_ansi+0x72>
        if (byte == ';' && !(esc_state & ESC_ANSI_VAL_2)) {
    dacc:	2b3b      	cmp	r3, #59	; 0x3b
    dace:	d019      	beq.n	db04 <handle_ansi+0x9c>
        esc_state &= ~ESC_ANSI_VAL_2;
    dad0:	f022 0218 	bic.w	r2, r2, #24
    dad4:	4843      	ldr	r0, [pc, #268]	; (dbe4 <handle_ansi+0x17c>)
    dad6:	6002      	str	r2, [r0, #0]
    dad8:	e7d7      	b.n	da8a <handle_ansi+0x22>
            if (esc_state & ESC_ANSI_VAL_2) {
    dada:	f012 0f10 	tst.w	r2, #16
    dade:	d008      	beq.n	daf2 <handle_ansi+0x8a>
                ansi_val_2 *= 10;
    dae0:	4942      	ldr	r1, [pc, #264]	; (dbec <handle_ansi+0x184>)
    dae2:	680a      	ldr	r2, [r1, #0]
    dae4:	eb02 0282 	add.w	r2, r2, r2, lsl #2
                ansi_val_2 += byte - '0';
    dae8:	eb03 0342 	add.w	r3, r3, r2, lsl #1
    daec:	3b30      	subs	r3, #48	; 0x30
    daee:	600b      	str	r3, [r1, #0]
    daf0:	4770      	bx	lr
                ansi_val *= 10;
    daf2:	493d      	ldr	r1, [pc, #244]	; (dbe8 <handle_ansi+0x180>)
    daf4:	680a      	ldr	r2, [r1, #0]
    daf6:	eb02 0282 	add.w	r2, r2, r2, lsl #2
                ansi_val += byte - '0';
    dafa:	eb03 0342 	add.w	r3, r3, r2, lsl #1
    dafe:	3b30      	subs	r3, #48	; 0x30
    db00:	600b      	str	r3, [r1, #0]
            return;
    db02:	4770      	bx	lr
        if (byte == ';' && !(esc_state & ESC_ANSI_VAL_2)) {
    db04:	f012 0f10 	tst.w	r2, #16
    db08:	d1e2      	bne.n	dad0 <handle_ansi+0x68>
            esc_state |= ESC_ANSI_VAL_2;
    db0a:	f042 0210 	orr.w	r2, r2, #16
    db0e:	4b35      	ldr	r3, [pc, #212]	; (dbe4 <handle_ansi+0x17c>)
    db10:	601a      	str	r2, [r3, #0]
            return;
    db12:	4770      	bx	lr
    switch (byte) {
    db14:	2b7e      	cmp	r3, #126	; 0x7e
    db16:	d152      	bne.n	dbbe <handle_ansi+0x156>
        switch (ansi_val) {
    db18:	4b33      	ldr	r3, [pc, #204]	; (dbe8 <handle_ansi+0x180>)
    db1a:	681b      	ldr	r3, [r3, #0]
    db1c:	2b03      	cmp	r3, #3
    db1e:	d059      	beq.n	dbd4 <handle_ansi+0x16c>
    db20:	2b04      	cmp	r3, #4
    db22:	d05b      	beq.n	dbdc <handle_ansi+0x174>
    db24:	2b01      	cmp	r3, #1
    db26:	d14a      	bne.n	dbbe <handle_ansi+0x156>
            handle_home(line);
    db28:	4608      	mov	r0, r1
    db2a:	f7ff ff31 	bl	d990 <handle_home>
            break;
    db2e:	e046      	b.n	dbbe <handle_ansi+0x156>
        if (ansi_val > cur) {
    db30:	4b2f      	ldr	r3, [pc, #188]	; (dbf0 <handle_ansi+0x188>)
    db32:	881b      	ldrh	r3, [r3, #0]
    db34:	4a2c      	ldr	r2, [pc, #176]	; (dbe8 <handle_ansi+0x180>)
    db36:	6811      	ldr	r1, [r2, #0]
    db38:	428b      	cmp	r3, r1
    db3a:	d340      	bcc.n	dbbe <handle_ansi+0x156>
        trailing_chars += ansi_val;
    db3c:	b28a      	uxth	r2, r1
    db3e:	4c2d      	ldr	r4, [pc, #180]	; (dbf4 <handle_ansi+0x18c>)
    db40:	8820      	ldrh	r0, [r4, #0]
    db42:	4410      	add	r0, r2
    db44:	8020      	strh	r0, [r4, #0]
        cur -= ansi_val;
    db46:	1a9b      	subs	r3, r3, r2
    db48:	4a29      	ldr	r2, [pc, #164]	; (dbf0 <handle_ansi+0x188>)
    db4a:	8013      	strh	r3, [r2, #0]
    char seq[14] = CSI;
    db4c:	f645 331b 	movw	r3, #23323	; 0x5b1b
    db50:	9300      	str	r3, [sp, #0]
    db52:	2300      	movs	r3, #0
    db54:	9301      	str	r3, [sp, #4]
    db56:	9302      	str	r3, [sp, #8]
    db58:	f8ad 300c 	strh.w	r3, [sp, #12]
    if (count) {
    db5c:	b379      	cbz	r1, dbbe <handle_ansi+0x156>
        p = add_ascii_num_with_char(seq + 2, count, 'D');
    db5e:	466c      	mov	r4, sp
    db60:	2244      	movs	r2, #68	; 0x44
    db62:	f10d 0002 	add.w	r0, sp, #2
    db66:	f7ff fe47 	bl	d7f8 <add_ascii_num_with_char>
        console_write_nolock(seq, p - seq);
    db6a:	1b01      	subs	r1, r0, r4
    db6c:	4620      	mov	r0, r4
    db6e:	f7ff fed7 	bl	d920 <console_write_nolock>
}
    db72:	e024      	b.n	dbbe <handle_ansi+0x156>
        if (ansi_val > trailing_chars) {
    db74:	4b1f      	ldr	r3, [pc, #124]	; (dbf4 <handle_ansi+0x18c>)
    db76:	881b      	ldrh	r3, [r3, #0]
    db78:	4a1b      	ldr	r2, [pc, #108]	; (dbe8 <handle_ansi+0x180>)
    db7a:	6811      	ldr	r1, [r2, #0]
    db7c:	428b      	cmp	r3, r1
    db7e:	d31e      	bcc.n	dbbe <handle_ansi+0x156>
        trailing_chars -= ansi_val;
    db80:	b28a      	uxth	r2, r1
    db82:	1a9b      	subs	r3, r3, r2
    db84:	481b      	ldr	r0, [pc, #108]	; (dbf4 <handle_ansi+0x18c>)
    db86:	8003      	strh	r3, [r0, #0]
        cur += ansi_val;
    db88:	4b19      	ldr	r3, [pc, #100]	; (dbf0 <handle_ansi+0x188>)
    db8a:	8818      	ldrh	r0, [r3, #0]
    db8c:	4402      	add	r2, r0
    db8e:	801a      	strh	r2, [r3, #0]
    char seq[14] = CSI;
    db90:	f645 331b 	movw	r3, #23323	; 0x5b1b
    db94:	9300      	str	r3, [sp, #0]
    db96:	2300      	movs	r3, #0
    db98:	9301      	str	r3, [sp, #4]
    db9a:	9302      	str	r3, [sp, #8]
    db9c:	f8ad 300c 	strh.w	r3, [sp, #12]
    if (count) {
    dba0:	b169      	cbz	r1, dbbe <handle_ansi+0x156>
        p = add_ascii_num_with_char(seq + 2, count, 'C');
    dba2:	466c      	mov	r4, sp
    dba4:	2243      	movs	r2, #67	; 0x43
    dba6:	f10d 0002 	add.w	r0, sp, #2
    dbaa:	f7ff fe25 	bl	d7f8 <add_ascii_num_with_char>
        console_write_nolock(seq, p - seq);
    dbae:	1b01      	subs	r1, r0, r4
    dbb0:	4620      	mov	r0, r4
    dbb2:	f7ff feb5 	bl	d920 <console_write_nolock>
}
    dbb6:	e002      	b.n	dbbe <handle_ansi+0x156>
        handle_home(line);
    dbb8:	4608      	mov	r0, r1
    dbba:	f7ff fee9 	bl	d990 <handle_home>
    esc_state &= ~ESC_ANSI;
    dbbe:	4a09      	ldr	r2, [pc, #36]	; (dbe4 <handle_ansi+0x17c>)
    dbc0:	6813      	ldr	r3, [r2, #0]
    dbc2:	f023 0302 	bic.w	r3, r3, #2
    dbc6:	6013      	str	r3, [r2, #0]
}
    dbc8:	b004      	add	sp, #16
    dbca:	bd10      	pop	{r4, pc}
        handle_end(line);
    dbcc:	4608      	mov	r0, r1
    dbce:	f7ff feb7 	bl	d940 <handle_end>
        break;
    dbd2:	e7f4      	b.n	dbbe <handle_ansi+0x156>
            handle_delete(line);
    dbd4:	4608      	mov	r0, r1
    dbd6:	f7ff ff37 	bl	da48 <handle_delete>
            break;
    dbda:	e7f0      	b.n	dbbe <handle_ansi+0x156>
            handle_end(line);
    dbdc:	4608      	mov	r0, r1
    dbde:	f7ff feaf 	bl	d940 <handle_end>
            break;
    dbe2:	e7ec      	b.n	dbbe <handle_ansi+0x156>
    dbe4:	200021b8 	.word	0x200021b8
    dbe8:	20002180 	.word	0x20002180
    dbec:	20002184 	.word	0x20002184
    dbf0:	200021b0 	.word	0x200021b0
    dbf4:	200021ca 	.word	0x200021ca

0000dbf8 <handle_backspace>:

static void
handle_backspace(char *line)
{
    if (cur > 0) {
    dbf8:	4b13      	ldr	r3, [pc, #76]	; (dc48 <handle_backspace+0x50>)
    dbfa:	881b      	ldrh	r3, [r3, #0]
    dbfc:	b903      	cbnz	r3, dc00 <handle_backspace+0x8>
    dbfe:	4770      	bx	lr
{
    dc00:	b530      	push	{r4, r5, lr}
    dc02:	b085      	sub	sp, #20
    dc04:	4604      	mov	r4, r0
    char seq[14] = CSI;
    dc06:	f645 331b 	movw	r3, #23323	; 0x5b1b
    dc0a:	9300      	str	r3, [sp, #0]
    dc0c:	2300      	movs	r3, #0
    dc0e:	9301      	str	r3, [sp, #4]
    dc10:	9302      	str	r3, [sp, #8]
    dc12:	f8ad 300c 	strh.w	r3, [sp, #12]
        p = add_ascii_num_with_char(seq + 2, count, 'D');
    dc16:	466d      	mov	r5, sp
    dc18:	2244      	movs	r2, #68	; 0x44
    dc1a:	2101      	movs	r1, #1
    dc1c:	f10d 0002 	add.w	r0, sp, #2
    dc20:	f7ff fdea 	bl	d7f8 <add_ascii_num_with_char>
        console_write_nolock(seq, p - seq);
    dc24:	1b41      	subs	r1, r0, r5
    dc26:	4628      	mov	r0, r5
    dc28:	f7ff fe7a 	bl	d920 <console_write_nolock>
        cursor_backward(1);
        cur--;
    dc2c:	4a06      	ldr	r2, [pc, #24]	; (dc48 <handle_backspace+0x50>)
    dc2e:	8813      	ldrh	r3, [r2, #0]
    dc30:	3b01      	subs	r3, #1
    dc32:	b29b      	uxth	r3, r3
    dc34:	8013      	strh	r3, [r2, #0]
        trailing_chars++;
    dc36:	4905      	ldr	r1, [pc, #20]	; (dc4c <handle_backspace+0x54>)
    dc38:	880a      	ldrh	r2, [r1, #0]
    dc3a:	3201      	adds	r2, #1
    dc3c:	800a      	strh	r2, [r1, #0]
        del_char(&line[cur]);
    dc3e:	18e0      	adds	r0, r4, r3
    dc40:	f7ff fece 	bl	d9e0 <del_char>
    }
}
    dc44:	b005      	add	sp, #20
    dc46:	bd30      	pop	{r4, r5, pc}
    dc48:	200021b0 	.word	0x200021b0
    dc4c:	200021ca 	.word	0x200021ca

0000dc50 <console_clear_line>:
{
    dc50:	b510      	push	{r4, lr}
    dc52:	b084      	sub	sp, #16
    if (cur) {
    dc54:	4b13      	ldr	r3, [pc, #76]	; (dca4 <console_clear_line+0x54>)
    dc56:	8819      	ldrh	r1, [r3, #0]
    dc58:	b979      	cbnz	r1, dc7a <console_clear_line+0x2a>
    cur = 0;
    dc5a:	2300      	movs	r3, #0
    dc5c:	4a11      	ldr	r2, [pc, #68]	; (dca4 <console_clear_line+0x54>)
    dc5e:	8013      	strh	r3, [r2, #0]
    trailing_chars = 0;
    dc60:	4a11      	ldr	r2, [pc, #68]	; (dca8 <console_clear_line+0x58>)
    dc62:	8013      	strh	r3, [r2, #0]
    console_out_nolock(ESC);
    dc64:	201b      	movs	r0, #27
    dc66:	f000 fb97 	bl	e398 <console_out_nolock>
    console_out_nolock('[');
    dc6a:	205b      	movs	r0, #91	; 0x5b
    dc6c:	f000 fb94 	bl	e398 <console_out_nolock>
    console_out_nolock('K');
    dc70:	204b      	movs	r0, #75	; 0x4b
    dc72:	f000 fb91 	bl	e398 <console_out_nolock>
}
    dc76:	b004      	add	sp, #16
    dc78:	bd10      	pop	{r4, pc}
    char seq[14] = CSI;
    dc7a:	f645 331b 	movw	r3, #23323	; 0x5b1b
    dc7e:	9300      	str	r3, [sp, #0]
    dc80:	2300      	movs	r3, #0
    dc82:	9301      	str	r3, [sp, #4]
    dc84:	9302      	str	r3, [sp, #8]
    dc86:	f8ad 300c 	strh.w	r3, [sp, #12]
    if (count) {
    dc8a:	2900      	cmp	r1, #0
    dc8c:	d0e5      	beq.n	dc5a <console_clear_line+0xa>
        p = add_ascii_num_with_char(seq + 2, count, 'D');
    dc8e:	466c      	mov	r4, sp
    dc90:	2244      	movs	r2, #68	; 0x44
    dc92:	f10d 0002 	add.w	r0, sp, #2
    dc96:	f7ff fdaf 	bl	d7f8 <add_ascii_num_with_char>
        console_write_nolock(seq, p - seq);
    dc9a:	1b01      	subs	r1, r0, r4
    dc9c:	4620      	mov	r0, r4
    dc9e:	f7ff fe3f 	bl	d920 <console_write_nolock>
}
    dca2:	e7da      	b.n	dc5a <console_clear_line+0xa>
    dca4:	200021b0 	.word	0x200021b0
    dca8:	200021ca 	.word	0x200021ca

0000dcac <insert_char>:
        cur + trailing_chars >= MYNEWT_VAL(CONSOLE_MAX_INPUT_LEN) - 1) {
    dcac:	4b26      	ldr	r3, [pc, #152]	; (dd48 <insert_char+0x9c>)
    dcae:	881b      	ldrh	r3, [r3, #0]
    dcb0:	4a26      	ldr	r2, [pc, #152]	; (dd4c <insert_char+0xa0>)
    dcb2:	8812      	ldrh	r2, [r2, #0]
    dcb4:	4413      	add	r3, r2
    if ((!MYNEWT_VAL(CONSOLE_HISTORY_AUTO_SEARCH) || !trailing_selection) &&
    dcb6:	2bfe      	cmp	r3, #254	; 0xfe
    dcb8:	dc44      	bgt.n	dd44 <insert_char+0x98>
{
    dcba:	b570      	push	{r4, r5, r6, lr}
    dcbc:	b084      	sub	sp, #16
    dcbe:	4604      	mov	r4, r0
    dcc0:	460e      	mov	r6, r1
    if (echo) {
    dcc2:	4b23      	ldr	r3, [pc, #140]	; (dd50 <insert_char+0xa4>)
    dcc4:	681b      	ldr	r3, [r3, #0]
    dcc6:	b95b      	cbnz	r3, dce0 <insert_char+0x34>
    ++cur;
    dcc8:	4a1f      	ldr	r2, [pc, #124]	; (dd48 <insert_char+0x9c>)
    dcca:	8813      	ldrh	r3, [r2, #0]
    dccc:	3301      	adds	r3, #1
    dcce:	8013      	strh	r3, [r2, #0]
    if (trailing_chars == 0) {
    dcd0:	4b1e      	ldr	r3, [pc, #120]	; (dd4c <insert_char+0xa0>)
    dcd2:	881b      	ldrh	r3, [r3, #0]
    dcd4:	b903      	cbnz	r3, dcd8 <insert_char+0x2c>
        *pos = c;
    dcd6:	7026      	strb	r6, [r4, #0]
    tmp = *pos;
    dcd8:	7825      	ldrb	r5, [r4, #0]
    *(pos++) = c;
    dcda:	f804 6b01 	strb.w	r6, [r4], #1
    while (end-- > 0) {
    dcde:	e00d      	b.n	dcfc <insert_char+0x50>
        console_out_nolock(c);
    dce0:	4608      	mov	r0, r1
    dce2:	f000 fb59 	bl	e398 <console_out_nolock>
    dce6:	e7ef      	b.n	dcc8 <insert_char+0x1c>
            console_out_nolock(tmp);
    dce8:	4628      	mov	r0, r5
    dcea:	f000 fb55 	bl	e398 <console_out_nolock>
        c = *pos;
    dcee:	7822      	ldrb	r2, [r4, #0]
        *(pos++) = tmp;
    dcf0:	4620      	mov	r0, r4
    dcf2:	f800 5b01 	strb.w	r5, [r0], #1
    while (end-- > 0) {
    dcf6:	4633      	mov	r3, r6
        tmp = c;
    dcf8:	4615      	mov	r5, r2
        *(pos++) = tmp;
    dcfa:	4604      	mov	r4, r0
    while (end-- > 0) {
    dcfc:	1e5e      	subs	r6, r3, #1
    dcfe:	2b00      	cmp	r3, #0
    dd00:	dd04      	ble.n	dd0c <insert_char+0x60>
        if (echo) {
    dd02:	4b13      	ldr	r3, [pc, #76]	; (dd50 <insert_char+0xa4>)
    dd04:	681b      	ldr	r3, [r3, #0]
    dd06:	2b00      	cmp	r3, #0
    dd08:	d0f1      	beq.n	dcee <insert_char+0x42>
    dd0a:	e7ed      	b.n	dce8 <insert_char+0x3c>
    if (echo) {
    dd0c:	4b10      	ldr	r3, [pc, #64]	; (dd50 <insert_char+0xa4>)
    dd0e:	681b      	ldr	r3, [r3, #0]
    dd10:	b90b      	cbnz	r3, dd16 <insert_char+0x6a>
}
    dd12:	b004      	add	sp, #16
    dd14:	bd70      	pop	{r4, r5, r6, pc}
        cursor_backward(trailing_chars);
    dd16:	4b0d      	ldr	r3, [pc, #52]	; (dd4c <insert_char+0xa0>)
    dd18:	8819      	ldrh	r1, [r3, #0]
    char seq[14] = CSI;
    dd1a:	f645 331b 	movw	r3, #23323	; 0x5b1b
    dd1e:	9300      	str	r3, [sp, #0]
    dd20:	2300      	movs	r3, #0
    dd22:	9301      	str	r3, [sp, #4]
    dd24:	9302      	str	r3, [sp, #8]
    dd26:	f8ad 300c 	strh.w	r3, [sp, #12]
    if (count) {
    dd2a:	2900      	cmp	r1, #0
    dd2c:	d0f1      	beq.n	dd12 <insert_char+0x66>
        p = add_ascii_num_with_char(seq + 2, count, 'D');
    dd2e:	466c      	mov	r4, sp
    dd30:	2244      	movs	r2, #68	; 0x44
    dd32:	f10d 0002 	add.w	r0, sp, #2
    dd36:	f7ff fd5f 	bl	d7f8 <add_ascii_num_with_char>
        console_write_nolock(seq, p - seq);
    dd3a:	1b01      	subs	r1, r0, r4
    dd3c:	4620      	mov	r0, r4
    dd3e:	f7ff fdef 	bl	d920 <console_write_nolock>
}
    dd42:	e7e6      	b.n	dd12 <insert_char+0x66>
    dd44:	4770      	bx	lr
    dd46:	bf00      	nop
    dd48:	200021b0 	.word	0x200021b0
    dd4c:	200021ca 	.word	0x200021ca
    dd50:	2000011c 	.word	0x2000011c

0000dd54 <console_echo>:
    echo = on;
    dd54:	4b01      	ldr	r3, [pc, #4]	; (dd5c <console_echo+0x8>)
    dd56:	6018      	str	r0, [r3, #0]
}
    dd58:	4770      	bx	lr
    dd5a:	bf00      	nop
    dd5c:	2000011c 	.word	0x2000011c

0000dd60 <console_nlip_enable_echo>:
{
    dd60:	b508      	push	{r3, lr}
    console_echo(1);
    dd62:	2001      	movs	r0, #1
    dd64:	f7ff fff6 	bl	dd54 <console_echo>
}
    dd68:	bd08      	pop	{r3, pc}

0000dd6a <console_nlip_disable_echo>:
{
    dd6a:	b508      	push	{r3, lr}
    console_echo(0);
    dd6c:	2000      	movs	r0, #0
    dd6e:	f7ff fff1 	bl	dd54 <console_echo>
}
    dd72:	bd08      	pop	{r3, pc}

0000dd74 <handle_nlip>:
{
    dd74:	b570      	push	{r4, r5, r6, lr}
    dd76:	4604      	mov	r4, r0
    input = current_line_ev->ev_arg;
    dd78:	4b3b      	ldr	r3, [pc, #236]	; (de68 <handle_nlip+0xf4>)
    dd7a:	681b      	ldr	r3, [r3, #0]
    dd7c:	689d      	ldr	r5, [r3, #8]
    switch (nlip_state) {
    dd7e:	4b3b      	ldr	r3, [pc, #236]	; (de6c <handle_nlip+0xf8>)
    dd80:	681b      	ldr	r3, [r3, #0]
    dd82:	3b04      	subs	r3, #4
    dd84:	2b10      	cmp	r3, #16
    dd86:	d852      	bhi.n	de2e <handle_nlip+0xba>
    dd88:	e8df f003 	tbb	[pc, r3]
    dd8c:	511f5138 	.word	0x511f5138
    dd90:	51510951 	.word	0x51510951
    dd94:	51515151 	.word	0x51515151
    dd98:	51515151 	.word	0x51515151
    dd9c:	09          	.byte	0x09
    dd9d:	00          	.byte	0x00
        insert_char(&input->line[cur], byte);
    dd9e:	4b34      	ldr	r3, [pc, #208]	; (de70 <handle_nlip+0xfc>)
    dda0:	8818      	ldrh	r0, [r3, #0]
    dda2:	4621      	mov	r1, r4
    dda4:	4428      	add	r0, r5
    dda6:	f7ff ff81 	bl	dcac <insert_char>
        if (byte == '\n') {
    ddaa:	2c0a      	cmp	r4, #10
    ddac:	d001      	beq.n	ddb2 <handle_nlip+0x3e>
    handled = 1;
    ddae:	2001      	movs	r0, #1
}
    ddb0:	bd70      	pop	{r4, r5, r6, pc}
            input->line[cur] = '\0';
    ddb2:	4b2f      	ldr	r3, [pc, #188]	; (de70 <handle_nlip+0xfc>)
    ddb4:	881b      	ldrh	r3, [r3, #0]
    ddb6:	2400      	movs	r4, #0
    ddb8:	54ec      	strb	r4, [r5, r3]
            console_nlip_enable_echo();
    ddba:	f7ff ffd1 	bl	dd60 <console_nlip_enable_echo>
            nlip_state = 0;
    ddbe:	4b2b      	ldr	r3, [pc, #172]	; (de6c <handle_nlip+0xf8>)
    ddc0:	601c      	str	r4, [r3, #0]
            console_handle_line();
    ddc2:	f7ff fd3f 	bl	d844 <console_handle_line>
    handled = 1;
    ddc6:	2001      	movs	r0, #1
    ddc8:	e7f2      	b.n	ddb0 <handle_nlip+0x3c>
        if (byte == CONSOLE_NLIP_PKT_START2) {
    ddca:	2809      	cmp	r0, #9
    ddcc:	d005      	beq.n	ddda <handle_nlip+0x66>
            nlip_state = 0;
    ddce:	4b27      	ldr	r3, [pc, #156]	; (de6c <handle_nlip+0xf8>)
    ddd0:	2200      	movs	r2, #0
    ddd2:	601a      	str	r2, [r3, #0]
            handled = g_console_ignore_non_nlip;
    ddd4:	4b27      	ldr	r3, [pc, #156]	; (de74 <handle_nlip+0x100>)
    ddd6:	7818      	ldrb	r0, [r3, #0]
    ddd8:	e7ea      	b.n	ddb0 <handle_nlip+0x3c>
            nlip_state = NLIP_PKT_START2;
    ddda:	4b24      	ldr	r3, [pc, #144]	; (de6c <handle_nlip+0xf8>)
    dddc:	6018      	str	r0, [r3, #0]
            console_nlip_disable_echo();
    ddde:	f7ff ffc4 	bl	dd6a <console_nlip_disable_echo>
            insert_char(&input->line[cur], CONSOLE_NLIP_PKT_START1);
    dde2:	4e23      	ldr	r6, [pc, #140]	; (de70 <handle_nlip+0xfc>)
    dde4:	8830      	ldrh	r0, [r6, #0]
    dde6:	2106      	movs	r1, #6
    dde8:	4428      	add	r0, r5
    ddea:	f7ff ff5f 	bl	dcac <insert_char>
            insert_char(&input->line[cur], CONSOLE_NLIP_PKT_START2);
    ddee:	8830      	ldrh	r0, [r6, #0]
    ddf0:	4621      	mov	r1, r4
    ddf2:	4428      	add	r0, r5
    ddf4:	f7ff ff5a 	bl	dcac <insert_char>
    handled = 1;
    ddf8:	2001      	movs	r0, #1
    ddfa:	e7d9      	b.n	ddb0 <handle_nlip+0x3c>
        if (byte == CONSOLE_NLIP_DATA_START2) {
    ddfc:	2814      	cmp	r0, #20
    ddfe:	d005      	beq.n	de0c <handle_nlip+0x98>
            nlip_state = 0;
    de00:	4b1a      	ldr	r3, [pc, #104]	; (de6c <handle_nlip+0xf8>)
    de02:	2200      	movs	r2, #0
    de04:	601a      	str	r2, [r3, #0]
            handled = g_console_ignore_non_nlip;
    de06:	4b1b      	ldr	r3, [pc, #108]	; (de74 <handle_nlip+0x100>)
    de08:	7818      	ldrb	r0, [r3, #0]
    de0a:	e7d1      	b.n	ddb0 <handle_nlip+0x3c>
            nlip_state = NLIP_DATA_START2;
    de0c:	4b17      	ldr	r3, [pc, #92]	; (de6c <handle_nlip+0xf8>)
    de0e:	6018      	str	r0, [r3, #0]
            console_nlip_disable_echo();
    de10:	f7ff ffab 	bl	dd6a <console_nlip_disable_echo>
            insert_char(&input->line[cur], CONSOLE_NLIP_DATA_START1);
    de14:	4e16      	ldr	r6, [pc, #88]	; (de70 <handle_nlip+0xfc>)
    de16:	8830      	ldrh	r0, [r6, #0]
    de18:	2104      	movs	r1, #4
    de1a:	4428      	add	r0, r5
    de1c:	f7ff ff46 	bl	dcac <insert_char>
            insert_char(&input->line[cur], CONSOLE_NLIP_DATA_START2);
    de20:	8830      	ldrh	r0, [r6, #0]
    de22:	4621      	mov	r1, r4
    de24:	4428      	add	r0, r5
    de26:	f7ff ff41 	bl	dcac <insert_char>
    handled = 1;
    de2a:	2001      	movs	r0, #1
    de2c:	e7c0      	b.n	ddb0 <handle_nlip+0x3c>
        if (byte == CONSOLE_NLIP_DATA_START1) {
    de2e:	2804      	cmp	r0, #4
    de30:	d00a      	beq.n	de48 <handle_nlip+0xd4>
        } else if (byte == CONSOLE_NLIP_PKT_START1) {
    de32:	2806      	cmp	r0, #6
    de34:	d00d      	beq.n	de52 <handle_nlip+0xde>
            handled = g_console_ignore_non_nlip && byte != '\r' && byte != '\n';
    de36:	4b0f      	ldr	r3, [pc, #60]	; (de74 <handle_nlip+0x100>)
    de38:	781b      	ldrb	r3, [r3, #0]
    de3a:	b18b      	cbz	r3, de60 <handle_nlip+0xec>
    de3c:	280d      	cmp	r0, #13
    de3e:	d011      	beq.n	de64 <handle_nlip+0xf0>
    de40:	280a      	cmp	r0, #10
    de42:	d00b      	beq.n	de5c <handle_nlip+0xe8>
    de44:	2001      	movs	r0, #1
    return handled;
    de46:	e7b3      	b.n	ddb0 <handle_nlip+0x3c>
            nlip_state = NLIP_DATA_START1;
    de48:	4b08      	ldr	r3, [pc, #32]	; (de6c <handle_nlip+0xf8>)
    de4a:	2204      	movs	r2, #4
    de4c:	601a      	str	r2, [r3, #0]
    handled = 1;
    de4e:	2001      	movs	r0, #1
    de50:	e7ae      	b.n	ddb0 <handle_nlip+0x3c>
            nlip_state = NLIP_PKT_START1;
    de52:	4b06      	ldr	r3, [pc, #24]	; (de6c <handle_nlip+0xf8>)
    de54:	2206      	movs	r2, #6
    de56:	601a      	str	r2, [r3, #0]
    handled = 1;
    de58:	2001      	movs	r0, #1
    de5a:	e7a9      	b.n	ddb0 <handle_nlip+0x3c>
            handled = g_console_ignore_non_nlip && byte != '\r' && byte != '\n';
    de5c:	2000      	movs	r0, #0
    de5e:	e7a7      	b.n	ddb0 <handle_nlip+0x3c>
    de60:	2000      	movs	r0, #0
    de62:	e7a5      	b.n	ddb0 <handle_nlip+0x3c>
    de64:	2000      	movs	r0, #0
    de66:	e7a3      	b.n	ddb0 <handle_nlip+0x3c>
    de68:	200021b4 	.word	0x200021b4
    de6c:	200021c4 	.word	0x200021c4
    de70:	200021b0 	.word	0x200021b0
    de74:	200021bc 	.word	0x200021bc

0000de78 <console_lock>:
{
    de78:	b508      	push	{r3, lr}
#endif

static inline int
os_arch_in_isr(void)
{
    return (SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk) != 0;
    de7a:	4b0a      	ldr	r3, [pc, #40]	; (dea4 <console_lock+0x2c>)
    de7c:	685b      	ldr	r3, [r3, #4]
    de7e:	f3c3 0308 	ubfx	r3, r3, #0, #9
    if (os_arch_in_isr()) {
    de82:	b133      	cbz	r3, de92 <console_lock+0x1a>
 *
 * @return number of times lock was called from current task
 */
static inline uint16_t os_mutex_get_level(struct os_mutex *mu)
{
    return mu->mu_level;
    de84:	4b08      	ldr	r3, [pc, #32]	; (dea8 <console_lock+0x30>)
    de86:	88db      	ldrh	r3, [r3, #6]
        if (os_mutex_get_level(&console_write_lock)) {
    de88:	b90b      	cbnz	r3, de8e <console_lock+0x16>
    int rc = OS_OK;
    de8a:	2000      	movs	r0, #0
    de8c:	e007      	b.n	de9e <console_lock+0x26>
            rc = OS_EBUSY;
    de8e:	200b      	movs	r0, #11
        goto end;
    de90:	e005      	b.n	de9e <console_lock+0x26>
    rc = os_mutex_pend(&console_write_lock, timeout);
    de92:	4601      	mov	r1, r0
    de94:	4804      	ldr	r0, [pc, #16]	; (dea8 <console_lock+0x30>)
    de96:	f7fe ffb5 	bl	ce04 <os_mutex_pend>
    if (rc == OS_NOT_STARTED) {
    de9a:	2809      	cmp	r0, #9
    de9c:	d000      	beq.n	dea0 <console_lock+0x28>
}
    de9e:	bd08      	pop	{r3, pc}
        rc = OS_OK;
    dea0:	2000      	movs	r0, #0
    return rc;
    dea2:	e7fc      	b.n	de9e <console_lock+0x26>
    dea4:	e000ed00 	.word	0xe000ed00
    dea8:	200021a4 	.word	0x200021a4

0000deac <console_unlock>:
{
    deac:	b508      	push	{r3, lr}
    deae:	4b0c      	ldr	r3, [pc, #48]	; (dee0 <console_unlock+0x34>)
    deb0:	685b      	ldr	r3, [r3, #4]
    deb2:	f3c3 0308 	ubfx	r3, r3, #0, #9
    if (os_arch_in_isr()) {
    deb6:	b10b      	cbz	r3, debc <console_unlock+0x10>
    int rc = OS_OK;
    deb8:	2000      	movs	r0, #0
}
    deba:	bd08      	pop	{r3, pc}
    rc = os_mutex_release(&console_write_lock);
    debc:	4809      	ldr	r0, [pc, #36]	; (dee4 <console_unlock+0x38>)
    debe:	f7fe ff41 	bl	cd44 <os_mutex_release>
    assert(rc == OS_OK || rc == OS_NOT_STARTED);
    dec2:	2800      	cmp	r0, #0
    dec4:	d0f9      	beq.n	deba <console_unlock+0xe>
    dec6:	2809      	cmp	r0, #9
    dec8:	d0f7      	beq.n	deba <console_unlock+0xe>
    deca:	f7fe f967 	bl	c19c <hal_debugger_connected>
    dece:	b100      	cbz	r0, ded2 <console_unlock+0x26>
    ded0:	be01      	bkpt	0x0001
    ded2:	2300      	movs	r3, #0
    ded4:	461a      	mov	r2, r3
    ded6:	4619      	mov	r1, r3
    ded8:	4618      	mov	r0, r3
    deda:	f7fe fb3d 	bl	c558 <__assert_func>
    dede:	bf00      	nop
    dee0:	e000ed00 	.word	0xe000ed00
    dee4:	200021a4 	.word	0x200021a4

0000dee8 <console_write>:
{
    dee8:	b538      	push	{r3, r4, r5, lr}
    deea:	4605      	mov	r5, r0
    deec:	460c      	mov	r4, r1
    if (console_lock(timeout) != OS_OK) {
    deee:	2080      	movs	r0, #128	; 0x80
    def0:	f7ff ffc2 	bl	de78 <console_lock>
    def4:	b9e0      	cbnz	r0, df30 <console_write+0x48>
    if (cnt >= 2 && str[0] == CONSOLE_NLIP_DATA_START1 &&
    def6:	2c01      	cmp	r4, #1
    def8:	dd02      	ble.n	df00 <console_write+0x18>
    defa:	782b      	ldrb	r3, [r5, #0]
    defc:	2b04      	cmp	r3, #4
    defe:	d018      	beq.n	df32 <console_write+0x4a>
    if (cnt >= 3 && str[1] == CONSOLE_NLIP_PKT_START1 &&
    df00:	2c02      	cmp	r4, #2
    df02:	dd02      	ble.n	df0a <console_write+0x22>
    df04:	786b      	ldrb	r3, [r5, #1]
    df06:	2b06      	cmp	r3, #6
    df08:	d01a      	beq.n	df40 <console_write+0x58>
    if (!g_is_output_nlip && g_console_silence_non_nlip) {
    df0a:	4b13      	ldr	r3, [pc, #76]	; (df58 <console_write+0x70>)
    df0c:	781b      	ldrb	r3, [r3, #0]
    df0e:	b913      	cbnz	r3, df16 <console_write+0x2e>
    df10:	4b12      	ldr	r3, [pc, #72]	; (df5c <console_write+0x74>)
    df12:	781b      	ldrb	r3, [r3, #0]
    df14:	b91b      	cbnz	r3, df1e <console_write+0x36>
    console_filter_write(str, cnt);
    df16:	4621      	mov	r1, r4
    df18:	4628      	mov	r0, r5
    df1a:	f7ff fccf 	bl	d8bc <console_filter_write>
    if (cnt > 0 && str[cnt - 1] == '\n') {
    df1e:	2c00      	cmp	r4, #0
    df20:	dd04      	ble.n	df2c <console_write+0x44>
    df22:	1928      	adds	r0, r5, r4
    df24:	f810 3c01 	ldrb.w	r3, [r0, #-1]
    df28:	2b0a      	cmp	r3, #10
    df2a:	d010      	beq.n	df4e <console_write+0x66>
    (void)console_unlock();
    df2c:	f7ff ffbe 	bl	deac <console_unlock>
}
    df30:	bd38      	pop	{r3, r4, r5, pc}
        str[1] == CONSOLE_NLIP_DATA_START2) {
    df32:	786b      	ldrb	r3, [r5, #1]
    if (cnt >= 2 && str[0] == CONSOLE_NLIP_DATA_START1 &&
    df34:	2b14      	cmp	r3, #20
    df36:	d1e3      	bne.n	df00 <console_write+0x18>
        g_is_output_nlip = 1;
    df38:	4b07      	ldr	r3, [pc, #28]	; (df58 <console_write+0x70>)
    df3a:	2201      	movs	r2, #1
    df3c:	701a      	strb	r2, [r3, #0]
    df3e:	e7df      	b.n	df00 <console_write+0x18>
        str[2] == CONSOLE_NLIP_PKT_START2) {
    df40:	78ab      	ldrb	r3, [r5, #2]
    if (cnt >= 3 && str[1] == CONSOLE_NLIP_PKT_START1 &&
    df42:	2b09      	cmp	r3, #9
    df44:	d1e1      	bne.n	df0a <console_write+0x22>
        g_is_output_nlip = 1;
    df46:	4b04      	ldr	r3, [pc, #16]	; (df58 <console_write+0x70>)
    df48:	2201      	movs	r2, #1
    df4a:	701a      	strb	r2, [r3, #0]
    df4c:	e7dd      	b.n	df0a <console_write+0x22>
        g_is_output_nlip = 0;
    df4e:	4b02      	ldr	r3, [pc, #8]	; (df58 <console_write+0x70>)
    df50:	2200      	movs	r2, #0
    df52:	701a      	strb	r2, [r3, #0]
    df54:	e7ea      	b.n	df2c <console_write+0x44>
    df56:	bf00      	nop
    df58:	200021bf 	.word	0x200021bf
    df5c:	200021be 	.word	0x200021be

0000df60 <console_blocking_mode>:
{
    df60:	b508      	push	{r3, lr}
    uart_console_blocking_mode();
    df62:	f000 fa03 	bl	e36c <uart_console_blocking_mode>
}
    df66:	bd08      	pop	{r3, pc}

0000df68 <console_handle_char>:

int
console_handle_char(uint8_t byte)
{
    df68:	b570      	push	{r4, r5, r6, lr}
    return 0;
#endif
    struct console_input *input;
    static char prev_endl = '\0';

    if (!lines_queue) {
    df6a:	4b57      	ldr	r3, [pc, #348]	; (e0c8 <console_handle_char+0x160>)
    df6c:	681b      	ldr	r3, [r3, #0]
    df6e:	2b00      	cmp	r3, #0
    df70:	f000 80a5 	beq.w	e0be <console_handle_char+0x156>
    df74:	4604      	mov	r4, r0
        return 0;
    }

    if (!current_line_ev) {
    df76:	4b55      	ldr	r3, [pc, #340]	; (e0cc <console_handle_char+0x164>)
    df78:	681b      	ldr	r3, [r3, #0]
    df7a:	b14b      	cbz	r3, df90 <console_handle_char+0x28>
        if (!current_line_ev) {
            rx_stalled = true;
            return -1;
        }
    }
    input = current_line_ev->ev_arg;
    df7c:	4b53      	ldr	r3, [pc, #332]	; (e0cc <console_handle_char+0x164>)
    df7e:	681b      	ldr	r3, [r3, #0]
    df80:	689e      	ldr	r6, [r3, #8]

    if (handle_nlip(byte)) {
    df82:	4620      	mov	r0, r4
    df84:	f7ff fef6 	bl	dd74 <handle_nlip>
    df88:	b178      	cbz	r0, dfaa <console_handle_char+0x42>
        return 0;
    df8a:	2500      	movs	r5, #0
    }
unlock:
    (void)console_unlock();

    return 0;
}
    df8c:	4628      	mov	r0, r5
    df8e:	bd70      	pop	{r4, r5, r6, pc}
        current_line_ev = os_eventq_get_no_wait(&avail_queue);
    df90:	484f      	ldr	r0, [pc, #316]	; (e0d0 <console_handle_char+0x168>)
    df92:	f7fe fde0 	bl	cb56 <os_eventq_get_no_wait>
    df96:	4b4d      	ldr	r3, [pc, #308]	; (e0cc <console_handle_char+0x164>)
    df98:	6018      	str	r0, [r3, #0]
        if (!current_line_ev) {
    df9a:	2800      	cmp	r0, #0
    df9c:	d1ee      	bne.n	df7c <console_handle_char+0x14>
            rx_stalled = true;
    df9e:	4b4d      	ldr	r3, [pc, #308]	; (e0d4 <console_handle_char+0x16c>)
    dfa0:	2201      	movs	r2, #1
    dfa2:	701a      	strb	r2, [r3, #0]
            return -1;
    dfa4:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    dfa8:	e7f0      	b.n	df8c <console_handle_char+0x24>
    if (console_lock(1000)) {
    dfaa:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    dfae:	f7ff ff63 	bl	de78 <console_lock>
    dfb2:	4605      	mov	r5, r0
    dfb4:	2800      	cmp	r0, #0
    dfb6:	f040 8084 	bne.w	e0c2 <console_handle_char+0x15a>
    if (esc_state & ESC_ANSI) {
    dfba:	4b47      	ldr	r3, [pc, #284]	; (e0d8 <console_handle_char+0x170>)
    dfbc:	681b      	ldr	r3, [r3, #0]
    dfbe:	f013 0f02 	tst.w	r3, #2
    dfc2:	d120      	bne.n	e006 <console_handle_char+0x9e>
    if (esc_state & ESC_ESC) {
    dfc4:	f013 0f01 	tst.w	r3, #1
    dfc8:	d122      	bne.n	e010 <console_handle_char+0xa8>
	    (__c >= '{' && __c <= '~');
}

__extern_inline int isprint(int __c)
{
	return (__c >= 0x20 && __c <= 0x7e);
    dfca:	f1a4 0320 	sub.w	r3, r4, #32
    if (!isprint(byte)) {
    dfce:	2b5e      	cmp	r3, #94	; 0x5e
    dfd0:	d96c      	bls.n	e0ac <console_handle_char+0x144>
        handle_ansi(byte, input->line);
    dfd2:	4631      	mov	r1, r6
    dfd4:	4620      	mov	r0, r4
    dfd6:	f7ff fd47 	bl	da68 <handle_ansi>
        switch (byte) {
    dfda:	2c1b      	cmp	r4, #27
    dfdc:	d828      	bhi.n	e030 <console_handle_char+0xc8>
    dfde:	2c03      	cmp	r4, #3
    dfe0:	d332      	bcc.n	e048 <console_handle_char+0xe0>
    dfe2:	1ee3      	subs	r3, r4, #3
    dfe4:	2b18      	cmp	r3, #24
    dfe6:	d82f      	bhi.n	e048 <console_handle_char+0xe0>
    dfe8:	e8df f003 	tbb	[pc, r3]
    dfec:	2e2e2e59 	.word	0x2e2e2e59
    dff0:	344f242e 	.word	0x344f242e
    dff4:	2e345c2e 	.word	0x2e345c2e
    dff8:	2e2e2e2e 	.word	0x2e2e2e2e
    dffc:	2e2e2e2e 	.word	0x2e2e2e2e
    e000:	2e2e2e2e 	.word	0x2e2e2e2e
    e004:	28          	.byte	0x28
    e005:	00          	.byte	0x00
        handle_ansi(byte, input->line);
    e006:	4631      	mov	r1, r6
    e008:	4620      	mov	r0, r4
    e00a:	f7ff fd2d 	bl	da68 <handle_ansi>
        goto unlock;
    e00e:	e053      	b.n	e0b8 <console_handle_char+0x150>
        esc_state &= ~ESC_ESC;
    e010:	f023 0301 	bic.w	r3, r3, #1
    e014:	4a30      	ldr	r2, [pc, #192]	; (e0d8 <console_handle_char+0x170>)
    e016:	6013      	str	r3, [r2, #0]
        handle_ansi(byte, input->line);
    e018:	4631      	mov	r1, r6
    e01a:	4620      	mov	r0, r4
    e01c:	f7ff fd24 	bl	da68 <handle_ansi>
        switch (byte) {
    e020:	2c5b      	cmp	r4, #91	; 0x5b
    e022:	d149      	bne.n	e0b8 <console_handle_char+0x150>
            esc_state |= ESC_ANSI;
    e024:	4a2c      	ldr	r2, [pc, #176]	; (e0d8 <console_handle_char+0x170>)
    e026:	6813      	ldr	r3, [r2, #0]
            esc_state |= ESC_ANSI_FIRST;
    e028:	f043 0306 	orr.w	r3, r3, #6
    e02c:	6013      	str	r3, [r2, #0]
        goto unlock;
    e02e:	e043      	b.n	e0b8 <console_handle_char+0x150>
        switch (byte) {
    e030:	2c7f      	cmp	r4, #127	; 0x7f
    e032:	d109      	bne.n	e048 <console_handle_char+0xe0>
            handle_backspace(input->line);
    e034:	4630      	mov	r0, r6
    e036:	f7ff fddf 	bl	dbf8 <handle_backspace>
            break;
    e03a:	e03d      	b.n	e0b8 <console_handle_char+0x150>
            esc_state |= ESC_ESC;
    e03c:	4a26      	ldr	r2, [pc, #152]	; (e0d8 <console_handle_char+0x170>)
    e03e:	6813      	ldr	r3, [r2, #0]
    e040:	f043 0301 	orr.w	r3, r3, #1
    e044:	6013      	str	r3, [r2, #0]
            break;
    e046:	e037      	b.n	e0b8 <console_handle_char+0x150>
            insert_char(&input->line[cur], byte);
    e048:	4b24      	ldr	r3, [pc, #144]	; (e0dc <console_handle_char+0x174>)
    e04a:	8818      	ldrh	r0, [r3, #0]
    e04c:	4621      	mov	r1, r4
    e04e:	4430      	add	r0, r6
    e050:	f7ff fe2c 	bl	dcac <insert_char>
            if (byte == '\n' && prev_endl == '\r') {
    e054:	2c0a      	cmp	r4, #10
    e056:	d103      	bne.n	e060 <console_handle_char+0xf8>
    e058:	4b21      	ldr	r3, [pc, #132]	; (e0e0 <console_handle_char+0x178>)
    e05a:	781b      	ldrb	r3, [r3, #0]
    e05c:	2b0d      	cmp	r3, #13
    e05e:	d011      	beq.n	e084 <console_handle_char+0x11c>
            prev_endl = byte;
    e060:	4b1f      	ldr	r3, [pc, #124]	; (e0e0 <console_handle_char+0x178>)
    e062:	701c      	strb	r4, [r3, #0]
            input->line[cur + trailing_chars] = '\0';
    e064:	4b1d      	ldr	r3, [pc, #116]	; (e0dc <console_handle_char+0x174>)
    e066:	881b      	ldrh	r3, [r3, #0]
    e068:	4a1e      	ldr	r2, [pc, #120]	; (e0e4 <console_handle_char+0x17c>)
    e06a:	8812      	ldrh	r2, [r2, #0]
    e06c:	4413      	add	r3, r2
    e06e:	2200      	movs	r2, #0
    e070:	54f2      	strb	r2, [r6, r3]
                console_filter_out('\r');
    e072:	200d      	movs	r0, #13
    e074:	f7ff fc04 	bl	d880 <console_filter_out>
                console_filter_out('\n');
    e078:	200a      	movs	r0, #10
    e07a:	f7ff fc01 	bl	d880 <console_filter_out>
            console_handle_line();
    e07e:	f7ff fbe1 	bl	d844 <console_handle_line>
            break;
    e082:	e019      	b.n	e0b8 <console_handle_char+0x150>
                prev_endl = byte;
    e084:	4b16      	ldr	r3, [pc, #88]	; (e0e0 <console_handle_char+0x178>)
    e086:	701c      	strb	r4, [r3, #0]
                break;
    e088:	e016      	b.n	e0b8 <console_handle_char+0x150>
            if (completion && (!trailing_chars ||
    e08a:	4b17      	ldr	r3, [pc, #92]	; (e0e8 <console_handle_char+0x180>)
    e08c:	681b      	ldr	r3, [r3, #0]
    e08e:	b19b      	cbz	r3, e0b8 <console_handle_char+0x150>
    e090:	4a14      	ldr	r2, [pc, #80]	; (e0e4 <console_handle_char+0x17c>)
    e092:	8812      	ldrh	r2, [r2, #0]
    e094:	b982      	cbnz	r2, e0b8 <console_handle_char+0x150>
                completion(input->line, console_append_char);
    e096:	4915      	ldr	r1, [pc, #84]	; (e0ec <console_handle_char+0x184>)
    e098:	4630      	mov	r0, r6
    e09a:	4798      	blx	r3
                console_switch_to_prompt();
    e09c:	e00c      	b.n	e0b8 <console_handle_char+0x150>
            console_clear_line();
    e09e:	f7ff fdd7 	bl	dc50 <console_clear_line>
            break;
    e0a2:	e009      	b.n	e0b8 <console_handle_char+0x150>
                console_out_nolock(VT);
    e0a4:	200c      	movs	r0, #12
    e0a6:	f000 f977 	bl	e398 <console_out_nolock>
            break;
    e0aa:	e005      	b.n	e0b8 <console_handle_char+0x150>
        insert_char(&input->line[cur], byte);
    e0ac:	4b0b      	ldr	r3, [pc, #44]	; (e0dc <console_handle_char+0x174>)
    e0ae:	8818      	ldrh	r0, [r3, #0]
    e0b0:	4621      	mov	r1, r4
    e0b2:	4430      	add	r0, r6
    e0b4:	f7ff fdfa 	bl	dcac <insert_char>
    (void)console_unlock();
    e0b8:	f7ff fef8 	bl	deac <console_unlock>
    return 0;
    e0bc:	e766      	b.n	df8c <console_handle_char+0x24>
        return 0;
    e0be:	2500      	movs	r5, #0
    e0c0:	e764      	b.n	df8c <console_handle_char+0x24>
        return -1;
    e0c2:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    e0c6:	e761      	b.n	df8c <console_handle_char+0x24>
    e0c8:	200021c0 	.word	0x200021c0
    e0cc:	200021b4 	.word	0x200021b4
    e0d0:	20002188 	.word	0x20002188
    e0d4:	200021c9 	.word	0x200021c9
    e0d8:	200021b8 	.word	0x200021b8
    e0dc:	200021b0 	.word	0x200021b0
    e0e0:	200021c8 	.word	0x200021c8
    e0e4:	200021ca 	.word	0x200021ca
    e0e8:	20002198 	.word	0x20002198
    e0ec:	0000d8dd 	.word	0x0000d8dd

0000e0f0 <console_is_init>:

int
console_is_init(void)
{
    e0f0:	b508      	push	{r3, lr}
#if MYNEWT_VAL(CONSOLE_UART)
    return uart_console_is_init();
    e0f2:	f000 f96d 	bl	e3d0 <uart_console_is_init>
#endif
#if MYNEWT_VAL(CONSOLE_TCP)
    return tcp_console_is_init();
#endif
    return 0;
}
    e0f6:	bd08      	pop	{r3, pc}

0000e0f8 <console_pkg_init>:
}
#endif

void
console_pkg_init(void)
{
    e0f8:	b510      	push	{r4, lr}
    e0fa:	b082      	sub	sp, #8
    int rc = 0;

    /* Ensure this function only gets called by sysinit. */
    SYSINIT_ASSERT_ACTIVE();
    e0fc:	4b12      	ldr	r3, [pc, #72]	; (e148 <console_pkg_init+0x50>)
    e0fe:	781b      	ldrb	r3, [r3, #0]
    e100:	b153      	cbz	r3, e118 <console_pkg_init+0x20>

    os_eventq_init(&avail_queue);
    e102:	4812      	ldr	r0, [pc, #72]	; (e14c <console_pkg_init+0x54>)
    e104:	f7fe fce2 	bl	cacc <os_eventq_init>
    os_mutex_init(&console_write_lock);
    e108:	4811      	ldr	r0, [pc, #68]	; (e150 <console_pkg_init+0x58>)
    e10a:	f7fe fe11 	bl	cd30 <os_mutex_init>

#if MYNEWT_VAL(CONSOLE_UART)
    rc = uart_console_init();
    e10e:	f000 f967 	bl	e3e0 <uart_console_init>
#endif
#if MYNEWT_VAL(CONSOLE_RTT)
    rc = rtt_console_init();
#endif
    SYSINIT_PANIC_ASSERT(rc == 0);
    e112:	b958      	cbnz	r0, e12c <console_pkg_init+0x34>
}
    e114:	b002      	add	sp, #8
    e116:	bd10      	pop	{r4, pc}
    SYSINIT_ASSERT_ACTIVE();
    e118:	f7fe f840 	bl	c19c <hal_debugger_connected>
    e11c:	b100      	cbz	r0, e120 <console_pkg_init+0x28>
    e11e:	be01      	bkpt	0x0001
    e120:	2300      	movs	r3, #0
    e122:	461a      	mov	r2, r3
    e124:	4619      	mov	r1, r3
    e126:	4618      	mov	r0, r3
    e128:	f7fe fa16 	bl	c558 <__assert_func>
    SYSINIT_PANIC_ASSERT(rc == 0);
    e12c:	f7fe f836 	bl	c19c <hal_debugger_connected>
    e130:	b100      	cbz	r0, e134 <console_pkg_init+0x3c>
    e132:	be01      	bkpt	0x0001
    e134:	2000      	movs	r0, #0
    e136:	9000      	str	r0, [sp, #0]
    e138:	4b06      	ldr	r3, [pc, #24]	; (e154 <console_pkg_init+0x5c>)
    e13a:	681c      	ldr	r4, [r3, #0]
    e13c:	4603      	mov	r3, r0
    e13e:	4602      	mov	r2, r0
    e140:	4601      	mov	r1, r0
    e142:	47a0      	blx	r4
}
    e144:	e7e6      	b.n	e114 <console_pkg_init+0x1c>
    e146:	bf00      	nop
    e148:	20002370 	.word	0x20002370
    e14c:	20002188 	.word	0x20002188
    e150:	200021a4 	.word	0x200021a4
    e154:	20000130 	.word	0x20000130

0000e158 <console_vprintf>:

#if MYNEWT_VAL(BASELIBC_PRESENT)

int
console_vprintf(const char *fmt, va_list ap)
{
    e158:	b570      	push	{r4, r5, r6, lr}
    e15a:	4604      	mov	r4, r0
    e15c:	460d      	mov	r5, r1
    int num_chars;

    num_chars = 0;

    if (console_get_ticks()) {
    e15e:	f000 f827 	bl	e1b0 <console_get_ticks>
    e162:	b160      	cbz	r0, e17e <console_vprintf+0x26>
        /* Prefix each line with a timestamp. */
        if (!console_is_midline) {
    e164:	4b09      	ldr	r3, [pc, #36]	; (e18c <console_vprintf+0x34>)
    e166:	681b      	ldr	r3, [r3, #0]
    e168:	b10b      	cbz	r3, e16e <console_vprintf+0x16>
    num_chars = 0;
    e16a:	2600      	movs	r6, #0
    e16c:	e008      	b.n	e180 <console_vprintf+0x28>
            num_chars += printf("%06lu ", (unsigned long)os_time_get());
    e16e:	f7ff f95b 	bl	d428 <os_time_get>
    e172:	4601      	mov	r1, r0
    e174:	4806      	ldr	r0, [pc, #24]	; (e190 <console_vprintf+0x38>)
    e176:	f002 fe87 	bl	10e88 <printf>
    e17a:	4606      	mov	r6, r0
    e17c:	e000      	b.n	e180 <console_vprintf+0x28>
    num_chars = 0;
    e17e:	2600      	movs	r6, #0
        }
    }

    num_chars += vprintf(fmt, ap);
    e180:	4629      	mov	r1, r5
    e182:	4620      	mov	r0, r4
    e184:	f002 fe92 	bl	10eac <vprintf>

    return num_chars;
}
    e188:	4430      	add	r0, r6
    e18a:	bd70      	pop	{r4, r5, r6, pc}
    e18c:	200021a0 	.word	0x200021a0
    e190:	000119b8 	.word	0x000119b8

0000e194 <console_printf>:
 *                                  unlimited.  This return value is analogous
 *                                  to that of snprintf.
 */
int
console_printf(const char *fmt, ...)
{
    e194:	b40f      	push	{r0, r1, r2, r3}
    e196:	b500      	push	{lr}
    e198:	b083      	sub	sp, #12
    e19a:	a904      	add	r1, sp, #16
    e19c:	f851 0b04 	ldr.w	r0, [r1], #4
    va_list args;
    int num_chars;

    va_start(args, fmt);
    e1a0:	9101      	str	r1, [sp, #4]
    num_chars = console_vprintf(fmt, args);
    e1a2:	f7ff ffd9 	bl	e158 <console_vprintf>
    va_end(args);

    return num_chars;
}
    e1a6:	b003      	add	sp, #12
    e1a8:	f85d eb04 	ldr.w	lr, [sp], #4
    e1ac:	b004      	add	sp, #16
    e1ae:	4770      	bx	lr

0000e1b0 <console_get_ticks>:

/* return value of CONSOLE_TICKS */
char console_get_ticks(void)
{
    return do_ticks;
}
    e1b0:	4b01      	ldr	r3, [pc, #4]	; (e1b8 <console_get_ticks+0x8>)
    e1b2:	7818      	ldrb	r0, [r3, #0]
    e1b4:	4770      	bx	lr
    e1b6:	bf00      	nop
    e1b8:	20000120 	.word	0x20000120

0000e1bc <uart_blocking_tx>:
 *
 * @param dev		Uart device in question
 */
static inline void
uart_blocking_tx(struct uart_dev *dev, uint8_t byte)
{
    e1bc:	b508      	push	{r3, lr}
    dev->ud_funcs.uf_blocking_tx(dev, byte);
    e1be:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
    e1c0:	4798      	blx	r3
}
    e1c2:	bd08      	pop	{r3, pc}

0000e1c4 <uart_console_ring_add_char>:
}

static void
uart_console_ring_add_char(struct console_ring *cr, char ch)
{
    cr->buf[cr->head] = ch;
    e1c4:	6842      	ldr	r2, [r0, #4]
    e1c6:	7803      	ldrb	r3, [r0, #0]
    e1c8:	54d1      	strb	r1, [r2, r3]
    cr->head = inc_and_wrap(cr->head, cr->size);
    e1ca:	7803      	ldrb	r3, [r0, #0]
    e1cc:	8842      	ldrh	r2, [r0, #2]
    return (i + 1) & (max - 1);
    e1ce:	3301      	adds	r3, #1
    e1d0:	3a01      	subs	r2, #1
    e1d2:	4013      	ands	r3, r2
    cr->head = inc_and_wrap(cr->head, cr->size);
    e1d4:	7003      	strb	r3, [r0, #0]
}
    e1d6:	4770      	bx	lr

0000e1d8 <uart_console_ring_pull_char>:

static uint8_t
uart_console_ring_pull_char(struct console_ring *cr)
{
    e1d8:	4603      	mov	r3, r0
    uint8_t ch;

    ch = cr->buf[cr->tail];
    e1da:	6841      	ldr	r1, [r0, #4]
    e1dc:	7842      	ldrb	r2, [r0, #1]
    e1de:	5c88      	ldrb	r0, [r1, r2]
    cr->tail = inc_and_wrap(cr->tail, cr->size);
    e1e0:	8859      	ldrh	r1, [r3, #2]
    return (i + 1) & (max - 1);
    e1e2:	3201      	adds	r2, #1
    e1e4:	3901      	subs	r1, #1
    e1e6:	400a      	ands	r2, r1
    cr->tail = inc_and_wrap(cr->tail, cr->size);
    e1e8:	705a      	strb	r2, [r3, #1]
    return ch;
}
    e1ea:	4770      	bx	lr

0000e1ec <uart_console_ring_is_full>:

static bool
uart_console_ring_is_full(const struct console_ring *cr)
{
    return inc_and_wrap(cr->head, cr->size) == cr->tail;
    e1ec:	7803      	ldrb	r3, [r0, #0]
    e1ee:	8842      	ldrh	r2, [r0, #2]
    return (i + 1) & (max - 1);
    e1f0:	3301      	adds	r3, #1
    e1f2:	3a01      	subs	r2, #1
    e1f4:	4013      	ands	r3, r2
    return inc_and_wrap(cr->head, cr->size) == cr->tail;
    e1f6:	7840      	ldrb	r0, [r0, #1]
}
    e1f8:	4298      	cmp	r0, r3
    e1fa:	bf14      	ite	ne
    e1fc:	2000      	movne	r0, #0
    e1fe:	2001      	moveq	r0, #1
    e200:	4770      	bx	lr

0000e202 <uart_console_ring_is_empty>:

static bool
uart_console_ring_is_empty(const struct console_ring *cr)
{
    return cr->head == cr->tail;
    e202:	7802      	ldrb	r2, [r0, #0]
    e204:	7840      	ldrb	r0, [r0, #1]
}
    e206:	4282      	cmp	r2, r0
    e208:	bf14      	ite	ne
    e20a:	2000      	movne	r0, #0
    e20c:	2001      	moveq	r0, #1
    e20e:	4770      	bx	lr

0000e210 <uart_console_tx_flush>:
/*
 * Flush cnt characters from console output queue.
 */
static void
uart_console_tx_flush(int cnt)
{
    e210:	b538      	push	{r3, r4, r5, lr}
    e212:	4605      	mov	r5, r0
    int i;
    uint8_t byte;

    for (i = 0; i < cnt; i++) {
    e214:	2400      	movs	r4, #0
    e216:	42ac      	cmp	r4, r5
    e218:	da0d      	bge.n	e236 <uart_console_tx_flush+0x26>
        if (uart_console_ring_is_empty(&cr_tx)) {
    e21a:	4807      	ldr	r0, [pc, #28]	; (e238 <uart_console_tx_flush+0x28>)
    e21c:	f7ff fff1 	bl	e202 <uart_console_ring_is_empty>
    e220:	b948      	cbnz	r0, e236 <uart_console_tx_flush+0x26>
            break;
        }
        byte = uart_console_ring_pull_char(&cr_tx);
    e222:	4805      	ldr	r0, [pc, #20]	; (e238 <uart_console_tx_flush+0x28>)
    e224:	f7ff ffd8 	bl	e1d8 <uart_console_ring_pull_char>
    e228:	4601      	mov	r1, r0
        uart_blocking_tx(uart_dev, byte);
    e22a:	4b04      	ldr	r3, [pc, #16]	; (e23c <uart_console_tx_flush+0x2c>)
    e22c:	6818      	ldr	r0, [r3, #0]
    dev->ud_funcs.uf_blocking_tx(dev, byte);
    e22e:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
    e230:	4790      	blx	r2
    for (i = 0; i < cnt; i++) {
    e232:	3401      	adds	r4, #1
    e234:	e7ef      	b.n	e216 <uart_console_tx_flush+0x6>
    }
}
    e236:	bd38      	pop	{r3, r4, r5, pc}
    e238:	200021f4 	.word	0x200021f4
    e23c:	20002230 	.word	0x20002230

0000e240 <uart_console_tx_char>:
 * Interrupts disabled when console_tx_char/console_rx_char are called.
 * Characters sent only in blocking mode.
 */
static int
uart_console_tx_char(void *arg)
{
    e240:	b508      	push	{r3, lr}
    if (uart_console_ring_is_empty(&cr_tx)) {
    e242:	4805      	ldr	r0, [pc, #20]	; (e258 <uart_console_tx_char+0x18>)
    e244:	f7ff ffdd 	bl	e202 <uart_console_ring_is_empty>
    e248:	b918      	cbnz	r0, e252 <uart_console_tx_char+0x12>
        return -1;
    }
    return uart_console_ring_pull_char(&cr_tx);
    e24a:	4803      	ldr	r0, [pc, #12]	; (e258 <uart_console_tx_char+0x18>)
    e24c:	f7ff ffc4 	bl	e1d8 <uart_console_ring_pull_char>
}
    e250:	bd08      	pop	{r3, pc}
        return -1;
    e252:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    e256:	e7fb      	b.n	e250 <uart_console_tx_char+0x10>
    e258:	200021f4 	.word	0x200021f4

0000e25c <uart_console_queue_char>:
    if (((uart_dev->ud_dev.od_flags & OS_DEV_F_STATUS_OPEN) == 0) ||
    e25c:	7ec3      	ldrb	r3, [r0, #27]
    e25e:	f003 0306 	and.w	r3, r3, #6
    e262:	2b02      	cmp	r3, #2
    e264:	d000      	beq.n	e268 <uart_console_queue_char+0xc>
    e266:	4770      	bx	lr
{
    e268:	b570      	push	{r4, r5, r6, lr}
    e26a:	4605      	mov	r5, r0
    e26c:	460e      	mov	r6, r1
    OS_ENTER_CRITICAL(sr);
    e26e:	f7ff f92b 	bl	d4c8 <os_arch_save_sr>
    e272:	4604      	mov	r4, r0
    while (uart_console_ring_is_full(&cr_tx)) {
    e274:	e005      	b.n	e282 <uart_console_queue_char+0x26>
            os_time_delay(1);
    e276:	2001      	movs	r0, #1
    e278:	f7ff f902 	bl	d480 <os_time_delay>
        OS_ENTER_CRITICAL(sr);
    e27c:	f7ff f924 	bl	d4c8 <os_arch_save_sr>
    e280:	4604      	mov	r4, r0
    while (uart_console_ring_is_full(&cr_tx)) {
    e282:	480b      	ldr	r0, [pc, #44]	; (e2b0 <uart_console_queue_char+0x54>)
    e284:	f7ff ffb2 	bl	e1ec <uart_console_ring_is_full>
    e288:	b150      	cbz	r0, e2a0 <uart_console_queue_char+0x44>
    dev->ud_funcs.uf_start_tx(dev);
    e28a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    e28c:	4628      	mov	r0, r5
    e28e:	4798      	blx	r3
        OS_EXIT_CRITICAL(sr);
    e290:	4620      	mov	r0, r4
    e292:	f7ff f91f 	bl	d4d4 <os_arch_restore_sr>
        if (os_started()) {
    e296:	f7fe fa1f 	bl	c6d8 <os_started>
    e29a:	2800      	cmp	r0, #0
    e29c:	d0ee      	beq.n	e27c <uart_console_queue_char+0x20>
    e29e:	e7ea      	b.n	e276 <uart_console_queue_char+0x1a>
    uart_console_ring_add_char(&cr_tx, ch);
    e2a0:	4631      	mov	r1, r6
    e2a2:	4803      	ldr	r0, [pc, #12]	; (e2b0 <uart_console_queue_char+0x54>)
    e2a4:	f7ff ff8e 	bl	e1c4 <uart_console_ring_add_char>
    OS_EXIT_CRITICAL(sr);
    e2a8:	4620      	mov	r0, r4
    e2aa:	f7ff f913 	bl	d4d4 <os_arch_restore_sr>
}
    e2ae:	bd70      	pop	{r4, r5, r6, pc}
    e2b0:	200021f4 	.word	0x200021f4

0000e2b4 <uart_console_rx_char>:
/*
 * Interrupts disabled when console_tx_char/console_rx_char are called.
 */
static int
uart_console_rx_char(void *arg, uint8_t byte)
{
    e2b4:	b510      	push	{r4, lr}
    e2b6:	460c      	mov	r4, r1
#if MYNEWT_VAL(CONSOLE_UART_RX_BUF_SIZE) > 0
    if (uart_console_ring_is_full(&cr_rx)) {
    e2b8:	480c      	ldr	r0, [pc, #48]	; (e2ec <uart_console_rx_char+0x38>)
    e2ba:	f7ff ff97 	bl	e1ec <uart_console_ring_is_full>
    e2be:	b940      	cbnz	r0, e2d2 <uart_console_rx_char+0x1e>
        uart_console_rx_stalled = true;
        return -1;
    }

    uart_console_ring_add_char(&cr_rx, byte);
    e2c0:	4621      	mov	r1, r4
    e2c2:	480a      	ldr	r0, [pc, #40]	; (e2ec <uart_console_rx_char+0x38>)
    e2c4:	f7ff ff7e 	bl	e1c4 <uart_console_ring_add_char>

    if (!rx_ev.ev_queued) {
    e2c8:	4b09      	ldr	r3, [pc, #36]	; (e2f0 <uart_console_rx_char+0x3c>)
    e2ca:	781b      	ldrb	r3, [r3, #0]
    e2cc:	b13b      	cbz	r3, e2de <uart_console_rx_char+0x2a>
        os_eventq_put(os_eventq_dflt_get(), &rx_ev);
    }

    return 0;
    e2ce:	2000      	movs	r0, #0
#else
    return console_handle_char(byte);
#endif
}
    e2d0:	bd10      	pop	{r4, pc}
        uart_console_rx_stalled = true;
    e2d2:	4b08      	ldr	r3, [pc, #32]	; (e2f4 <uart_console_rx_char+0x40>)
    e2d4:	2201      	movs	r2, #1
    e2d6:	701a      	strb	r2, [r3, #0]
        return -1;
    e2d8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    e2dc:	e7f8      	b.n	e2d0 <uart_console_rx_char+0x1c>
        os_eventq_put(os_eventq_dflt_get(), &rx_ev);
    e2de:	f7fe fc47 	bl	cb70 <os_eventq_dflt_get>
    e2e2:	4903      	ldr	r1, [pc, #12]	; (e2f0 <uart_console_rx_char+0x3c>)
    e2e4:	f7fe fbff 	bl	cae6 <os_eventq_put>
    return 0;
    e2e8:	2000      	movs	r0, #0
    e2ea:	e7f1      	b.n	e2d0 <uart_console_rx_char+0x1c>
    e2ec:	200021cc 	.word	0x200021cc
    e2f0:	2000221c 	.word	0x2000221c
    e2f4:	2000222c 	.word	0x2000222c

0000e2f8 <uart_console_rx_char_event>:

#if MYNEWT_VAL(CONSOLE_UART_RX_BUF_SIZE) > 0
static void
uart_console_rx_char_event(struct os_event *ev)
{
    e2f8:	b510      	push	{r4, lr}
    static int b = -1;
    int sr;
    int ret;

    /* We may have unhandled character - try it first */
    if (b >= 0) {
    e2fa:	4b18      	ldr	r3, [pc, #96]	; (e35c <uart_console_rx_char_event+0x64>)
    e2fc:	6818      	ldr	r0, [r3, #0]
    e2fe:	2800      	cmp	r0, #0
    e300:	db0b      	blt.n	e31a <uart_console_rx_char_event+0x22>
        ret = console_handle_char(b);
    e302:	b2c0      	uxtb	r0, r0
    e304:	f7ff fe30 	bl	df68 <console_handle_char>
        if (ret < 0) {
    e308:	2800      	cmp	r0, #0
    e30a:	da06      	bge.n	e31a <uart_console_rx_char_event+0x22>
    e30c:	e024      	b.n	e358 <uart_console_rx_char_event+0x60>
        if (uart_console_rx_stalled) {
            uart_console_rx_stalled = false;
            uart_start_rx(uart_dev);
        }

        ret = console_handle_char(b);
    e30e:	4b13      	ldr	r3, [pc, #76]	; (e35c <uart_console_rx_char_event+0x64>)
    e310:	7818      	ldrb	r0, [r3, #0]
    e312:	f7ff fe29 	bl	df68 <console_handle_char>
        if (ret < 0) {
    e316:	2800      	cmp	r0, #0
    e318:	db1e      	blt.n	e358 <uart_console_rx_char_event+0x60>
    while (!uart_console_ring_is_empty(&cr_rx)) {
    e31a:	4811      	ldr	r0, [pc, #68]	; (e360 <uart_console_rx_char_event+0x68>)
    e31c:	f7ff ff71 	bl	e202 <uart_console_ring_is_empty>
    e320:	b9b0      	cbnz	r0, e350 <uart_console_rx_char_event+0x58>
        OS_ENTER_CRITICAL(sr);
    e322:	f7ff f8d1 	bl	d4c8 <os_arch_save_sr>
    e326:	4604      	mov	r4, r0
        b = uart_console_ring_pull_char(&cr_rx);
    e328:	480d      	ldr	r0, [pc, #52]	; (e360 <uart_console_rx_char_event+0x68>)
    e32a:	f7ff ff55 	bl	e1d8 <uart_console_ring_pull_char>
    e32e:	4b0b      	ldr	r3, [pc, #44]	; (e35c <uart_console_rx_char_event+0x64>)
    e330:	6018      	str	r0, [r3, #0]
        OS_EXIT_CRITICAL(sr);
    e332:	4620      	mov	r0, r4
    e334:	f7ff f8ce 	bl	d4d4 <os_arch_restore_sr>
        if (uart_console_rx_stalled) {
    e338:	4b0a      	ldr	r3, [pc, #40]	; (e364 <uart_console_rx_char_event+0x6c>)
    e33a:	781b      	ldrb	r3, [r3, #0]
    e33c:	2b00      	cmp	r3, #0
    e33e:	d0e6      	beq.n	e30e <uart_console_rx_char_event+0x16>
            uart_console_rx_stalled = false;
    e340:	4b08      	ldr	r3, [pc, #32]	; (e364 <uart_console_rx_char_event+0x6c>)
    e342:	2200      	movs	r2, #0
    e344:	701a      	strb	r2, [r3, #0]
            uart_start_rx(uart_dev);
    e346:	4b08      	ldr	r3, [pc, #32]	; (e368 <uart_console_rx_char_event+0x70>)
    e348:	6818      	ldr	r0, [r3, #0]
    dev->ud_funcs.uf_start_rx(dev);
    e34a:	6a83      	ldr	r3, [r0, #40]	; 0x28
    e34c:	4798      	blx	r3
}
    e34e:	e7de      	b.n	e30e <uart_console_rx_char_event+0x16>
            return;
        }
    }

    b = -1;
    e350:	4b02      	ldr	r3, [pc, #8]	; (e35c <uart_console_rx_char_event+0x64>)
    e352:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    e356:	601a      	str	r2, [r3, #0]
}
    e358:	bd10      	pop	{r4, pc}
    e35a:	bf00      	nop
    e35c:	20000124 	.word	0x20000124
    e360:	200021cc 	.word	0x200021cc
    e364:	2000222c 	.word	0x2000222c
    e368:	20002230 	.word	0x20002230

0000e36c <uart_console_blocking_mode>:
{
    e36c:	b510      	push	{r4, lr}
    OS_ENTER_CRITICAL(sr);
    e36e:	f7ff f8ab 	bl	d4c8 <os_arch_save_sr>
    e372:	4604      	mov	r4, r0
    if (write_char_cb) {
    e374:	4b06      	ldr	r3, [pc, #24]	; (e390 <uart_console_blocking_mode+0x24>)
    e376:	681b      	ldr	r3, [r3, #0]
    e378:	b12b      	cbz	r3, e386 <uart_console_blocking_mode+0x1a>
        write_char_cb = uart_blocking_tx;
    e37a:	4b05      	ldr	r3, [pc, #20]	; (e390 <uart_console_blocking_mode+0x24>)
    e37c:	4a05      	ldr	r2, [pc, #20]	; (e394 <uart_console_blocking_mode+0x28>)
    e37e:	601a      	str	r2, [r3, #0]
        uart_console_tx_flush(MYNEWT_VAL(CONSOLE_UART_TX_BUF_SIZE));
    e380:	2020      	movs	r0, #32
    e382:	f7ff ff45 	bl	e210 <uart_console_tx_flush>
    OS_EXIT_CRITICAL(sr);
    e386:	4620      	mov	r0, r4
    e388:	f7ff f8a4 	bl	d4d4 <os_arch_restore_sr>
}
    e38c:	bd10      	pop	{r4, pc}
    e38e:	bf00      	nop
    e390:	20002234 	.word	0x20002234
    e394:	0000e1bd 	.word	0x0000e1bd

0000e398 <console_out_nolock>:
{
    e398:	b538      	push	{r3, r4, r5, lr}
    e39a:	4604      	mov	r4, r0
    if (!write_char_cb) {
    e39c:	4b0a      	ldr	r3, [pc, #40]	; (e3c8 <console_out_nolock+0x30>)
    e39e:	681b      	ldr	r3, [r3, #0]
    e3a0:	b153      	cbz	r3, e3b8 <console_out_nolock+0x20>
    if ('\n' == c) {
    e3a2:	280a      	cmp	r0, #10
    e3a4:	d00a      	beq.n	e3bc <console_out_nolock+0x24>
    write_char_cb(uart_dev, c);
    e3a6:	4d09      	ldr	r5, [pc, #36]	; (e3cc <console_out_nolock+0x34>)
    e3a8:	4b07      	ldr	r3, [pc, #28]	; (e3c8 <console_out_nolock+0x30>)
    e3aa:	681b      	ldr	r3, [r3, #0]
    e3ac:	b2e1      	uxtb	r1, r4
    e3ae:	6828      	ldr	r0, [r5, #0]
    e3b0:	4798      	blx	r3
    uart_start_tx(uart_dev);
    e3b2:	6828      	ldr	r0, [r5, #0]
    dev->ud_funcs.uf_start_tx(dev);
    e3b4:	6a43      	ldr	r3, [r0, #36]	; 0x24
    e3b6:	4798      	blx	r3
}
    e3b8:	4620      	mov	r0, r4
    e3ba:	bd38      	pop	{r3, r4, r5, pc}
        write_char_cb(uart_dev, '\r');
    e3bc:	210d      	movs	r1, #13
    e3be:	4a03      	ldr	r2, [pc, #12]	; (e3cc <console_out_nolock+0x34>)
    e3c0:	6810      	ldr	r0, [r2, #0]
    e3c2:	4798      	blx	r3
    e3c4:	e7ef      	b.n	e3a6 <console_out_nolock+0xe>
    e3c6:	bf00      	nop
    e3c8:	20002234 	.word	0x20002234
    e3cc:	20002230 	.word	0x20002230

0000e3d0 <uart_console_is_init>:
#endif

int
uart_console_is_init(void)
{
    return uart_dev != NULL;
    e3d0:	4b02      	ldr	r3, [pc, #8]	; (e3dc <uart_console_is_init+0xc>)
    e3d2:	6818      	ldr	r0, [r3, #0]
}
    e3d4:	3800      	subs	r0, #0
    e3d6:	bf18      	it	ne
    e3d8:	2001      	movne	r0, #1
    e3da:	4770      	bx	lr
    e3dc:	20002230 	.word	0x20002230

0000e3e0 <uart_console_init>:
    return 0;
}

int
uart_console_init(void)
{
    e3e0:	b500      	push	{lr}
    e3e2:	b087      	sub	sp, #28
    struct uart_conf uc = {
    e3e4:	2300      	movs	r3, #0
    e3e6:	9301      	str	r3, [sp, #4]
    e3e8:	9304      	str	r3, [sp, #16]
    e3ea:	9305      	str	r3, [sp, #20]
    e3ec:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
    e3f0:	9300      	str	r3, [sp, #0]
    e3f2:	2308      	movs	r3, #8
    e3f4:	f88d 3004 	strb.w	r3, [sp, #4]
    e3f8:	2301      	movs	r3, #1
    e3fa:	f88d 3005 	strb.w	r3, [sp, #5]
    e3fe:	4b14      	ldr	r3, [pc, #80]	; (e450 <uart_console_init+0x70>)
    e400:	9302      	str	r3, [sp, #8]
    e402:	4b14      	ldr	r3, [pc, #80]	; (e454 <uart_console_init+0x74>)
    e404:	9303      	str	r3, [sp, #12]
        .uc_flow_ctl = MYNEWT_VAL(CONSOLE_UART_FLOW_CONTROL),
        .uc_tx_char = uart_console_tx_char,
        .uc_rx_char = uart_console_rx_char,
    };

    cr_tx.size = MYNEWT_VAL(CONSOLE_UART_TX_BUF_SIZE);
    e406:	4b14      	ldr	r3, [pc, #80]	; (e458 <uart_console_init+0x78>)
    e408:	2220      	movs	r2, #32
    e40a:	805a      	strh	r2, [r3, #2]
    cr_tx.buf = cr_tx_buf;
    e40c:	4913      	ldr	r1, [pc, #76]	; (e45c <uart_console_init+0x7c>)
    e40e:	6059      	str	r1, [r3, #4]
    write_char_cb = uart_console_queue_char;
    e410:	4b13      	ldr	r3, [pc, #76]	; (e460 <uart_console_init+0x80>)
    e412:	4914      	ldr	r1, [pc, #80]	; (e464 <uart_console_init+0x84>)
    e414:	6019      	str	r1, [r3, #0]

#if MYNEWT_VAL(CONSOLE_UART_RX_BUF_SIZE) > 0
    cr_rx.size = MYNEWT_VAL(CONSOLE_UART_RX_BUF_SIZE);
    e416:	4b14      	ldr	r3, [pc, #80]	; (e468 <uart_console_init+0x88>)
    e418:	805a      	strh	r2, [r3, #2]
    cr_rx.buf = cr_rx_buf;
    e41a:	4a14      	ldr	r2, [pc, #80]	; (e46c <uart_console_init+0x8c>)
    e41c:	605a      	str	r2, [r3, #4]

    rx_ev.ev_cb = uart_console_rx_char_event;
    e41e:	4b14      	ldr	r3, [pc, #80]	; (e470 <uart_console_init+0x90>)
    e420:	4a14      	ldr	r2, [pc, #80]	; (e474 <uart_console_init+0x94>)
    e422:	605a      	str	r2, [r3, #4]
#endif

    if (!uart_dev) {
    e424:	4b14      	ldr	r3, [pc, #80]	; (e478 <uart_console_init+0x98>)
    e426:	681b      	ldr	r3, [r3, #0]
    e428:	b11b      	cbz	r3, e432 <uart_console_init+0x52>
          OS_TIMEOUT_NEVER, &uc);
        if (!uart_dev) {
            return -1;
        }
    }
    return 0;
    e42a:	2000      	movs	r0, #0
}
    e42c:	b007      	add	sp, #28
    e42e:	f85d fb04 	ldr.w	pc, [sp], #4
        uart_dev = (struct uart_dev *)os_dev_open(MYNEWT_VAL(CONSOLE_UART_DEV),
    e432:	466a      	mov	r2, sp
    e434:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    e438:	4810      	ldr	r0, [pc, #64]	; (e47c <uart_console_init+0x9c>)
    e43a:	f7fe fb1d 	bl	ca78 <os_dev_open>
    e43e:	4b0e      	ldr	r3, [pc, #56]	; (e478 <uart_console_init+0x98>)
    e440:	6018      	str	r0, [r3, #0]
        if (!uart_dev) {
    e442:	b108      	cbz	r0, e448 <uart_console_init+0x68>
    return 0;
    e444:	2000      	movs	r0, #0
    e446:	e7f1      	b.n	e42c <uart_console_init+0x4c>
            return -1;
    e448:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    e44c:	e7ee      	b.n	e42c <uart_console_init+0x4c>
    e44e:	bf00      	nop
    e450:	0000e241 	.word	0x0000e241
    e454:	0000e2b5 	.word	0x0000e2b5
    e458:	200021f4 	.word	0x200021f4
    e45c:	200021fc 	.word	0x200021fc
    e460:	20002234 	.word	0x20002234
    e464:	0000e25d 	.word	0x0000e25d
    e468:	200021cc 	.word	0x200021cc
    e46c:	200021d4 	.word	0x200021d4
    e470:	2000221c 	.word	0x2000221c
    e474:	0000e2f9 	.word	0x0000e2f9
    e478:	20002230 	.word	0x20002230
    e47c:	000119c0 	.word	0x000119c0

0000e480 <flash_area_find_idx>:
const struct flash_area *flash_map;
int flash_map_entries;

static int
flash_area_find_idx(uint8_t id)
{
    e480:	4602      	mov	r2, r0
    int i;

    if (flash_map == NULL) {
    e482:	4b0b      	ldr	r3, [pc, #44]	; (e4b0 <flash_area_find_idx+0x30>)
    e484:	6819      	ldr	r1, [r3, #0]
    e486:	b179      	cbz	r1, e4a8 <flash_area_find_idx+0x28>
        return -1;
    }

    for (i = 0; i < flash_map_entries; i++) {
    e488:	2000      	movs	r0, #0
    e48a:	4b0a      	ldr	r3, [pc, #40]	; (e4b4 <flash_area_find_idx+0x34>)
    e48c:	681b      	ldr	r3, [r3, #0]
    e48e:	4283      	cmp	r3, r0
    e490:	dd07      	ble.n	e4a2 <flash_area_find_idx+0x22>
        if (flash_map[i].fa_id == id) {
    e492:	eb00 0340 	add.w	r3, r0, r0, lsl #1
    e496:	f811 3023 	ldrb.w	r3, [r1, r3, lsl #2]
    e49a:	4293      	cmp	r3, r2
    e49c:	d006      	beq.n	e4ac <flash_area_find_idx+0x2c>
    for (i = 0; i < flash_map_entries; i++) {
    e49e:	3001      	adds	r0, #1
    e4a0:	e7f3      	b.n	e48a <flash_area_find_idx+0xa>
            return i;
        }
    }

    return -1;
    e4a2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    e4a6:	4770      	bx	lr
        return -1;
    e4a8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
    e4ac:	4770      	bx	lr
    e4ae:	bf00      	nop
    e4b0:	20002238 	.word	0x20002238
    e4b4:	2000223c 	.word	0x2000223c

0000e4b8 <flash_map_area_overlaps>:
    const struct flash_area *area2;
    uint32_t end1;
    uint32_t end2;
    int i;

    for (i = 0; i < flash_map_entries; i++) {
    e4b8:	2300      	movs	r3, #0
    e4ba:	4a13      	ldr	r2, [pc, #76]	; (e508 <flash_map_area_overlaps+0x50>)
    e4bc:	6812      	ldr	r2, [r2, #0]
    e4be:	429a      	cmp	r2, r3
    e4c0:	dd1f      	ble.n	e502 <flash_map_area_overlaps+0x4a>
{
    e4c2:	b430      	push	{r4, r5}
    e4c4:	e004      	b.n	e4d0 <flash_map_area_overlaps+0x18>
    for (i = 0; i < flash_map_entries; i++) {
    e4c6:	3301      	adds	r3, #1
    e4c8:	4a0f      	ldr	r2, [pc, #60]	; (e508 <flash_map_area_overlaps+0x50>)
    e4ca:	6812      	ldr	r2, [r2, #0]
    e4cc:	429a      	cmp	r2, r3
    e4ce:	dd15      	ble.n	e4fc <flash_map_area_overlaps+0x44>
        area2 = &flash_map[i];
    e4d0:	4a0e      	ldr	r2, [pc, #56]	; (e50c <flash_map_area_overlaps+0x54>)
    e4d2:	6812      	ldr	r2, [r2, #0]
    e4d4:	eb03 0143 	add.w	r1, r3, r3, lsl #1
    e4d8:	eb02 0281 	add.w	r2, r2, r1, lsl #2

        if (area1->fa_device_id == area2->fa_device_id) {
    e4dc:	7844      	ldrb	r4, [r0, #1]
    e4de:	7851      	ldrb	r1, [r2, #1]
    e4e0:	428c      	cmp	r4, r1
    e4e2:	d1f0      	bne.n	e4c6 <flash_map_area_overlaps+0xe>
            end1 = area1->fa_off + area1->fa_size;
    e4e4:	6845      	ldr	r5, [r0, #4]
    e4e6:	6881      	ldr	r1, [r0, #8]
    e4e8:	4429      	add	r1, r5
            end2 = area2->fa_off + area2->fa_size;
    e4ea:	6854      	ldr	r4, [r2, #4]
    e4ec:	6892      	ldr	r2, [r2, #8]
    e4ee:	4422      	add	r2, r4

            if (end1 > area2->fa_off && area1->fa_off < end2) {
    e4f0:	428c      	cmp	r4, r1
    e4f2:	d2e8      	bcs.n	e4c6 <flash_map_area_overlaps+0xe>
    e4f4:	4295      	cmp	r5, r2
    e4f6:	d2e6      	bcs.n	e4c6 <flash_map_area_overlaps+0xe>
                return true;
    e4f8:	2001      	movs	r0, #1
    e4fa:	e000      	b.n	e4fe <flash_map_area_overlaps+0x46>
            }
        }
    }

    return false;
    e4fc:	2000      	movs	r0, #0
}
    e4fe:	bc30      	pop	{r4, r5}
    e500:	4770      	bx	lr
    return false;
    e502:	2000      	movs	r0, #0
}
    e504:	4770      	bx	lr
    e506:	bf00      	nop
    e508:	2000223c 	.word	0x2000223c
    e50c:	20002238 	.word	0x20002238

0000e510 <flash_map_add_new_dflt_areas>:
 * Adds areas from the hardcoded flash map that aren't present in, and don't
 * overlap with, the manufacturing flash map.
 */
static void
flash_map_add_new_dflt_areas(void)
{
    e510:	b570      	push	{r4, r5, r6, lr}

    const struct flash_area *dflt_area;
    struct flash_area *dst_area;
    int i;
    
    for (i = 0; i < num_dflt_entries; i++) {
    e512:	2400      	movs	r4, #0
    e514:	e00a      	b.n	e52c <flash_map_add_new_dflt_areas+0x1c>
            /* Default flash map contains a new entry. */
            if (flash_map_entries >= MYNEWT_VAL(FLASH_MAP_MAX_AREAS)) {
                DFLT_LOG_DEBUG("failed to add default flash area: "
                               "no room: id=%d",
                               dflt_area->fa_id);
                DEBUG_PANIC();
    e516:	f7fd fe41 	bl	c19c <hal_debugger_connected>
    e51a:	b100      	cbz	r0, e51e <flash_map_add_new_dflt_areas+0xe>
    e51c:	be01      	bkpt	0x0001
    e51e:	2300      	movs	r3, #0
    e520:	461a      	mov	r2, r3
    e522:	4619      	mov	r1, r3
    e524:	4618      	mov	r0, r3
    e526:	f7fe f817 	bl	c558 <__assert_func>
    for (i = 0; i < num_dflt_entries; i++) {
    e52a:	3401      	adds	r4, #1
    e52c:	2c05      	cmp	r4, #5
    e52e:	dc28      	bgt.n	e582 <flash_map_add_new_dflt_areas+0x72>
        dflt_area = &sysflash_map_dflt[i];
    e530:	eb04 0344 	add.w	r3, r4, r4, lsl #1
    e534:	4a13      	ldr	r2, [pc, #76]	; (e584 <flash_map_add_new_dflt_areas+0x74>)
    e536:	eb02 0683 	add.w	r6, r2, r3, lsl #2
        if (flash_area_find_idx(dflt_area->fa_id) == -1) {
    e53a:	f812 0023 	ldrb.w	r0, [r2, r3, lsl #2]
    e53e:	f7ff ff9f 	bl	e480 <flash_area_find_idx>
    e542:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
    e546:	d1f0      	bne.n	e52a <flash_map_add_new_dflt_areas+0x1a>
            if (flash_map_entries >= MYNEWT_VAL(FLASH_MAP_MAX_AREAS)) {
    e548:	4b0f      	ldr	r3, [pc, #60]	; (e588 <flash_map_add_new_dflt_areas+0x78>)
    e54a:	681d      	ldr	r5, [r3, #0]
    e54c:	2d09      	cmp	r5, #9
    e54e:	dce2      	bgt.n	e516 <flash_map_add_new_dflt_areas+0x6>
                return;
            } 

            /* Add the default entry if it doesn't cause any overlaps. */
            if (flash_map_area_overlaps(dflt_area)) {
    e550:	4630      	mov	r0, r6
    e552:	f7ff ffb1 	bl	e4b8 <flash_map_area_overlaps>
    e556:	2800      	cmp	r0, #0
    e558:	d1e7      	bne.n	e52a <flash_map_add_new_dflt_areas+0x1a>
                DFLT_LOG_DEBUG("failed to add default flash area: "
                               "overlap: id=%d",
                               dflt_area->fa_id);
            } else {
                /* Cast away const. */
                dst_area = (struct flash_area *) &flash_map[flash_map_entries];
    e55a:	4b0c      	ldr	r3, [pc, #48]	; (e58c <flash_map_add_new_dflt_areas+0x7c>)
    e55c:	681b      	ldr	r3, [r3, #0]
    e55e:	eb05 0545 	add.w	r5, r5, r5, lsl #1
    e562:	eb03 0585 	add.w	r5, r3, r5, lsl #2

                *dst_area = *dflt_area;
    e566:	eb04 0344 	add.w	r3, r4, r4, lsl #1
    e56a:	4a06      	ldr	r2, [pc, #24]	; (e584 <flash_map_add_new_dflt_areas+0x74>)
    e56c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    e570:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
    e574:	e885 0007 	stmia.w	r5, {r0, r1, r2}
                flash_map_entries++;
    e578:	4a03      	ldr	r2, [pc, #12]	; (e588 <flash_map_add_new_dflt_areas+0x78>)
    e57a:	6813      	ldr	r3, [r2, #0]
    e57c:	3301      	adds	r3, #1
    e57e:	6013      	str	r3, [r2, #0]
    e580:	e7d3      	b.n	e52a <flash_map_add_new_dflt_areas+0x1a>
            }
        }
    }
}
    e582:	bd70      	pop	{r4, r5, r6, pc}
    e584:	00011a44 	.word	0x00011a44
    e588:	2000223c 	.word	0x2000223c
    e58c:	20002238 	.word	0x20002238

0000e590 <flash_map_init>:

void
flash_map_init(void)
{
    e590:	b510      	push	{r4, lr}
    e592:	b082      	sub	sp, #8
#endif

    int rc;

    /* Ensure this function only gets called by sysinit. */
    SYSINIT_ASSERT_ACTIVE();
    e594:	4b13      	ldr	r3, [pc, #76]	; (e5e4 <flash_map_init+0x54>)
    e596:	781b      	ldrb	r3, [r3, #0]
    e598:	b163      	cbz	r3, e5b4 <flash_map_init+0x24>

    rc = hal_flash_init();
    e59a:	f001 fb43 	bl	fc24 <hal_flash_init>
    SYSINIT_PANIC_ASSERT(rc == 0);
    e59e:	b998      	cbnz	r0, e5c8 <flash_map_init+0x38>
     *    In particular, a FLASH_AREA_BOOTLOADER entry is required for the boot
     *    MMR, as well as an entry for each extended MMR.
     * 2. If we fail to read the flash map from the MMRs, the system continues
     *    to use the default flash map.
     */
    flash_map = sysflash_map_dflt;
    e5a0:	4b11      	ldr	r3, [pc, #68]	; (e5e8 <flash_map_init+0x58>)
    e5a2:	4a12      	ldr	r2, [pc, #72]	; (e5ec <flash_map_init+0x5c>)
    e5a4:	601a      	str	r2, [r3, #0]
    flash_map_entries = sizeof sysflash_map_dflt / sizeof sysflash_map_dflt[0];
    e5a6:	4b12      	ldr	r3, [pc, #72]	; (e5f0 <flash_map_init+0x60>)
    e5a8:	2206      	movs	r2, #6
    e5aa:	601a      	str	r2, [r3, #0]

    /* The hardcoded flash map may contain new areas that aren't present in the
     * manufacturing flash map.  Try including them if they don't overlap with
     * any mfg areas.
     */
    flash_map_add_new_dflt_areas();
    e5ac:	f7ff ffb0 	bl	e510 <flash_map_add_new_dflt_areas>
}
    e5b0:	b002      	add	sp, #8
    e5b2:	bd10      	pop	{r4, pc}
    SYSINIT_ASSERT_ACTIVE();
    e5b4:	f7fd fdf2 	bl	c19c <hal_debugger_connected>
    e5b8:	b100      	cbz	r0, e5bc <flash_map_init+0x2c>
    e5ba:	be01      	bkpt	0x0001
    e5bc:	2300      	movs	r3, #0
    e5be:	461a      	mov	r2, r3
    e5c0:	4619      	mov	r1, r3
    e5c2:	4618      	mov	r0, r3
    e5c4:	f7fd ffc8 	bl	c558 <__assert_func>
    SYSINIT_PANIC_ASSERT(rc == 0);
    e5c8:	f7fd fde8 	bl	c19c <hal_debugger_connected>
    e5cc:	b100      	cbz	r0, e5d0 <flash_map_init+0x40>
    e5ce:	be01      	bkpt	0x0001
    e5d0:	2000      	movs	r0, #0
    e5d2:	9000      	str	r0, [sp, #0]
    e5d4:	4b07      	ldr	r3, [pc, #28]	; (e5f4 <flash_map_init+0x64>)
    e5d6:	681c      	ldr	r4, [r3, #0]
    e5d8:	4603      	mov	r3, r0
    e5da:	4602      	mov	r2, r0
    e5dc:	4601      	mov	r1, r0
    e5de:	47a0      	blx	r4
    e5e0:	e7de      	b.n	e5a0 <flash_map_init+0x10>
    e5e2:	bf00      	nop
    e5e4:	20002370 	.word	0x20002370
    e5e8:	20002238 	.word	0x20002238
    e5ec:	00011a44 	.word	0x00011a44
    e5f0:	2000223c 	.word	0x2000223c
    e5f4:	20000130 	.word	0x20000130

0000e5f8 <log_registered>:
static int
log_registered(struct log *log)
{
    struct log *cur;

    STAILQ_FOREACH(cur, &g_log_list, l_next) {
    e5f8:	4b05      	ldr	r3, [pc, #20]	; (e610 <log_registered+0x18>)
    e5fa:	681b      	ldr	r3, [r3, #0]
    e5fc:	b11b      	cbz	r3, e606 <log_registered+0xe>
        if (cur == log) {
    e5fe:	4283      	cmp	r3, r0
    e600:	d003      	beq.n	e60a <log_registered+0x12>
    STAILQ_FOREACH(cur, &g_log_list, l_next) {
    e602:	68db      	ldr	r3, [r3, #12]
    e604:	e7fa      	b.n	e5fc <log_registered+0x4>
            return 1;
        }
    }

    return 0;
    e606:	2000      	movs	r0, #0
    e608:	4770      	bx	lr
            return 1;
    e60a:	2001      	movs	r0, #1
}
    e60c:	4770      	bx	lr
    e60e:	bf00      	nop
    e610:	20000128 	.word	0x20000128

0000e614 <log_init>:
{
    e614:	b508      	push	{r3, lr}
    SYSINIT_ASSERT_ACTIVE();
    e616:	4b0d      	ldr	r3, [pc, #52]	; (e64c <log_init+0x38>)
    e618:	781b      	ldrb	r3, [r3, #0]
    e61a:	b163      	cbz	r3, e636 <log_init+0x22>
    log_written = 0;
    e61c:	2300      	movs	r3, #0
    e61e:	4a0c      	ldr	r2, [pc, #48]	; (e650 <log_init+0x3c>)
    e620:	7013      	strb	r3, [r2, #0]
    STAILQ_INIT(&g_log_list);
    e622:	4a0c      	ldr	r2, [pc, #48]	; (e654 <log_init+0x40>)
    e624:	6013      	str	r3, [r2, #0]
    e626:	6052      	str	r2, [r2, #4]
    g_log_info.li_version = MYNEWT_VAL(LOG_VERSION);
    e628:	4a0b      	ldr	r2, [pc, #44]	; (e658 <log_init+0x44>)
    e62a:	2103      	movs	r1, #3
    e62c:	7111      	strb	r1, [r2, #4]
    g_log_info.li_next_index = 0;
    e62e:	6013      	str	r3, [r2, #0]
    log_console_init();
    e630:	f000 f95a 	bl	e8e8 <log_console_init>
}
    e634:	bd08      	pop	{r3, pc}
    SYSINIT_ASSERT_ACTIVE();
    e636:	f7fd fdb1 	bl	c19c <hal_debugger_connected>
    e63a:	b100      	cbz	r0, e63e <log_init+0x2a>
    e63c:	be01      	bkpt	0x0001
    e63e:	2300      	movs	r3, #0
    e640:	461a      	mov	r2, r3
    e642:	4619      	mov	r1, r3
    e644:	4618      	mov	r0, r3
    e646:	f7fd ff87 	bl	c558 <__assert_func>
    e64a:	bf00      	nop
    e64c:	20002370 	.word	0x20002370
    e650:	20002248 	.word	0x20002248
    e654:	20000128 	.word	0x20000128
    e658:	20002240 	.word	0x20002240

0000e65c <log_hdr_len>:
}

uint16_t
log_hdr_len(const struct log_entry_hdr *hdr)
{
    if (hdr->ue_flags & LOG_FLAGS_IMG_HASH) {
    e65c:	7b83      	ldrb	r3, [r0, #14]
    e65e:	f013 0f10 	tst.w	r3, #16
    e662:	d101      	bne.n	e668 <log_hdr_len+0xc>
        return LOG_BASE_ENTRY_HDR_SIZE + LOG_IMG_HASHLEN;
    }

    return LOG_BASE_ENTRY_HDR_SIZE;
    e664:	200f      	movs	r0, #15
    e666:	4770      	bx	lr
        return LOG_BASE_ENTRY_HDR_SIZE + LOG_IMG_HASHLEN;
    e668:	2013      	movs	r0, #19
}
    e66a:	4770      	bx	lr

0000e66c <log_walk>:
}

int
log_walk(struct log *log, log_walk_func_t walk_func,
         struct log_offset *log_offset)
{
    e66c:	b508      	push	{r3, lr}
    int rc;

    rc = log->l_log->log_walk(log, walk_func, log_offset);
    e66e:	6843      	ldr	r3, [r0, #4]
    e670:	69db      	ldr	r3, [r3, #28]
    e672:	4798      	blx	r3
    }

    return (0);
err:
    return (rc);
}
    e674:	bd08      	pop	{r3, pc}
	...

0000e678 <log_read_last_hdr>:
{
    e678:	b530      	push	{r4, r5, lr}
    e67a:	b089      	sub	sp, #36	; 0x24
    arg.hdr = out_hdr;
    e67c:	9106      	str	r1, [sp, #24]
    arg.read_success = 0;
    e67e:	2300      	movs	r3, #0
    e680:	9307      	str	r3, [sp, #28]
    log_offset.lo_arg = &arg;
    e682:	aa06      	add	r2, sp, #24
    e684:	9204      	str	r2, [sp, #16]
    log_offset.lo_ts = -1;
    e686:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    e68a:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    e68e:	e9cd 4500 	strd	r4, r5, [sp]
    log_offset.lo_index = 0;
    e692:	9302      	str	r3, [sp, #8]
    log_offset.lo_data_len = 0;
    e694:	9303      	str	r3, [sp, #12]
    log_walk(log, log_read_hdr_walk, &log_offset);
    e696:	466a      	mov	r2, sp
    e698:	4905      	ldr	r1, [pc, #20]	; (e6b0 <log_read_last_hdr+0x38>)
    e69a:	f7ff ffe7 	bl	e66c <log_walk>
    if (!arg.read_success) {
    e69e:	9b07      	ldr	r3, [sp, #28]
    e6a0:	b113      	cbz	r3, e6a8 <log_read_last_hdr+0x30>
    return 0;
    e6a2:	2000      	movs	r0, #0
}
    e6a4:	b009      	add	sp, #36	; 0x24
    e6a6:	bd30      	pop	{r4, r5, pc}
        return -1;
    e6a8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    e6ac:	e7fa      	b.n	e6a4 <log_read_last_hdr+0x2c>
    e6ae:	bf00      	nop
    e6b0:	0000e7a9 	.word	0x0000e7a9

0000e6b4 <log_register>:
{
    e6b4:	b530      	push	{r4, r5, lr}
    e6b6:	b087      	sub	sp, #28
    e6b8:	460c      	mov	r4, r1
    e6ba:	f89d 1028 	ldrb.w	r1, [sp, #40]	; 0x28
    assert(!log_written);
    e6be:	4d2f      	ldr	r5, [pc, #188]	; (e77c <log_register+0xc8>)
    e6c0:	782d      	ldrb	r5, [r5, #0]
    e6c2:	bb25      	cbnz	r5, e70e <log_register+0x5a>
    if (level > LOG_LEVEL_MAX) {
    e6c4:	290f      	cmp	r1, #15
    e6c6:	d900      	bls.n	e6ca <log_register+0x16>
        level = LOG_LEVEL_MAX;
    e6c8:	210f      	movs	r1, #15
    log->l_name = name;
    e6ca:	6020      	str	r0, [r4, #0]
    log->l_log = lh;
    e6cc:	6062      	str	r2, [r4, #4]
    log->l_arg = arg;
    e6ce:	60a3      	str	r3, [r4, #8]
    log->l_level = level;
    e6d0:	7621      	strb	r1, [r4, #24]
    log->l_append_cb = NULL;
    e6d2:	2300      	movs	r3, #0
    e6d4:	6123      	str	r3, [r4, #16]
    log->l_max_entry_len = 0;
    e6d6:	8363      	strh	r3, [r4, #26]
    if (!log_registered(log)) {
    e6d8:	4620      	mov	r0, r4
    e6da:	f7ff ff8d 	bl	e5f8 <log_registered>
    e6de:	b938      	cbnz	r0, e6f0 <log_register+0x3c>
        STAILQ_INSERT_TAIL(&g_log_list, log, l_next);
    e6e0:	2300      	movs	r3, #0
    e6e2:	60e3      	str	r3, [r4, #12]
    e6e4:	4b26      	ldr	r3, [pc, #152]	; (e780 <log_register+0xcc>)
    e6e6:	685a      	ldr	r2, [r3, #4]
    e6e8:	6014      	str	r4, [r2, #0]
    e6ea:	f104 020c 	add.w	r2, r4, #12
    e6ee:	605a      	str	r2, [r3, #4]
    if (log->l_log->log_registered) {
    e6f0:	6863      	ldr	r3, [r4, #4]
    e6f2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    e6f4:	b11b      	cbz	r3, e6fe <log_register+0x4a>
        rc = log->l_log->log_registered(log);
    e6f6:	4620      	mov	r0, r4
    e6f8:	4798      	blx	r3
        if (rc) {
    e6fa:	4605      	mov	r5, r0
    e6fc:	b988      	cbnz	r0, e722 <log_register+0x6e>
    if (log->l_log->log_type == LOG_TYPE_STORAGE) {
    e6fe:	6863      	ldr	r3, [r4, #4]
    e700:	681b      	ldr	r3, [r3, #0]
    e702:	2b02      	cmp	r3, #2
    e704:	d024      	beq.n	e750 <log_register+0x9c>
    return (0);
    e706:	2500      	movs	r5, #0
}
    e708:	4628      	mov	r0, r5
    e70a:	b007      	add	sp, #28
    e70c:	bd30      	pop	{r4, r5, pc}
    assert(!log_written);
    e70e:	f7fd fd45 	bl	c19c <hal_debugger_connected>
    e712:	b100      	cbz	r0, e716 <log_register+0x62>
    e714:	be01      	bkpt	0x0001
    e716:	2300      	movs	r3, #0
    e718:	461a      	mov	r2, r3
    e71a:	4619      	mov	r1, r3
    e71c:	4618      	mov	r0, r3
    e71e:	f7fd ff1b 	bl	c558 <__assert_func>
            STAILQ_REMOVE(&g_log_list, log, log, l_next);
    e722:	4b17      	ldr	r3, [pc, #92]	; (e780 <log_register+0xcc>)
    e724:	681b      	ldr	r3, [r3, #0]
    e726:	42a3      	cmp	r3, r4
    e728:	d00b      	beq.n	e742 <log_register+0x8e>
    e72a:	461a      	mov	r2, r3
    e72c:	68db      	ldr	r3, [r3, #12]
    e72e:	42a3      	cmp	r3, r4
    e730:	d1fb      	bne.n	e72a <log_register+0x76>
    e732:	68db      	ldr	r3, [r3, #12]
    e734:	60d3      	str	r3, [r2, #12]
    e736:	2b00      	cmp	r3, #0
    e738:	d1e6      	bne.n	e708 <log_register+0x54>
    e73a:	320c      	adds	r2, #12
    e73c:	4b10      	ldr	r3, [pc, #64]	; (e780 <log_register+0xcc>)
    e73e:	605a      	str	r2, [r3, #4]
            return rc;
    e740:	e7e2      	b.n	e708 <log_register+0x54>
            STAILQ_REMOVE(&g_log_list, log, log, l_next);
    e742:	68db      	ldr	r3, [r3, #12]
    e744:	4a0e      	ldr	r2, [pc, #56]	; (e780 <log_register+0xcc>)
    e746:	6013      	str	r3, [r2, #0]
    e748:	2b00      	cmp	r3, #0
    e74a:	d1dd      	bne.n	e708 <log_register+0x54>
    e74c:	6052      	str	r2, [r2, #4]
    e74e:	e7db      	b.n	e708 <log_register+0x54>
        rc = log_read_last_hdr(log, &hdr);
    e750:	a901      	add	r1, sp, #4
    e752:	4620      	mov	r0, r4
    e754:	f7ff ff90 	bl	e678 <log_read_last_hdr>
        if (rc == 0) {
    e758:	4605      	mov	r5, r0
    e75a:	b108      	cbz	r0, e760 <log_register+0xac>
    return (0);
    e75c:	2500      	movs	r5, #0
    e75e:	e7d3      	b.n	e708 <log_register+0x54>
            OS_ENTER_CRITICAL(sr);
    e760:	f7fe feb2 	bl	d4c8 <os_arch_save_sr>
            if (hdr.ue_index >= g_log_info.li_next_index) {
    e764:	9b03      	ldr	r3, [sp, #12]
    e766:	4a07      	ldr	r2, [pc, #28]	; (e784 <log_register+0xd0>)
    e768:	6812      	ldr	r2, [r2, #0]
    e76a:	4293      	cmp	r3, r2
    e76c:	d302      	bcc.n	e774 <log_register+0xc0>
                g_log_info.li_next_index = hdr.ue_index + 1;
    e76e:	3301      	adds	r3, #1
    e770:	4a04      	ldr	r2, [pc, #16]	; (e784 <log_register+0xd0>)
    e772:	6013      	str	r3, [r2, #0]
            OS_EXIT_CRITICAL(sr);
    e774:	f7fe feae 	bl	d4d4 <os_arch_restore_sr>
    e778:	e7c6      	b.n	e708 <log_register+0x54>
    e77a:	bf00      	nop
    e77c:	20002248 	.word	0x20002248
    e780:	20000128 	.word	0x20000128
    e784:	20002240 	.word	0x20002240

0000e788 <log_read>:
 * @return                      The number of bytes read; 0 on failure.
 */
int
log_read(struct log *log, const void *dptr, void *buf, uint16_t off,
         uint16_t len)
{
    e788:	b530      	push	{r4, r5, lr}
    e78a:	b083      	sub	sp, #12
    int rc;

    rc = log->l_log->log_read(log, dptr, buf, off, len);
    e78c:	6844      	ldr	r4, [r0, #4]
    e78e:	6864      	ldr	r4, [r4, #4]
    e790:	f8bd 5018 	ldrh.w	r5, [sp, #24]
    e794:	9500      	str	r5, [sp, #0]
    e796:	47a0      	blx	r4

    return (rc);
}
    e798:	b003      	add	sp, #12
    e79a:	bd30      	pop	{r4, r5, pc}

0000e79c <log_fill_current_img_hash>:
    hdr->ue_flags |= LOG_FLAGS_IMG_HASH;

    /* We have to account for LOG_IMG_HASHLEN bytes of hash */
    return imgr_get_current_hash(hdr->ue_imghash, LOG_IMG_HASHLEN);
#endif
    memset(hdr->ue_imghash, 0, LOG_IMG_HASHLEN);
    e79c:	2300      	movs	r3, #0
    e79e:	f8c0 300f 	str.w	r3, [r0, #15]

    return SYS_ENOTSUP;
}
    e7a2:	f06f 000b 	mvn.w	r0, #11
    e7a6:	4770      	bx	lr

0000e7a8 <log_read_hdr_walk>:
{
    e7a8:	b510      	push	{r4, lr}
    e7aa:	b082      	sub	sp, #8
    e7ac:	460b      	mov	r3, r1
    e7ae:	4611      	mov	r1, r2
    arg = log_offset->lo_arg;
    e7b0:	691c      	ldr	r4, [r3, #16]
    rc = log_read(log, dptr, arg->hdr, 0, LOG_BASE_ENTRY_HDR_SIZE);
    e7b2:	6822      	ldr	r2, [r4, #0]
    e7b4:	230f      	movs	r3, #15
    e7b6:	9300      	str	r3, [sp, #0]
    e7b8:	2300      	movs	r3, #0
    e7ba:	f7ff ffe5 	bl	e788 <log_read>
    if (rc >= LOG_BASE_ENTRY_HDR_SIZE) {
    e7be:	280e      	cmp	r0, #14
    e7c0:	dd01      	ble.n	e7c6 <log_read_hdr_walk+0x1e>
        arg->read_success = 1;
    e7c2:	2301      	movs	r3, #1
    e7c4:	6063      	str	r3, [r4, #4]
    if (arg->hdr->ue_flags & LOG_FLAGS_IMG_HASH) {
    e7c6:	6820      	ldr	r0, [r4, #0]
    e7c8:	7b83      	ldrb	r3, [r0, #14]
    e7ca:	f013 0f10 	tst.w	r3, #16
    e7ce:	d102      	bne.n	e7d6 <log_read_hdr_walk+0x2e>
}
    e7d0:	2001      	movs	r0, #1
    e7d2:	b002      	add	sp, #8
    e7d4:	bd10      	pop	{r4, pc}
        rc = log_fill_current_img_hash(arg->hdr);
    e7d6:	f7ff ffe1 	bl	e79c <log_fill_current_img_hash>
        if (!rc || rc == SYS_ENOTSUP) {
    e7da:	b110      	cbz	r0, e7e2 <log_read_hdr_walk+0x3a>
    e7dc:	f110 0f0c 	cmn.w	r0, #12
    e7e0:	d1f6      	bne.n	e7d0 <log_read_hdr_walk+0x28>
            arg->read_success = 1;
    e7e2:	2301      	movs	r3, #1
    e7e4:	6063      	str	r3, [r4, #4]
    e7e6:	e7f3      	b.n	e7d0 <log_read_hdr_walk+0x28>

0000e7e8 <log_console_read>:
log_console_read(struct log *log, const void *dptr, void *buf, uint16_t offset,
        uint16_t len)
{
    /* You don't read console, console read you */
    return (OS_EINVAL);
}
    e7e8:	2002      	movs	r0, #2
    e7ea:	4770      	bx	lr

0000e7ec <log_console_walk>:
log_console_walk(struct log *log, log_walk_func_t walk_func,
        struct log_offset *log_offset)
{
    /* You don't walk console, console walk you. */
    return (OS_EINVAL);
}
    e7ec:	2002      	movs	r0, #2
    e7ee:	4770      	bx	lr

0000e7f0 <log_console_flush>:
static int
log_console_flush(struct log *log)
{
    /* You don't flush console, console flush you. */
    return (OS_EINVAL);
}
    e7f0:	2002      	movs	r0, #2
    e7f2:	4770      	bx	lr

0000e7f4 <log_console_print_hdr>:
{
    e7f4:	b510      	push	{r4, lr}
    e7f6:	b082      	sub	sp, #8
    e7f8:	4604      	mov	r4, r0
                   hdr->ue_ts, hdr->ue_module, hdr->ue_level);
    e7fa:	7b03      	ldrb	r3, [r0, #12]
    e7fc:	7b42      	ldrb	r2, [r0, #13]
    console_printf("[ts=%lluus, mod=%u level=%u ",
    e7fe:	9201      	str	r2, [sp, #4]
    e800:	9300      	str	r3, [sp, #0]
    e802:	6802      	ldr	r2, [r0, #0]
    e804:	6843      	ldr	r3, [r0, #4]
    e806:	480a      	ldr	r0, [pc, #40]	; (e830 <log_console_print_hdr+0x3c>)
    e808:	f7ff fcc4 	bl	e194 <console_printf>
    if (hdr->ue_flags & LOG_FLAGS_IMG_HASH) {
    e80c:	7ba3      	ldrb	r3, [r4, #14]
    e80e:	f013 0f10 	tst.w	r3, #16
    e812:	d104      	bne.n	e81e <log_console_print_hdr+0x2a>
    console_printf("]");
    e814:	4807      	ldr	r0, [pc, #28]	; (e834 <log_console_print_hdr+0x40>)
    e816:	f7ff fcbd 	bl	e194 <console_printf>
}
    e81a:	b002      	add	sp, #8
    e81c:	bd10      	pop	{r4, pc}
                       hdr->ue_imghash[2], hdr->ue_imghash[3]);
    e81e:	7ca3      	ldrb	r3, [r4, #18]
        console_printf("ih=0x%x%x%x%x", hdr->ue_imghash[0], hdr->ue_imghash[1],
    e820:	9300      	str	r3, [sp, #0]
    e822:	7c63      	ldrb	r3, [r4, #17]
    e824:	7c22      	ldrb	r2, [r4, #16]
    e826:	7be1      	ldrb	r1, [r4, #15]
    e828:	4803      	ldr	r0, [pc, #12]	; (e838 <log_console_print_hdr+0x44>)
    e82a:	f7ff fcb3 	bl	e194 <console_printf>
    e82e:	e7f1      	b.n	e814 <log_console_print_hdr+0x20>
    e830:	000119c8 	.word	0x000119c8
    e834:	000119f8 	.word	0x000119f8
    e838:	000119e8 	.word	0x000119e8

0000e83c <log_console_dump_cbor_entry>:
{
    e83c:	b530      	push	{r4, r5, lr}
    e83e:	b095      	sub	sp, #84	; 0x54
    e840:	460a      	mov	r2, r1
    cbor_buf_reader_init(&cbor_buf_reader, dptr, len);
    e842:	4601      	mov	r1, r0
    e844:	a805      	add	r0, sp, #20
    e846:	f000 fa65 	bl	ed14 <cbor_buf_reader_init>
    cbor_parser_init(&cbor_buf_reader.r, 0, &cbor_parser, &cbor_value);
    e84a:	ad0d      	add	r5, sp, #52	; 0x34
    e84c:	462b      	mov	r3, r5
    e84e:	aa11      	add	r2, sp, #68	; 0x44
    e850:	2100      	movs	r1, #0
    e852:	a805      	add	r0, sp, #20
    e854:	f000 fd2a 	bl	f2ac <cbor_parser_init>

/* Human-readable (dump) API */
CBOR_API CborError cbor_value_to_pretty_advance(FILE *out, CborValue *value);
CBOR_INLINE_API CborError cbor_value_to_pretty(FILE *out, const CborValue *value)
{
    CborValue copy = *value;
    e858:	ac01      	add	r4, sp, #4
    e85a:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
    e85e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    return cbor_value_to_pretty_advance(out, &copy);
    e862:	4621      	mov	r1, r4
    e864:	4b05      	ldr	r3, [pc, #20]	; (e87c <log_console_dump_cbor_entry+0x40>)
    e866:	6818      	ldr	r0, [r3, #0]
    e868:	f001 f98a 	bl	fb80 <cbor_value_to_pretty_advance>
    console_write("\n", 1);
    e86c:	2101      	movs	r1, #1
    e86e:	4804      	ldr	r0, [pc, #16]	; (e880 <log_console_dump_cbor_entry+0x44>)
    e870:	f7ff fb3a 	bl	dee8 <console_write>
}
    e874:	2000      	movs	r0, #0
    e876:	b015      	add	sp, #84	; 0x54
    e878:	bd30      	pop	{r4, r5, pc}
    e87a:	bf00      	nop
    e87c:	00011b9c 	.word	0x00011b9c
    e880:	0001182c 	.word	0x0001182c

0000e884 <log_console_append_body>:
{
    e884:	b570      	push	{r4, r5, r6, lr}
    e886:	460c      	mov	r4, r1
    e888:	4616      	mov	r6, r2
    e88a:	461d      	mov	r5, r3
    if (!console_is_init()) {
    e88c:	f7ff fc30 	bl	e0f0 <console_is_init>
    e890:	b158      	cbz	r0, e8aa <log_console_append_body+0x26>
    if (!console_is_midline) {
    e892:	4b0b      	ldr	r3, [pc, #44]	; (e8c0 <log_console_append_body+0x3c>)
    e894:	681b      	ldr	r3, [r3, #0]
    e896:	b153      	cbz	r3, e8ae <log_console_append_body+0x2a>
    if (hdr->ue_etype != LOG_ETYPE_CBOR) {
    e898:	7ba3      	ldrb	r3, [r4, #14]
    e89a:	f003 030f 	and.w	r3, r3, #15
    e89e:	2b01      	cmp	r3, #1
    e8a0:	d009      	beq.n	e8b6 <log_console_append_body+0x32>
        console_write(body, body_len);
    e8a2:	4629      	mov	r1, r5
    e8a4:	4630      	mov	r0, r6
    e8a6:	f7ff fb1f 	bl	dee8 <console_write>
}
    e8aa:	2000      	movs	r0, #0
    e8ac:	bd70      	pop	{r4, r5, r6, pc}
        log_console_print_hdr(hdr);
    e8ae:	4620      	mov	r0, r4
    e8b0:	f7ff ffa0 	bl	e7f4 <log_console_print_hdr>
    e8b4:	e7f0      	b.n	e898 <log_console_append_body+0x14>
        log_console_dump_cbor_entry(body, body_len);
    e8b6:	b2a9      	uxth	r1, r5
    e8b8:	4630      	mov	r0, r6
    e8ba:	f7ff ffbf 	bl	e83c <log_console_dump_cbor_entry>
    e8be:	e7f4      	b.n	e8aa <log_console_append_body+0x26>
    e8c0:	200021a0 	.word	0x200021a0

0000e8c4 <log_console_append>:
{
    e8c4:	b570      	push	{r4, r5, r6, lr}
    e8c6:	4605      	mov	r5, r0
    e8c8:	460c      	mov	r4, r1
    e8ca:	4616      	mov	r6, r2
    hdr_len = log_hdr_len(buf);
    e8cc:	4608      	mov	r0, r1
    e8ce:	f7ff fec5 	bl	e65c <log_hdr_len>
    return log_console_append_body(log, buf, (uint8_t *)buf + hdr_len,
    e8d2:	1a33      	subs	r3, r6, r0
    e8d4:	1822      	adds	r2, r4, r0
    e8d6:	4621      	mov	r1, r4
    e8d8:	4628      	mov	r0, r5
    e8da:	f7ff ffd3 	bl	e884 <log_console_append_body>
}
    e8de:	bd70      	pop	{r4, r5, r6, pc}

0000e8e0 <log_console_get>:
}
    e8e0:	4800      	ldr	r0, [pc, #0]	; (e8e4 <log_console_get+0x4>)
    e8e2:	4770      	bx	lr
    e8e4:	2000224c 	.word	0x2000224c

0000e8e8 <log_console_init>:
    .log_flush = log_console_flush,
};

void
log_console_init(void)
{
    e8e8:	b510      	push	{r4, lr}
    e8ea:	b082      	sub	sp, #8
    int rc;

    /* Ensure this function only gets called by sysinit. */
    SYSINIT_ASSERT_ACTIVE();
    e8ec:	4b11      	ldr	r3, [pc, #68]	; (e934 <log_console_init+0x4c>)
    e8ee:	781b      	ldrb	r3, [r3, #0]
    e8f0:	b14b      	cbz	r3, e906 <log_console_init+0x1e>

    rc = log_register("console", &log_console, &log_console_handler, NULL,
    e8f2:	2300      	movs	r3, #0
    e8f4:	9300      	str	r3, [sp, #0]
    e8f6:	4a10      	ldr	r2, [pc, #64]	; (e938 <log_console_init+0x50>)
    e8f8:	4910      	ldr	r1, [pc, #64]	; (e93c <log_console_init+0x54>)
    e8fa:	4811      	ldr	r0, [pc, #68]	; (e940 <log_console_init+0x58>)
    e8fc:	f7ff feda 	bl	e6b4 <log_register>
                      MYNEWT_VAL(LOG_LEVEL));
    SYSINIT_PANIC_ASSERT(rc == 0);
    e900:	b958      	cbnz	r0, e91a <log_console_init+0x32>
}
    e902:	b002      	add	sp, #8
    e904:	bd10      	pop	{r4, pc}
    SYSINIT_ASSERT_ACTIVE();
    e906:	f7fd fc49 	bl	c19c <hal_debugger_connected>
    e90a:	b100      	cbz	r0, e90e <log_console_init+0x26>
    e90c:	be01      	bkpt	0x0001
    e90e:	2300      	movs	r3, #0
    e910:	461a      	mov	r2, r3
    e912:	4619      	mov	r1, r3
    e914:	4618      	mov	r0, r3
    e916:	f7fd fe1f 	bl	c558 <__assert_func>
    SYSINIT_PANIC_ASSERT(rc == 0);
    e91a:	f7fd fc3f 	bl	c19c <hal_debugger_connected>
    e91e:	b100      	cbz	r0, e922 <log_console_init+0x3a>
    e920:	be01      	bkpt	0x0001
    e922:	2000      	movs	r0, #0
    e924:	9000      	str	r0, [sp, #0]
    e926:	4b07      	ldr	r3, [pc, #28]	; (e944 <log_console_init+0x5c>)
    e928:	681c      	ldr	r4, [r3, #0]
    e92a:	4603      	mov	r3, r0
    e92c:	4602      	mov	r2, r0
    e92e:	4601      	mov	r1, r0
    e930:	47a0      	blx	r4
}
    e932:	e7e6      	b.n	e902 <log_console_init+0x1a>
    e934:	20002370 	.word	0x20002370
    e938:	00011a04 	.word	0x00011a04
    e93c:	2000224c 	.word	0x2000224c
    e940:	000119fc 	.word	0x000119fc
    e944:	20000130 	.word	0x20000130

0000e948 <modlog_find_by_module>:
    return cur;
}

static struct modlog_mapping *
modlog_find_by_module(uint8_t module, struct modlog_mapping **out_prev)
{
    e948:	b410      	push	{r4}
    e94a:	4602      	mov	r2, r0
    struct modlog_mapping *prev;
    struct modlog_mapping *cur;

    prev = NULL;
    SLIST_FOREACH(cur, &modlog_mappings, next) {
    e94c:	4b07      	ldr	r3, [pc, #28]	; (e96c <modlog_find_by_module+0x24>)
    e94e:	6818      	ldr	r0, [r3, #0]
    prev = NULL;
    e950:	2400      	movs	r4, #0
    SLIST_FOREACH(cur, &modlog_mappings, next) {
    e952:	e001      	b.n	e958 <modlog_find_by_module+0x10>
        if (cur->desc.module > module) {
            cur = NULL;
            break;
        }

        prev = cur;
    e954:	4604      	mov	r4, r0
    SLIST_FOREACH(cur, &modlog_mappings, next) {
    e956:	6800      	ldr	r0, [r0, #0]
    e958:	b120      	cbz	r0, e964 <modlog_find_by_module+0x1c>
        if (cur->desc.module == module) {
    e95a:	7a43      	ldrb	r3, [r0, #9]
    e95c:	4293      	cmp	r3, r2
    e95e:	d001      	beq.n	e964 <modlog_find_by_module+0x1c>
        if (cur->desc.module > module) {
    e960:	d9f8      	bls.n	e954 <modlog_find_by_module+0xc>
            cur = NULL;
    e962:	2000      	movs	r0, #0
    }

    if (out_prev != NULL) {
    e964:	b101      	cbz	r1, e968 <modlog_find_by_module+0x20>
        *out_prev = prev;
    e966:	600c      	str	r4, [r1, #0]
    }

    return cur;
}
    e968:	bc10      	pop	{r4}
    e96a:	4770      	bx	lr
    e96c:	20002348 	.word	0x20002348

0000e970 <modlog_insert>:

static void
modlog_insert(struct modlog_mapping *mm)
{
    e970:	b510      	push	{r4, lr}
    e972:	b082      	sub	sp, #8
    e974:	4604      	mov	r4, r0
    struct modlog_mapping *prev;

    modlog_find_by_module(mm->desc.module, &prev);
    e976:	a901      	add	r1, sp, #4
    e978:	7a40      	ldrb	r0, [r0, #9]
    e97a:	f7ff ffe5 	bl	e948 <modlog_find_by_module>
    if (prev == NULL) {
    e97e:	9b01      	ldr	r3, [sp, #4]
    e980:	b143      	cbz	r3, e994 <modlog_insert+0x24>
        SLIST_INSERT_HEAD(&modlog_mappings, mm, next);
    } else {
        SLIST_INSERT_AFTER(prev, mm, next);
    e982:	681b      	ldr	r3, [r3, #0]
    e984:	6023      	str	r3, [r4, #0]
    e986:	9b01      	ldr	r3, [sp, #4]
    e988:	601c      	str	r4, [r3, #0]
    }

    if (mm->desc.module == MODLOG_MODULE_DFLT) {
    e98a:	7a63      	ldrb	r3, [r4, #9]
    e98c:	2bff      	cmp	r3, #255	; 0xff
    e98e:	d006      	beq.n	e99e <modlog_insert+0x2e>
        modlog_first_dflt = mm;
    }
}
    e990:	b002      	add	sp, #8
    e992:	bd10      	pop	{r4, pc}
        SLIST_INSERT_HEAD(&modlog_mappings, mm, next);
    e994:	4b03      	ldr	r3, [pc, #12]	; (e9a4 <modlog_insert+0x34>)
    e996:	681a      	ldr	r2, [r3, #0]
    e998:	6022      	str	r2, [r4, #0]
    e99a:	601c      	str	r4, [r3, #0]
    e99c:	e7f5      	b.n	e98a <modlog_insert+0x1a>
        modlog_first_dflt = mm;
    e99e:	4b02      	ldr	r3, [pc, #8]	; (e9a8 <modlog_insert+0x38>)
    e9a0:	601c      	str	r4, [r3, #0]
}
    e9a2:	e7f5      	b.n	e990 <modlog_insert+0x20>
    e9a4:	20002348 	.word	0x20002348
    e9a8:	20002268 	.word	0x20002268

0000e9ac <modlog_alloc>:
{
    e9ac:	b508      	push	{r3, lr}
    mm = os_memblock_get(&modlog_mapping_pool);
    e9ae:	4805      	ldr	r0, [pc, #20]	; (e9c4 <modlog_alloc+0x18>)
    e9b0:	f7fe f928 	bl	cc04 <os_memblock_get>
    if (mm != NULL) {
    e9b4:	4603      	mov	r3, r0
    e9b6:	b118      	cbz	r0, e9c0 <modlog_alloc+0x14>
        *mm = (struct modlog_mapping) { 0 };
    e9b8:	2200      	movs	r2, #0
    e9ba:	6002      	str	r2, [r0, #0]
    e9bc:	6042      	str	r2, [r0, #4]
    e9be:	6082      	str	r2, [r0, #8]
}
    e9c0:	4618      	mov	r0, r3
    e9c2:	bd08      	pop	{r3, pc}
    e9c4:	2000232c 	.word	0x2000232c

0000e9c8 <modlog_infer_handle>:
{
    e9c8:	b508      	push	{r3, lr}
    off = (uintptr_t)mm - (uintptr_t)modlog_mapping_buf;
    e9ca:	4a13      	ldr	r2, [pc, #76]	; (ea18 <modlog_infer_handle+0x50>)
    e9cc:	1a82      	subs	r2, r0, r2
    idx = off / elem_sz;
    e9ce:	4813      	ldr	r0, [pc, #76]	; (ea1c <modlog_infer_handle+0x54>)
    e9d0:	fba0 3002 	umull	r3, r0, r0, r2
    assert(idx >= 0 && idx < MYNEWT_VAL(MODLOG_MAX_MAPPINGS));
    e9d4:	2abf      	cmp	r2, #191	; 0xbf
    e9d6:	d80b      	bhi.n	e9f0 <modlog_infer_handle+0x28>
    e9d8:	08c0      	lsrs	r0, r0, #3
    assert(off % elem_sz == 0);
    e9da:	4b10      	ldr	r3, [pc, #64]	; (ea1c <modlog_infer_handle+0x54>)
    e9dc:	fba3 1302 	umull	r1, r3, r3, r2
    e9e0:	08db      	lsrs	r3, r3, #3
    e9e2:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    e9e6:	ebb2 0f83 	cmp.w	r2, r3, lsl #2
    e9ea:	d10b      	bne.n	ea04 <modlog_infer_handle+0x3c>
}
    e9ec:	b2c0      	uxtb	r0, r0
    e9ee:	bd08      	pop	{r3, pc}
    assert(idx >= 0 && idx < MYNEWT_VAL(MODLOG_MAX_MAPPINGS));
    e9f0:	f7fd fbd4 	bl	c19c <hal_debugger_connected>
    e9f4:	b100      	cbz	r0, e9f8 <modlog_infer_handle+0x30>
    e9f6:	be01      	bkpt	0x0001
    e9f8:	2300      	movs	r3, #0
    e9fa:	461a      	mov	r2, r3
    e9fc:	4619      	mov	r1, r3
    e9fe:	4618      	mov	r0, r3
    ea00:	f7fd fdaa 	bl	c558 <__assert_func>
    assert(off % elem_sz == 0);
    ea04:	f7fd fbca 	bl	c19c <hal_debugger_connected>
    ea08:	b100      	cbz	r0, ea0c <modlog_infer_handle+0x44>
    ea0a:	be01      	bkpt	0x0001
    ea0c:	2300      	movs	r3, #0
    ea0e:	461a      	mov	r2, r3
    ea10:	4619      	mov	r1, r3
    ea12:	4618      	mov	r0, r3
    ea14:	f7fd fda0 	bl	c558 <__assert_func>
    ea18:	2000226c 	.word	0x2000226c
    ea1c:	aaaaaaab 	.word	0xaaaaaaab

0000ea20 <modlog_register_no_lock>:
modlog_register_no_lock(uint8_t module, struct log *log, uint8_t min_level,
                        uint8_t *out_handle)
{
    struct modlog_mapping *mm;

    if (log == NULL) {
    ea20:	b1c9      	cbz	r1, ea56 <modlog_register_no_lock+0x36>
{
    ea22:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    ea26:	4607      	mov	r7, r0
    ea28:	4616      	mov	r6, r2
    ea2a:	461d      	mov	r5, r3
    ea2c:	4688      	mov	r8, r1
        return SYS_EINVAL;
    }

    mm = modlog_alloc();
    ea2e:	f7ff ffbd 	bl	e9ac <modlog_alloc>
    if (mm == NULL) {
    ea32:	4604      	mov	r4, r0
    ea34:	b190      	cbz	r0, ea5c <modlog_register_no_lock+0x3c>
        return SYS_ENOMEM;
    }

    mm->desc = (struct modlog_desc) {
        .log = log,
        .handle = modlog_infer_handle(mm),
    ea36:	f7ff ffc7 	bl	e9c8 <modlog_infer_handle>
    mm->desc = (struct modlog_desc) {
    ea3a:	f8c4 8004 	str.w	r8, [r4, #4]
    ea3e:	7220      	strb	r0, [r4, #8]
    ea40:	7267      	strb	r7, [r4, #9]
    ea42:	72a6      	strb	r6, [r4, #10]
        .module = module,
        .min_level = min_level,
    };

    modlog_insert(mm);
    ea44:	4620      	mov	r0, r4
    ea46:	f7ff ff93 	bl	e970 <modlog_insert>

    if (out_handle != NULL) {
    ea4a:	b155      	cbz	r5, ea62 <modlog_register_no_lock+0x42>
        *out_handle = mm->desc.handle;
    ea4c:	7a23      	ldrb	r3, [r4, #8]
    ea4e:	702b      	strb	r3, [r5, #0]
    }

    return 0;
    ea50:	2000      	movs	r0, #0
}
    ea52:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return SYS_EINVAL;
    ea56:	f06f 0001 	mvn.w	r0, #1
}
    ea5a:	4770      	bx	lr
        return SYS_ENOMEM;
    ea5c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    ea60:	e7f7      	b.n	ea52 <modlog_register_no_lock+0x32>
    return 0;
    ea62:	2000      	movs	r0, #0
    ea64:	e7f5      	b.n	ea52 <modlog_register_no_lock+0x32>
	...

0000ea68 <modlog_register>:
}

int
modlog_register(uint8_t module, struct log *log, uint8_t min_level,
                uint8_t *out_handle)
{
    ea68:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    ea6c:	4604      	mov	r4, r0
    ea6e:	460d      	mov	r5, r1
    ea70:	4616      	mov	r6, r2
    ea72:	461f      	mov	r7, r3
    int rc;

    rwlock_acquire_write(&modlog_rwl);
    ea74:	f8df 8020 	ldr.w	r8, [pc, #32]	; ea98 <modlog_register+0x30>
    ea78:	4640      	mov	r0, r8
    ea7a:	f000 f8c9 	bl	ec10 <rwlock_acquire_write>
    rc = modlog_register_no_lock(module, log, min_level, out_handle);
    ea7e:	463b      	mov	r3, r7
    ea80:	4632      	mov	r2, r6
    ea82:	4629      	mov	r1, r5
    ea84:	4620      	mov	r0, r4
    ea86:	f7ff ffcb 	bl	ea20 <modlog_register_no_lock>
    ea8a:	4604      	mov	r4, r0
    rwlock_release_write(&modlog_rwl);
    ea8c:	4640      	mov	r0, r8
    ea8e:	f000 f8e9 	bl	ec64 <rwlock_release_write>

    return rc;
}
    ea92:	4620      	mov	r0, r4
    ea94:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ea98:	2000234c 	.word	0x2000234c

0000ea9c <modlog_init>:
    modlog_append(module, level, LOG_ETYPE_STRING, buf, len);
}

void
modlog_init(void)
{
    ea9c:	b510      	push	{r4, lr}
    ea9e:	b082      	sub	sp, #8
    int rc;

    SYSINIT_ASSERT_ACTIVE();
    eaa0:	4b28      	ldr	r3, [pc, #160]	; (eb44 <modlog_init+0xa8>)
    eaa2:	781b      	ldrb	r3, [r3, #0]
    eaa4:	b1e3      	cbz	r3, eae0 <modlog_init+0x44>

    rc = os_mempool_init(&modlog_mapping_pool, MYNEWT_VAL(MODLOG_MAX_MAPPINGS),
    eaa6:	4b28      	ldr	r3, [pc, #160]	; (eb48 <modlog_init+0xac>)
    eaa8:	9300      	str	r3, [sp, #0]
    eaaa:	4b28      	ldr	r3, [pc, #160]	; (eb4c <modlog_init+0xb0>)
    eaac:	220c      	movs	r2, #12
    eaae:	2110      	movs	r1, #16
    eab0:	4827      	ldr	r0, [pc, #156]	; (eb50 <modlog_init+0xb4>)
    eab2:	f7fe f89d 	bl	cbf0 <os_mempool_init>
                         sizeof (struct modlog_mapping), modlog_mapping_buf,
                         "modlog_mapping_pool");
    SYSINIT_PANIC_ASSERT(rc == 0);
    eab6:	b9e8      	cbnz	r0, eaf4 <modlog_init+0x58>

    SLIST_INIT(&modlog_mappings);
    eab8:	2300      	movs	r3, #0
    eaba:	4a26      	ldr	r2, [pc, #152]	; (eb54 <modlog_init+0xb8>)
    eabc:	6013      	str	r3, [r2, #0]
    modlog_first_dflt = NULL;
    eabe:	4a26      	ldr	r2, [pc, #152]	; (eb58 <modlog_init+0xbc>)
    eac0:	6013      	str	r3, [r2, #0]

    rc = rwlock_init(&modlog_rwl);
    eac2:	4826      	ldr	r0, [pc, #152]	; (eb5c <modlog_init+0xc0>)
    eac4:	f000 f8dd 	bl	ec82 <rwlock_init>
    SYSINIT_PANIC_ASSERT(rc == 0);
    eac8:	bb08      	cbnz	r0, eb0e <modlog_init+0x72>

    /* Register the default console mapping if configured. */
#if MYNEWT_VAL(MODLOG_CONSOLE_DFLT)
    rc = modlog_register(MODLOG_MODULE_DFLT, log_console_get(),
    eaca:	f7ff ff09 	bl	e8e0 <log_console_get>
    eace:	4601      	mov	r1, r0
    ead0:	2300      	movs	r3, #0
    ead2:	461a      	mov	r2, r3
    ead4:	20ff      	movs	r0, #255	; 0xff
    ead6:	f7ff ffc7 	bl	ea68 <modlog_register>
                         LOG_LEVEL_DEBUG, NULL);
    SYSINIT_PANIC_ASSERT(rc == 0);
    eada:	bb28      	cbnz	r0, eb28 <modlog_init+0x8c>
#endif
}
    eadc:	b002      	add	sp, #8
    eade:	bd10      	pop	{r4, pc}
    SYSINIT_ASSERT_ACTIVE();
    eae0:	f7fd fb5c 	bl	c19c <hal_debugger_connected>
    eae4:	b100      	cbz	r0, eae8 <modlog_init+0x4c>
    eae6:	be01      	bkpt	0x0001
    eae8:	2300      	movs	r3, #0
    eaea:	461a      	mov	r2, r3
    eaec:	4619      	mov	r1, r3
    eaee:	4618      	mov	r0, r3
    eaf0:	f7fd fd32 	bl	c558 <__assert_func>
    SYSINIT_PANIC_ASSERT(rc == 0);
    eaf4:	f7fd fb52 	bl	c19c <hal_debugger_connected>
    eaf8:	b100      	cbz	r0, eafc <modlog_init+0x60>
    eafa:	be01      	bkpt	0x0001
    eafc:	2000      	movs	r0, #0
    eafe:	9000      	str	r0, [sp, #0]
    eb00:	4b17      	ldr	r3, [pc, #92]	; (eb60 <modlog_init+0xc4>)
    eb02:	681c      	ldr	r4, [r3, #0]
    eb04:	4603      	mov	r3, r0
    eb06:	4602      	mov	r2, r0
    eb08:	4601      	mov	r1, r0
    eb0a:	47a0      	blx	r4
    eb0c:	e7d4      	b.n	eab8 <modlog_init+0x1c>
    SYSINIT_PANIC_ASSERT(rc == 0);
    eb0e:	f7fd fb45 	bl	c19c <hal_debugger_connected>
    eb12:	b100      	cbz	r0, eb16 <modlog_init+0x7a>
    eb14:	be01      	bkpt	0x0001
    eb16:	2000      	movs	r0, #0
    eb18:	9000      	str	r0, [sp, #0]
    eb1a:	4b11      	ldr	r3, [pc, #68]	; (eb60 <modlog_init+0xc4>)
    eb1c:	681c      	ldr	r4, [r3, #0]
    eb1e:	4603      	mov	r3, r0
    eb20:	4602      	mov	r2, r0
    eb22:	4601      	mov	r1, r0
    eb24:	47a0      	blx	r4
    eb26:	e7d0      	b.n	eaca <modlog_init+0x2e>
    SYSINIT_PANIC_ASSERT(rc == 0);
    eb28:	f7fd fb38 	bl	c19c <hal_debugger_connected>
    eb2c:	b100      	cbz	r0, eb30 <modlog_init+0x94>
    eb2e:	be01      	bkpt	0x0001
    eb30:	2000      	movs	r0, #0
    eb32:	9000      	str	r0, [sp, #0]
    eb34:	4b0a      	ldr	r3, [pc, #40]	; (eb60 <modlog_init+0xc4>)
    eb36:	681c      	ldr	r4, [r3, #0]
    eb38:	4603      	mov	r3, r0
    eb3a:	4602      	mov	r2, r0
    eb3c:	4601      	mov	r1, r0
    eb3e:	47a0      	blx	r4
}
    eb40:	e7cc      	b.n	eadc <modlog_init+0x40>
    eb42:	bf00      	nop
    eb44:	20002370 	.word	0x20002370
    eb48:	00011a30 	.word	0x00011a30
    eb4c:	2000226c 	.word	0x2000226c
    eb50:	2000232c 	.word	0x2000232c
    eb54:	20002348 	.word	0x20002348
    eb58:	20002268 	.word	0x20002268
    eb5c:	2000234c 	.word	0x2000234c
    eb60:	20000130 	.word	0x20000130

0000eb64 <sysinit_dflt_panic_cb>:
#include "os/mynewt.h"

static void
sysinit_dflt_panic_cb(const char *file, int line, const char *func,
                      const char *expr, const char *msg)
{
    eb64:	b508      	push	{r3, lr}
    if (msg != NULL) {
        fprintf(stderr, "sysinit failure: %s\n", msg);
    }
#endif

    __assert_func(file, line, func, expr);
    eb66:	f7fd fcf7 	bl	c558 <__assert_func>
	...

0000eb6c <sysinit_start>:
}

void
sysinit_start(void)
{
    sysinit_active = 1;
    eb6c:	4b01      	ldr	r3, [pc, #4]	; (eb74 <sysinit_start+0x8>)
    eb6e:	2201      	movs	r2, #1
    eb70:	701a      	strb	r2, [r3, #0]
}
    eb72:	4770      	bx	lr
    eb74:	20002370 	.word	0x20002370

0000eb78 <sysinit_end>:

void
sysinit_end(void)
{
    sysinit_active = 0;
    eb78:	4b01      	ldr	r3, [pc, #4]	; (eb80 <sysinit_end+0x8>)
    eb7a:	2200      	movs	r2, #0
    eb7c:	701a      	strb	r2, [r3, #0]
}
    eb7e:	4770      	bx	lr
    eb80:	20002370 	.word	0x20002370

0000eb84 <mem_init_mbuf_pool>:

int
mem_init_mbuf_pool(void *mem, struct os_mempool *mempool,
                   struct os_mbuf_pool *mbuf_pool, int num_blocks,
                   int block_size, char *name)
{
    eb84:	b5f0      	push	{r4, r5, r6, r7, lr}
    eb86:	b083      	sub	sp, #12
    eb88:	460d      	mov	r5, r1
    eb8a:	4617      	mov	r7, r2
    int rc;

    rc = os_mempool_init(mempool, num_blocks, block_size, mem, name);
    eb8c:	b29e      	uxth	r6, r3
    eb8e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    eb90:	9300      	str	r3, [sp, #0]
    eb92:	4603      	mov	r3, r0
    eb94:	9a08      	ldr	r2, [sp, #32]
    eb96:	4631      	mov	r1, r6
    eb98:	4628      	mov	r0, r5
    eb9a:	f7fe f829 	bl	cbf0 <os_mempool_init>
    if (rc != 0) {
    eb9e:	b108      	cbz	r0, eba4 <mem_init_mbuf_pool+0x20>
    if (rc != 0) {
        return rc;
    }

    return 0;
}
    eba0:	b003      	add	sp, #12
    eba2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    rc = os_mbuf_pool_init(mbuf_pool, mempool, block_size, num_blocks);
    eba4:	4633      	mov	r3, r6
    eba6:	9a08      	ldr	r2, [sp, #32]
    eba8:	b292      	uxth	r2, r2
    ebaa:	4629      	mov	r1, r5
    ebac:	4638      	mov	r0, r7
    ebae:	f7fe fd59 	bl	d664 <os_mbuf_pool_init>
    if (rc != 0) {
    ebb2:	e7f5      	b.n	eba0 <mem_init_mbuf_pool+0x1c>

0000ebb4 <rwlock_complete_handoff>:
static void
rwlock_complete_handoff(struct rwlock *lock)
{
    RWLOCK_DBG_ASSERT(lock->mtx.mu_owner == g_current_task);
    RWLOCK_DBG_ASSERT(lock->handoffs > 0);
    lock->handoffs--;
    ebb4:	f890 3020 	ldrb.w	r3, [r0, #32]
    ebb8:	3b01      	subs	r3, #1
    ebba:	f880 3020 	strb.w	r3, [r0, #32]
}
    ebbe:	4770      	bx	lr

0000ebc0 <rwlock_write_must_block>:
static bool
rwlock_write_must_block(const struct rwlock *lock)
{
    RWLOCK_DBG_ASSERT(lock->mtx.mu_owner == g_current_task);

    return lock->active_writer ||
    ebc0:	8b83      	ldrh	r3, [r0, #28]
           lock->num_readers > 0 ||
    ebc2:	b923      	cbnz	r3, ebce <rwlock_write_must_block+0xe>
           lock->handoffs > 0;
    ebc4:	f890 3020 	ldrb.w	r3, [r0, #32]
           lock->num_readers > 0 ||
    ebc8:	b11b      	cbz	r3, ebd2 <rwlock_write_must_block+0x12>
    ebca:	2001      	movs	r0, #1
    ebcc:	4770      	bx	lr
    ebce:	2001      	movs	r0, #1
    ebd0:	4770      	bx	lr
    ebd2:	2000      	movs	r0, #0
}
    ebd4:	4770      	bx	lr

0000ebd6 <rwlock_unblock>:
{
    ebd6:	b510      	push	{r4, lr}
    ebd8:	4604      	mov	r4, r0
    if (lock->pending_writers > 0) {
    ebda:	7fc3      	ldrb	r3, [r0, #31]
    ebdc:	b91b      	cbnz	r3, ebe6 <rwlock_unblock+0x10>
        lock->handoffs = lock->pending_readers;
    ebde:	7f83      	ldrb	r3, [r0, #30]
    ebe0:	f880 3020 	strb.w	r3, [r0, #32]
        while (lock->pending_readers > 0) {
    ebe4:	e010      	b.n	ec08 <rwlock_unblock+0x32>
        lock->handoffs = 1;
    ebe6:	2301      	movs	r3, #1
    ebe8:	f880 3020 	strb.w	r3, [r0, #32]
        os_sem_release(&lock->wsem);
    ebec:	3014      	adds	r0, #20
    ebee:	f001 fcb9 	bl	10564 <os_sem_release>
        lock->pending_writers--;
    ebf2:	7fe3      	ldrb	r3, [r4, #31]
    ebf4:	3b01      	subs	r3, #1
    ebf6:	77e3      	strb	r3, [r4, #31]
    ebf8:	e009      	b.n	ec0e <rwlock_unblock+0x38>
            os_sem_release(&lock->rsem);
    ebfa:	f104 000c 	add.w	r0, r4, #12
    ebfe:	f001 fcb1 	bl	10564 <os_sem_release>
            lock->pending_readers--;
    ec02:	7fa3      	ldrb	r3, [r4, #30]
    ec04:	3b01      	subs	r3, #1
    ec06:	77a3      	strb	r3, [r4, #30]
        while (lock->pending_readers > 0) {
    ec08:	7fa3      	ldrb	r3, [r4, #30]
    ec0a:	2b00      	cmp	r3, #0
    ec0c:	d1f5      	bne.n	ebfa <rwlock_unblock+0x24>
}
    ec0e:	bd10      	pop	{r4, pc}

0000ec10 <rwlock_acquire_write>:
    os_mutex_release(&lock->mtx);
}

void
rwlock_acquire_write(struct rwlock *lock)
{
    ec10:	b538      	push	{r3, r4, r5, lr}
    ec12:	4604      	mov	r4, r0
    bool acquired;

    os_mutex_pend(&lock->mtx, OS_TIMEOUT_NEVER);
    ec14:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    ec18:	f7fe f8f4 	bl	ce04 <os_mutex_pend>

    if (rwlock_write_must_block(lock)) {
    ec1c:	4620      	mov	r0, r4
    ec1e:	f7ff ffcf 	bl	ebc0 <rwlock_write_must_block>
    ec22:	b140      	cbz	r0, ec36 <rwlock_acquire_write+0x26>
        lock->pending_writers++;
    ec24:	7fe3      	ldrb	r3, [r4, #31]
    ec26:	3301      	adds	r3, #1
    ec28:	77e3      	strb	r3, [r4, #31]
        acquired = false;
    ec2a:	2500      	movs	r5, #0
    } else {
        lock->active_writer = true;
        acquired = true;
    }

    os_mutex_release(&lock->mtx);
    ec2c:	4620      	mov	r0, r4
    ec2e:	f7fe f889 	bl	cd44 <os_mutex_release>

    if (acquired) {
    ec32:	b11d      	cbz	r5, ec3c <rwlock_acquire_write+0x2c>
    /* Record writer ownership. */
    os_mutex_pend(&lock->mtx, OS_TIMEOUT_NEVER);
    lock->active_writer = true;
    rwlock_complete_handoff(lock);
    os_mutex_release(&lock->mtx);
}
    ec34:	bd38      	pop	{r3, r4, r5, pc}
        lock->active_writer = true;
    ec36:	2501      	movs	r5, #1
    ec38:	7765      	strb	r5, [r4, #29]
        acquired = true;
    ec3a:	e7f7      	b.n	ec2c <rwlock_acquire_write+0x1c>
    os_sem_pend(&lock->wsem, OS_TIMEOUT_NEVER);
    ec3c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    ec40:	f104 0014 	add.w	r0, r4, #20
    ec44:	f001 fcc0 	bl	105c8 <os_sem_pend>
    os_mutex_pend(&lock->mtx, OS_TIMEOUT_NEVER);
    ec48:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    ec4c:	4620      	mov	r0, r4
    ec4e:	f7fe f8d9 	bl	ce04 <os_mutex_pend>
    lock->active_writer = true;
    ec52:	2301      	movs	r3, #1
    ec54:	7763      	strb	r3, [r4, #29]
    rwlock_complete_handoff(lock);
    ec56:	4620      	mov	r0, r4
    ec58:	f7ff ffac 	bl	ebb4 <rwlock_complete_handoff>
    os_mutex_release(&lock->mtx);
    ec5c:	4620      	mov	r0, r4
    ec5e:	f7fe f871 	bl	cd44 <os_mutex_release>
    ec62:	e7e7      	b.n	ec34 <rwlock_acquire_write+0x24>

0000ec64 <rwlock_release_write>:

void
rwlock_release_write(struct rwlock *lock)
{
    ec64:	b510      	push	{r4, lr}
    ec66:	4604      	mov	r4, r0
    os_mutex_pend(&lock->mtx, OS_TIMEOUT_NEVER);
    ec68:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    ec6c:	f7fe f8ca 	bl	ce04 <os_mutex_pend>

    RWLOCK_DBG_ASSERT(lock->active_writer);
    lock->active_writer = false;
    ec70:	2300      	movs	r3, #0
    ec72:	7763      	strb	r3, [r4, #29]

    rwlock_unblock(lock);
    ec74:	4620      	mov	r0, r4
    ec76:	f7ff ffae 	bl	ebd6 <rwlock_unblock>

    os_mutex_release(&lock->mtx);
    ec7a:	4620      	mov	r0, r4
    ec7c:	f7fe f862 	bl	cd44 <os_mutex_release>
}
    ec80:	bd10      	pop	{r4, pc}

0000ec82 <rwlock_init>:

int
rwlock_init(struct rwlock *lock)
{
    ec82:	b510      	push	{r4, lr}
    ec84:	4604      	mov	r4, r0
    int rc;

    *lock = (struct rwlock) { 0 };
    ec86:	2224      	movs	r2, #36	; 0x24
    ec88:	2100      	movs	r1, #0
    ec8a:	f7fe fd86 	bl	d79a <memset>

    rc = os_mutex_init(&lock->mtx);
    ec8e:	4620      	mov	r0, r4
    ec90:	f7fe f84e 	bl	cd30 <os_mutex_init>
    if (rc != 0) {
    ec94:	b100      	cbz	r0, ec98 <rwlock_init+0x16>
    if (rc != 0) {
        return rc;
    }

    return 0;
}
    ec96:	bd10      	pop	{r4, pc}
    rc = os_sem_init(&lock->rsem, 0);
    ec98:	2100      	movs	r1, #0
    ec9a:	f104 000c 	add.w	r0, r4, #12
    ec9e:	f001 fc59 	bl	10554 <os_sem_init>
    if (rc != 0) {
    eca2:	2800      	cmp	r0, #0
    eca4:	d1f7      	bne.n	ec96 <rwlock_init+0x14>
    rc = os_sem_init(&lock->wsem, 0);
    eca6:	2100      	movs	r1, #0
    eca8:	f104 0014 	add.w	r0, r4, #20
    ecac:	f001 fc52 	bl	10554 <os_sem_init>
    if (rc != 0) {
    ecb0:	e7f1      	b.n	ec96 <rwlock_init+0x14>

0000ecb2 <cbuf_buf_reader_get8>:

static uint8_t
cbuf_buf_reader_get8(struct cbor_decoder_reader *d, int offset)
{
    struct cbor_buf_reader *cb = (struct cbor_buf_reader *) d;
    return cb->buffer[offset];
    ecb2:	69c3      	ldr	r3, [r0, #28]
}
    ecb4:	5c58      	ldrb	r0, [r3, r1]
    ecb6:	4770      	bx	lr

0000ecb8 <cbor_buf_reader_cpy>:
}

static uintptr_t
cbor_buf_reader_cpy(struct cbor_decoder_reader *d, char *dst, int src_offset,
                    size_t len)
{
    ecb8:	b510      	push	{r4, lr}
    ecba:	4604      	mov	r4, r0
    ecbc:	4608      	mov	r0, r1
    ecbe:	4611      	mov	r1, r2
    struct cbor_buf_reader *cb = (struct cbor_buf_reader *) d;
    return (uintptr_t) memcpy(dst, cb->buffer + src_offset, len);
    ecc0:	69e4      	ldr	r4, [r4, #28]
    ecc2:	461a      	mov	r2, r3
    ecc4:	4421      	add	r1, r4
    ecc6:	f7fe fd5b 	bl	d780 <memcpy>
}
    ecca:	bd10      	pop	{r4, pc}

0000eccc <cbor_buf_reader_cmp>:
{
    eccc:	b510      	push	{r4, lr}
    ecce:	4604      	mov	r4, r0
    ecd0:	4608      	mov	r0, r1
    ecd2:	4611      	mov	r1, r2
    return memcmp(dst, cb->buffer + src_offset, len) == 0;
    ecd4:	69e4      	ldr	r4, [r4, #28]
    ecd6:	461a      	mov	r2, r3
    ecd8:	4421      	add	r1, r4
    ecda:	f7fe fd2d 	bl	d738 <memcmp>
}
    ecde:	fab0 f080 	clz	r0, r0
    ece2:	0940      	lsrs	r0, r0, #5
    ece4:	bd10      	pop	{r4, pc}

0000ece6 <cbuf_buf_reader_get64>:
{
    ece6:	b410      	push	{r4}
    ece8:	b083      	sub	sp, #12
    return get64(cb->buffer + offset);
    ecea:	69c2      	ldr	r2, [r0, #28]
    ecec:	1854      	adds	r4, r2, r1
}

static inline uint64_t get64(const uint8_t *ptr)
{
    uint64_t result;
    memcpy(&result, ptr, sizeof(result));
    ecee:	466b      	mov	r3, sp
    ecf0:	5850      	ldr	r0, [r2, r1]
    ecf2:	6861      	ldr	r1, [r4, #4]
    ecf4:	c303      	stmia	r3!, {r0, r1}
}
    ecf6:	ba08      	rev	r0, r1
    ecf8:	9900      	ldr	r1, [sp, #0]
    ecfa:	ba09      	rev	r1, r1
    ecfc:	b003      	add	sp, #12
    ecfe:	bc10      	pop	{r4}
    ed00:	4770      	bx	lr

0000ed02 <cbuf_buf_reader_get32>:
    val = get32(cb->buffer + offset);
    ed02:	69c3      	ldr	r3, [r0, #28]
    return cbor_ntohl(result);
    ed04:	5858      	ldr	r0, [r3, r1]
}
    ed06:	ba00      	rev	r0, r0
    ed08:	4770      	bx	lr

0000ed0a <cbuf_buf_reader_get16>:
    return get16(cb->buffer + offset);
    ed0a:	69c3      	ldr	r3, [r0, #28]
    return cbor_ntohs(result);
    ed0c:	5a58      	ldrh	r0, [r3, r1]
    ed0e:	ba40      	rev16	r0, r0
}
    ed10:	b280      	uxth	r0, r0
    ed12:	4770      	bx	lr

0000ed14 <cbor_buf_reader_init>:

void
cbor_buf_reader_init(struct cbor_buf_reader *cb, const uint8_t *buffer,
                     size_t data)
{
    cb->buffer = buffer;
    ed14:	61c1      	str	r1, [r0, #28]
    cb->r.get8 = &cbuf_buf_reader_get8;
    ed16:	4b07      	ldr	r3, [pc, #28]	; (ed34 <cbor_buf_reader_init+0x20>)
    ed18:	6003      	str	r3, [r0, #0]
    cb->r.get16 = &cbuf_buf_reader_get16;
    ed1a:	4b07      	ldr	r3, [pc, #28]	; (ed38 <cbor_buf_reader_init+0x24>)
    ed1c:	6043      	str	r3, [r0, #4]
    cb->r.get32 = &cbuf_buf_reader_get32;
    ed1e:	4b07      	ldr	r3, [pc, #28]	; (ed3c <cbor_buf_reader_init+0x28>)
    ed20:	6083      	str	r3, [r0, #8]
    cb->r.get64 = &cbuf_buf_reader_get64;
    ed22:	4b07      	ldr	r3, [pc, #28]	; (ed40 <cbor_buf_reader_init+0x2c>)
    ed24:	60c3      	str	r3, [r0, #12]
    cb->r.cmp = &cbor_buf_reader_cmp;
    ed26:	4b07      	ldr	r3, [pc, #28]	; (ed44 <cbor_buf_reader_init+0x30>)
    ed28:	6103      	str	r3, [r0, #16]
    cb->r.cpy = &cbor_buf_reader_cpy;
    ed2a:	4b07      	ldr	r3, [pc, #28]	; (ed48 <cbor_buf_reader_init+0x34>)
    ed2c:	6143      	str	r3, [r0, #20]
    cb->r.message_size = data;
    ed2e:	6182      	str	r2, [r0, #24]
}
    ed30:	4770      	bx	lr
    ed32:	bf00      	nop
    ed34:	0000ecb3 	.word	0x0000ecb3
    ed38:	0000ed0b 	.word	0x0000ed0b
    ed3c:	0000ed03 	.word	0x0000ed03
    ed40:	0000ece7 	.word	0x0000ece7
    ed44:	0000eccd 	.word	0x0000eccd
    ed48:	0000ecb9 	.word	0x0000ecb9

0000ed4c <is_fixed_type>:
    return CborNoError;
}

static bool is_fixed_type(uint8_t type)
{
    return type != CborTextStringType && type != CborByteStringType && type != CborArrayType &&
    ed4c:	2860      	cmp	r0, #96	; 0x60
    ed4e:	d009      	beq.n	ed64 <is_fixed_type+0x18>
    ed50:	2840      	cmp	r0, #64	; 0x40
    ed52:	d009      	beq.n	ed68 <is_fixed_type+0x1c>
    ed54:	2880      	cmp	r0, #128	; 0x80
    ed56:	d009      	beq.n	ed6c <is_fixed_type+0x20>
    ed58:	28a0      	cmp	r0, #160	; 0xa0
    ed5a:	d001      	beq.n	ed60 <is_fixed_type+0x14>
    ed5c:	2001      	movs	r0, #1
           type != CborMapType;
}
    ed5e:	4770      	bx	lr
    return type != CborTextStringType && type != CborByteStringType && type != CborArrayType &&
    ed60:	2000      	movs	r0, #0
    ed62:	4770      	bx	lr
    ed64:	2000      	movs	r0, #0
    ed66:	4770      	bx	lr
    ed68:	2000      	movs	r0, #0
    ed6a:	4770      	bx	lr
    ed6c:	2000      	movs	r0, #0
    ed6e:	4770      	bx	lr

0000ed70 <iterate_noop>:
    (void)d;
    (void)dst;
    (void)src_offset;
    (void)len;
    return true;
}
    ed70:	2001      	movs	r0, #1
    ed72:	4770      	bx	lr

0000ed74 <preparse_value>:
{
    ed74:	b570      	push	{r4, r5, r6, lr}
    const CborParser *parser = it->parser;
    ed76:	6805      	ldr	r5, [r0, #0]
    it->type = CborInvalidType;
    ed78:	23ff      	movs	r3, #255	; 0xff
    ed7a:	7383      	strb	r3, [r0, #14]
    if (it->offset == parser->end)
    ed7c:	6841      	ldr	r1, [r0, #4]
    ed7e:	686b      	ldr	r3, [r5, #4]
    ed80:	4299      	cmp	r1, r3
    ed82:	f000 808d 	beq.w	eea0 <preparse_value+0x12c>
    ed86:	4604      	mov	r4, r0
    uint8_t descriptor = parser->d->get8(parser->d, it->offset);
    ed88:	6828      	ldr	r0, [r5, #0]
    ed8a:	6803      	ldr	r3, [r0, #0]
    ed8c:	4798      	blx	r3
    uint8_t type = descriptor & MajorTypeMask;
    ed8e:	f000 06e0 	and.w	r6, r0, #224	; 0xe0
    it->type = type;
    ed92:	73a6      	strb	r6, [r4, #14]
    it->flags = 0;
    ed94:	2300      	movs	r3, #0
    ed96:	73e3      	strb	r3, [r4, #15]
    it->extra = (descriptor &= SmallValueMask);
    ed98:	f000 031f 	and.w	r3, r0, #31
    ed9c:	81a3      	strh	r3, [r4, #12]
    if (descriptor > Value64Bit) {
    ed9e:	2b1b      	cmp	r3, #27
    eda0:	d91d      	bls.n	edde <preparse_value+0x6a>
        if (unlikely(descriptor != IndefiniteLength))
    eda2:	2b1f      	cmp	r3, #31
    eda4:	d10b      	bne.n	edbe <preparse_value+0x4a>
        if (likely(!is_fixed_type(type))) {
    eda6:	4630      	mov	r0, r6
    eda8:	f7ff ffd0 	bl	ed4c <is_fixed_type>
    edac:	f080 0001 	eor.w	r0, r0, #1
    edb0:	f010 0fff 	tst.w	r0, #255	; 0xff
    edb4:	d00b      	beq.n	edce <preparse_value+0x5a>
            it->flags |= CborIteratorFlag_UnknownLength;
    edb6:	2304      	movs	r3, #4
    edb8:	73e3      	strb	r3, [r4, #15]
            return CborNoError;
    edba:	2000      	movs	r0, #0
}
    edbc:	bd70      	pop	{r4, r5, r6, pc}
            return type == CborSimpleType ? CborErrorUnknownType : CborErrorIllegalNumber;
    edbe:	2ee0      	cmp	r6, #224	; 0xe0
    edc0:	d002      	beq.n	edc8 <preparse_value+0x54>
    edc2:	f240 1005 	movw	r0, #261	; 0x105
    edc6:	e7f9      	b.n	edbc <preparse_value+0x48>
    edc8:	f240 1003 	movw	r0, #259	; 0x103
    edcc:	e7f6      	b.n	edbc <preparse_value+0x48>
        return type == CborSimpleType ? CborErrorUnexpectedBreak : CborErrorIllegalNumber;
    edce:	2ee0      	cmp	r6, #224	; 0xe0
    edd0:	d002      	beq.n	edd8 <preparse_value+0x64>
    edd2:	f240 1005 	movw	r0, #261	; 0x105
    edd6:	e7f1      	b.n	edbc <preparse_value+0x48>
    edd8:	f44f 7081 	mov.w	r0, #258	; 0x102
    eddc:	e7ee      	b.n	edbc <preparse_value+0x48>
    size_t bytesNeeded = descriptor < Value8Bit ? 0 : (1 << (descriptor - Value8Bit));
    edde:	2b17      	cmp	r3, #23
    ede0:	d91a      	bls.n	ee18 <preparse_value+0xa4>
    ede2:	f1a3 0118 	sub.w	r1, r3, #24
    ede6:	2201      	movs	r2, #1
    ede8:	408a      	lsls	r2, r1
    if (bytesNeeded + 1 > (size_t)(parser->end - it->offset))
    edea:	3201      	adds	r2, #1
    edec:	6868      	ldr	r0, [r5, #4]
    edee:	6861      	ldr	r1, [r4, #4]
    edf0:	1a40      	subs	r0, r0, r1
    edf2:	4282      	cmp	r2, r0
    edf4:	d857      	bhi.n	eea6 <preparse_value+0x132>
    uint8_t majortype = type >> MajorTypeShift;
    edf6:	0972      	lsrs	r2, r6, #5
    if (majortype == NegativeIntegerType) {
    edf8:	2e20      	cmp	r6, #32
    edfa:	d00f      	beq.n	ee1c <preparse_value+0xa8>
    } else if (majortype == SimpleTypesType) {
    edfc:	2a07      	cmp	r2, #7
    edfe:	d012      	beq.n	ee26 <preparse_value+0xb2>
    if (descriptor < Value8Bit)
    ee00:	2b17      	cmp	r3, #23
    ee02:	d953      	bls.n	eeac <preparse_value+0x138>
    if (descriptor == Value8Bit)
    ee04:	2b18      	cmp	r3, #24
    ee06:	d03d      	beq.n	ee84 <preparse_value+0x110>
    else if (descriptor == Value16Bit)
    ee08:	2b19      	cmp	r3, #25
    ee0a:	d042      	beq.n	ee92 <preparse_value+0x11e>
        it->flags |= CborIteratorFlag_IntegerValueTooLarge;     /* Value32Bit or Value64Bit */
    ee0c:	7be3      	ldrb	r3, [r4, #15]
    ee0e:	f043 0301 	orr.w	r3, r3, #1
    ee12:	73e3      	strb	r3, [r4, #15]
    return CborNoError;
    ee14:	2000      	movs	r0, #0
    ee16:	e7d1      	b.n	edbc <preparse_value+0x48>
    size_t bytesNeeded = descriptor < Value8Bit ? 0 : (1 << (descriptor - Value8Bit));
    ee18:	2200      	movs	r2, #0
    ee1a:	e7e6      	b.n	edea <preparse_value+0x76>
        it->flags |= CborIteratorFlag_NegativeInteger;
    ee1c:	2202      	movs	r2, #2
    ee1e:	73e2      	strb	r2, [r4, #15]
        it->type = CborIntegerType;
    ee20:	2200      	movs	r2, #0
    ee22:	73a2      	strb	r2, [r4, #14]
    ee24:	e7ec      	b.n	ee00 <preparse_value+0x8c>
        switch (descriptor) {
    ee26:	3b14      	subs	r3, #20
    ee28:	2b0b      	cmp	r3, #11
    ee2a:	d812      	bhi.n	ee52 <preparse_value+0xde>
    ee2c:	e8df f003 	tbb	[pc, r3]
    ee30:	0d0d0d06 	.word	0x0d0d0d06
    ee34:	0b0b0d13 	.word	0x0b0b0d13
    ee38:	20202020 	.word	0x20202020
            it->extra = false;
    ee3c:	2300      	movs	r3, #0
    ee3e:	81a3      	strh	r3, [r4, #12]
            it->type = CborBooleanType;
    ee40:	23f5      	movs	r3, #245	; 0xf5
    ee42:	73a3      	strb	r3, [r4, #14]
            break;
    ee44:	e005      	b.n	ee52 <preparse_value+0xde>
            it->flags |= CborIteratorFlag_IntegerValueTooLarge;
    ee46:	2301      	movs	r3, #1
    ee48:	73e3      	strb	r3, [r4, #15]
            it->type = parser->d->get8(parser->d, it->offset);
    ee4a:	6828      	ldr	r0, [r5, #0]
    ee4c:	6803      	ldr	r3, [r0, #0]
    ee4e:	4798      	blx	r3
    ee50:	73a0      	strb	r0, [r4, #14]
        return CborNoError;
    ee52:	2000      	movs	r0, #0
    ee54:	e7b2      	b.n	edbc <preparse_value+0x48>
            it->extra = parser->d->get8(parser->d, it->offset + 1);
    ee56:	6828      	ldr	r0, [r5, #0]
    ee58:	6803      	ldr	r3, [r0, #0]
    ee5a:	3101      	adds	r1, #1
    ee5c:	4798      	blx	r3
    ee5e:	b283      	uxth	r3, r0
    ee60:	81a3      	strh	r3, [r4, #12]
            if (unlikely(it->extra < 32)) {
    ee62:	2b1f      	cmp	r3, #31
    ee64:	d8f5      	bhi.n	ee52 <preparse_value+0xde>
                it->type = CborInvalidType;
    ee66:	23ff      	movs	r3, #255	; 0xff
    ee68:	73a3      	strb	r3, [r4, #14]
                return CborErrorIllegalSimpleType;
    ee6a:	f44f 7083 	mov.w	r0, #262	; 0x106
    ee6e:	e7a5      	b.n	edbc <preparse_value+0x48>
            assert(false);  /* these conditions can't be reached */
    ee70:	f7fd f994 	bl	c19c <hal_debugger_connected>
    ee74:	b100      	cbz	r0, ee78 <preparse_value+0x104>
    ee76:	be01      	bkpt	0x0001
    ee78:	2300      	movs	r3, #0
    ee7a:	461a      	mov	r2, r3
    ee7c:	4619      	mov	r1, r3
    ee7e:	4618      	mov	r0, r3
    ee80:	f7fd fb6a 	bl	c558 <__assert_func>
        it->extra = parser->d->get8(parser->d, it->offset + 1);
    ee84:	6828      	ldr	r0, [r5, #0]
    ee86:	6803      	ldr	r3, [r0, #0]
    ee88:	3101      	adds	r1, #1
    ee8a:	4798      	blx	r3
    ee8c:	81a0      	strh	r0, [r4, #12]
    return CborNoError;
    ee8e:	2000      	movs	r0, #0
    ee90:	e794      	b.n	edbc <preparse_value+0x48>
        it->extra = parser->d->get16(parser->d, it->offset + 1);
    ee92:	6828      	ldr	r0, [r5, #0]
    ee94:	6843      	ldr	r3, [r0, #4]
    ee96:	3101      	adds	r1, #1
    ee98:	4798      	blx	r3
    ee9a:	81a0      	strh	r0, [r4, #12]
    return CborNoError;
    ee9c:	2000      	movs	r0, #0
    ee9e:	e78d      	b.n	edbc <preparse_value+0x48>
        return CborErrorUnexpectedEOF;
    eea0:	f240 1001 	movw	r0, #257	; 0x101
    eea4:	e78a      	b.n	edbc <preparse_value+0x48>
        return CborErrorUnexpectedEOF;
    eea6:	f240 1001 	movw	r0, #257	; 0x101
    eeaa:	e787      	b.n	edbc <preparse_value+0x48>
        return CborNoError;
    eeac:	2000      	movs	r0, #0
    eeae:	e785      	b.n	edbc <preparse_value+0x48>

0000eeb0 <preparse_next_value>:
{
    eeb0:	b510      	push	{r4, lr}
    eeb2:	4604      	mov	r4, r0
    if (it->remaining != UINT32_MAX) {
    eeb4:	6880      	ldr	r0, [r0, #8]
    eeb6:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
    eeba:	d00c      	beq.n	eed6 <preparse_next_value+0x26>
        if (it->type != CborTagType && !--it->remaining) {
    eebc:	7ba2      	ldrb	r2, [r4, #14]
    eebe:	2ac0      	cmp	r2, #192	; 0xc0
    eec0:	d002      	beq.n	eec8 <preparse_next_value+0x18>
    eec2:	3801      	subs	r0, #1
    eec4:	60a0      	str	r0, [r4, #8]
    eec6:	b118      	cbz	r0, eed0 <preparse_next_value+0x20>
    return preparse_value(it);
    eec8:	4620      	mov	r0, r4
    eeca:	f7ff ff53 	bl	ed74 <preparse_value>
}
    eece:	bd10      	pop	{r4, pc}
            it->type = CborInvalidType;
    eed0:	23ff      	movs	r3, #255	; 0xff
    eed2:	73a3      	strb	r3, [r4, #14]
            return CborNoError;
    eed4:	e7fb      	b.n	eece <preparse_next_value+0x1e>
    } else if (it->remaining == UINT32_MAX && it->offset != it->parser->end &&
    eed6:	6861      	ldr	r1, [r4, #4]
    eed8:	6823      	ldr	r3, [r4, #0]
    eeda:	685a      	ldr	r2, [r3, #4]
    eedc:	4291      	cmp	r1, r2
    eede:	d0f3      	beq.n	eec8 <preparse_next_value+0x18>
        it->parser->d->get8(it->parser->d, it->offset) == (uint8_t)BreakByte) {
    eee0:	6818      	ldr	r0, [r3, #0]
    eee2:	6803      	ldr	r3, [r0, #0]
    eee4:	4798      	blx	r3
    } else if (it->remaining == UINT32_MAX && it->offset != it->parser->end &&
    eee6:	28ff      	cmp	r0, #255	; 0xff
    eee8:	d1ee      	bne.n	eec8 <preparse_next_value+0x18>
        ++it->offset;
    eeea:	6863      	ldr	r3, [r4, #4]
    eeec:	3301      	adds	r3, #1
    eeee:	6063      	str	r3, [r4, #4]
        it->type = CborInvalidType;
    eef0:	23ff      	movs	r3, #255	; 0xff
    eef2:	73a3      	strb	r3, [r4, #14]
        it->remaining = 0;
    eef4:	2000      	movs	r0, #0
    eef6:	60a0      	str	r0, [r4, #8]
        return CborNoError;
    eef8:	e7e9      	b.n	eece <preparse_next_value+0x1e>

0000eefa <extract_length>:
{
    eefa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    eefe:	4605      	mov	r5, r0
    ef00:	460e      	mov	r6, r1
    ef02:	4617      	mov	r7, r2
    return cbor_ntohll(result);
}

static inline CborError extract_number(const CborParser *p, int *offset, uint64_t *len)
{
    uint8_t additional_information = p->d->get8(p->d, *offset) & SmallValueMask;
    ef04:	6800      	ldr	r0, [r0, #0]
    ef06:	6803      	ldr	r3, [r0, #0]
    ef08:	6809      	ldr	r1, [r1, #0]
    ef0a:	4798      	blx	r3
    ef0c:	f000 041f 	and.w	r4, r0, #31
    ++*offset;
    ef10:	6833      	ldr	r3, [r6, #0]
    ef12:	3301      	adds	r3, #1
    ef14:	6033      	str	r3, [r6, #0]
    *len = 1;
    if (additional_information < Value8Bit) {
    ef16:	2c17      	cmp	r4, #23
    ef18:	d91a      	bls.n	ef50 <extract_length+0x56>
        *len = additional_information;
        return CborNoError;
    }
    if (unlikely(additional_information > Value64Bit))
    ef1a:	2c1b      	cmp	r4, #27
    ef1c:	d83a      	bhi.n	ef94 <extract_length+0x9a>
        return CborErrorIllegalNumber;

    size_t bytesNeeded = (size_t)(1 << (additional_information - Value8Bit));
    ef1e:	3c18      	subs	r4, #24
    ef20:	f04f 0801 	mov.w	r8, #1
    ef24:	fa08 f804 	lsl.w	r8, r8, r4
    if (unlikely(bytesNeeded > (size_t)(p->end - *offset))) {
    ef28:	686b      	ldr	r3, [r5, #4]
    ef2a:	6831      	ldr	r1, [r6, #0]
    ef2c:	1a5b      	subs	r3, r3, r1
    ef2e:	4598      	cmp	r8, r3
    ef30:	d835      	bhi.n	ef9e <extract_length+0xa4>
        return CborErrorUnexpectedEOF;
    } else if (bytesNeeded == 1) {
    ef32:	f1b8 0f01 	cmp.w	r8, #1
    ef36:	d00f      	beq.n	ef58 <extract_length+0x5e>
        *len = p->d->get8(p->d, *offset);
    } else if (bytesNeeded == 2) {
    ef38:	f1b8 0f02 	cmp.w	r8, #2
    ef3c:	d01e      	beq.n	ef7c <extract_length+0x82>
        *len =  p->d->get16(p->d, *offset);
    } else if (bytesNeeded == 4) {
    ef3e:	f1b8 0f04 	cmp.w	r8, #4
    ef42:	d021      	beq.n	ef88 <extract_length+0x8e>
        *len =  p->d->get32(p->d, *offset);
    } else {
        *len =  p->d->get64(p->d, *offset);
    ef44:	6828      	ldr	r0, [r5, #0]
    ef46:	68c3      	ldr	r3, [r0, #12]
    ef48:	4798      	blx	r3
    ef4a:	4604      	mov	r4, r0
    ef4c:	460d      	mov	r5, r1
    ef4e:	e008      	b.n	ef62 <extract_length+0x68>
        *len = additional_information;
    ef50:	b2e4      	uxtb	r4, r4
    ef52:	2500      	movs	r5, #0
        return CborNoError;
    ef54:	2000      	movs	r0, #0
    ef56:	e008      	b.n	ef6a <extract_length+0x70>
        *len = p->d->get8(p->d, *offset);
    ef58:	6828      	ldr	r0, [r5, #0]
    ef5a:	6803      	ldr	r3, [r0, #0]
    ef5c:	4798      	blx	r3
    ef5e:	4604      	mov	r4, r0
    ef60:	2500      	movs	r5, #0
    }
    *offset += bytesNeeded;
    ef62:	6833      	ldr	r3, [r6, #0]
    ef64:	4443      	add	r3, r8
    ef66:	6033      	str	r3, [r6, #0]
    return CborNoError;
    ef68:	2000      	movs	r0, #0
    if (err) {
    ef6a:	b9e8      	cbnz	r0, efa8 <extract_length+0xae>
    *len = v;
    ef6c:	603c      	str	r4, [r7, #0]
    if (v != *len)
    ef6e:	2300      	movs	r3, #0
    ef70:	42ab      	cmp	r3, r5
    ef72:	bf08      	it	eq
    ef74:	42a4      	cmpeq	r4, r4
    ef76:	d11a      	bne.n	efae <extract_length+0xb4>
}
    ef78:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        *len =  p->d->get16(p->d, *offset);
    ef7c:	6828      	ldr	r0, [r5, #0]
    ef7e:	6843      	ldr	r3, [r0, #4]
    ef80:	4798      	blx	r3
    ef82:	4604      	mov	r4, r0
    ef84:	2500      	movs	r5, #0
    ef86:	e7ec      	b.n	ef62 <extract_length+0x68>
        *len =  p->d->get32(p->d, *offset);
    ef88:	6828      	ldr	r0, [r5, #0]
    ef8a:	6883      	ldr	r3, [r0, #8]
    ef8c:	4798      	blx	r3
    ef8e:	4604      	mov	r4, r0
    ef90:	2500      	movs	r5, #0
    ef92:	e7e6      	b.n	ef62 <extract_length+0x68>
    *len = 1;
    ef94:	2401      	movs	r4, #1
    ef96:	2500      	movs	r5, #0
        return CborErrorIllegalNumber;
    ef98:	f240 1005 	movw	r0, #261	; 0x105
    ef9c:	e7e5      	b.n	ef6a <extract_length+0x70>
    *len = 1;
    ef9e:	2401      	movs	r4, #1
    efa0:	2500      	movs	r5, #0
        return CborErrorUnexpectedEOF;
    efa2:	f240 1001 	movw	r0, #257	; 0x101
    efa6:	e7e0      	b.n	ef6a <extract_length+0x70>
        *len = 0;
    efa8:	2300      	movs	r3, #0
    efaa:	603b      	str	r3, [r7, #0]
        return err;
    efac:	e7e4      	b.n	ef78 <extract_length+0x7e>
        return CborErrorDataTooLarge;
    efae:	f44f 6080 	mov.w	r0, #1024	; 0x400
    efb2:	e7e1      	b.n	ef78 <extract_length+0x7e>

0000efb4 <iterate_string_chunks>:

static CborError iterate_string_chunks(const CborValue *value, char *buffer, size_t *buflen,
                                       bool *result, CborValue *next, IterateFunction func)
{
    efb4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    efb8:	b085      	sub	sp, #20
    efba:	4604      	mov	r4, r0
    efbc:	4689      	mov	r9, r1
    efbe:	4616      	mov	r6, r2
    efc0:	461d      	mov	r5, r3
{ return value->type == CborByteStringType; }
    efc2:	7b83      	ldrb	r3, [r0, #14]
    assert(cbor_value_is_byte_string(value) || cbor_value_is_text_string(value));
    efc4:	2b40      	cmp	r3, #64	; 0x40
    efc6:	d001      	beq.n	efcc <iterate_string_chunks+0x18>
    efc8:	2b60      	cmp	r3, #96	; 0x60
    efca:	d10c      	bne.n	efe6 <iterate_string_chunks+0x32>

    size_t total;
    CborError err;
    int offset = value->offset;
    efcc:	6863      	ldr	r3, [r4, #4]
    efce:	9302      	str	r3, [sp, #8]
{ return (value->flags & CborIteratorFlag_UnknownLength) == 0; }
    efd0:	7be2      	ldrb	r2, [r4, #15]
    if (cbor_value_is_length_known(value)) {
    efd2:	f012 0f04 	tst.w	r2, #4
    efd6:	d010      	beq.n	effa <iterate_string_chunks+0x46>
        else
            *result = false;
        offset += total;
    } else {
        /* chunked */
        ++offset;
    efd8:	3301      	adds	r3, #1
    efda:	9302      	str	r3, [sp, #8]
        total = 0;
    efdc:	2300      	movs	r3, #0
    efde:	9303      	str	r3, [sp, #12]
        *result = true;
    efe0:	2301      	movs	r3, #1
    efe2:	702b      	strb	r3, [r5, #0]
    efe4:	e04c      	b.n	f080 <iterate_string_chunks+0xcc>
    assert(cbor_value_is_byte_string(value) || cbor_value_is_text_string(value));
    efe6:	f7fd f8d9 	bl	c19c <hal_debugger_connected>
    efea:	b100      	cbz	r0, efee <iterate_string_chunks+0x3a>
    efec:	be01      	bkpt	0x0001
    efee:	2300      	movs	r3, #0
    eff0:	461a      	mov	r2, r3
    eff2:	4619      	mov	r1, r3
    eff4:	4618      	mov	r0, r3
    eff6:	f7fd faaf 	bl	c558 <__assert_func>
        err = extract_length(value->parser, &offset, &total);
    effa:	aa03      	add	r2, sp, #12
    effc:	a902      	add	r1, sp, #8
    effe:	6820      	ldr	r0, [r4, #0]
    f000:	f7ff ff7b 	bl	eefa <extract_length>
        if (err)
    f004:	4603      	mov	r3, r0
    f006:	2800      	cmp	r0, #0
    f008:	d177      	bne.n	f0fa <iterate_string_chunks+0x146>
        if (total > (size_t)(value->parser->end - offset))
    f00a:	6820      	ldr	r0, [r4, #0]
    f00c:	6843      	ldr	r3, [r0, #4]
    f00e:	9a02      	ldr	r2, [sp, #8]
    f010:	1a99      	subs	r1, r3, r2
    f012:	9b03      	ldr	r3, [sp, #12]
    f014:	4299      	cmp	r1, r3
    f016:	f0c0 8083 	bcc.w	f120 <iterate_string_chunks+0x16c>
        if (total <= *buflen)
    f01a:	6831      	ldr	r1, [r6, #0]
    f01c:	428b      	cmp	r3, r1
    f01e:	d81e      	bhi.n	f05e <iterate_string_chunks+0xaa>
            *result = !!func(value->parser->d, buffer, offset, total);
    f020:	4649      	mov	r1, r9
    f022:	6800      	ldr	r0, [r0, #0]
    f024:	9f0d      	ldr	r7, [sp, #52]	; 0x34
    f026:	47b8      	blx	r7
    f028:	3800      	subs	r0, #0
    f02a:	bf18      	it	ne
    f02c:	2001      	movne	r0, #1
    f02e:	7028      	strb	r0, [r5, #0]
        offset += total;
    f030:	9b02      	ldr	r3, [sp, #8]
    f032:	9a03      	ldr	r2, [sp, #12]
    f034:	4413      	add	r3, r2
    f036:	9302      	str	r3, [sp, #8]
            total = newTotal;
        }
    }

    /* is there enough room for the ending NUL byte? */
    if (*result && *buflen > total) {
    f038:	782b      	ldrb	r3, [r5, #0]
    f03a:	b14b      	cbz	r3, f050 <iterate_string_chunks+0x9c>
    f03c:	6832      	ldr	r2, [r6, #0]
    f03e:	9b03      	ldr	r3, [sp, #12]
    f040:	429a      	cmp	r2, r3
    f042:	d905      	bls.n	f050 <iterate_string_chunks+0x9c>
        /* we are just trying to write a NULL byte here,, but this is hard
         * because this is called by function pointer with an abstract
         * reader.  Since this is the output buffer, we can assume that if
         * we have a valid buffer its ok to write a NULL here  */
        if(buffer) {
    f044:	f1b9 0f00 	cmp.w	r9, #0
    f048:	d002      	beq.n	f050 <iterate_string_chunks+0x9c>
            *(buffer + total) = '\0';
    f04a:	2200      	movs	r2, #0
    f04c:	f809 2003 	strb.w	r2, [r9, r3]
        }
    }
    *buflen = total;
    f050:	9b03      	ldr	r3, [sp, #12]
    f052:	6033      	str	r3, [r6, #0]

    if (next) {
    f054:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    f056:	2b00      	cmp	r3, #0
    f058:	d156      	bne.n	f108 <iterate_string_chunks+0x154>
        *next = *value;
        next->offset = offset;
        return preparse_next_value(next);
    }
    return CborNoError;
    f05a:	2300      	movs	r3, #0
    f05c:	e04d      	b.n	f0fa <iterate_string_chunks+0x146>
            *result = false;
    f05e:	2300      	movs	r3, #0
    f060:	702b      	strb	r3, [r5, #0]
    f062:	e7e5      	b.n	f030 <iterate_string_chunks+0x7c>
                ++offset;
    f064:	9b02      	ldr	r3, [sp, #8]
    f066:	3301      	adds	r3, #1
    f068:	9302      	str	r3, [sp, #8]
                break;
    f06a:	e7e5      	b.n	f038 <iterate_string_chunks+0x84>
#endif

static inline bool add_check_overflow(size_t v1, size_t v2, size_t *r)
{
#if ((defined(__GNUC__) && (__GNUC__ >= 5)) && !defined(__INTEL_COMPILER)) || __has_builtin(__builtin_add_overflow)
    return __builtin_add_overflow(v1, v2, r);
    f06c:	2201      	movs	r2, #1
    f06e:	e023      	b.n	f0b8 <iterate_string_chunks+0x104>
                *result = false;
    f070:	2300      	movs	r3, #0
    f072:	702b      	strb	r3, [r5, #0]
            offset += chunkLen;
    f074:	9b02      	ldr	r3, [sp, #8]
    f076:	9a01      	ldr	r2, [sp, #4]
    f078:	4413      	add	r3, r2
    f07a:	9302      	str	r3, [sp, #8]
            total = newTotal;
    f07c:	f8cd 800c 	str.w	r8, [sp, #12]
            if (offset == value->parser->end)
    f080:	6823      	ldr	r3, [r4, #0]
    f082:	685a      	ldr	r2, [r3, #4]
    f084:	9902      	ldr	r1, [sp, #8]
    f086:	428a      	cmp	r2, r1
    f088:	d02f      	beq.n	f0ea <iterate_string_chunks+0x136>
            val = value->parser->d->get8(value->parser->d, offset);
    f08a:	6818      	ldr	r0, [r3, #0]
    f08c:	6803      	ldr	r3, [r0, #0]
    f08e:	4798      	blx	r3
            if (val == (uint8_t)BreakByte) {
    f090:	28ff      	cmp	r0, #255	; 0xff
    f092:	d0e7      	beq.n	f064 <iterate_string_chunks+0xb0>
            if ((val & MajorTypeMask) != value->type)
    f094:	f020 001f 	bic.w	r0, r0, #31
    f098:	7ba3      	ldrb	r3, [r4, #14]
    f09a:	4298      	cmp	r0, r3
    f09c:	d128      	bne.n	f0f0 <iterate_string_chunks+0x13c>
            err = extract_length(value->parser, &offset, &chunkLen);
    f09e:	aa01      	add	r2, sp, #4
    f0a0:	a902      	add	r1, sp, #8
    f0a2:	6820      	ldr	r0, [r4, #0]
    f0a4:	f7ff ff29 	bl	eefa <extract_length>
            if (err)
    f0a8:	4603      	mov	r3, r0
    f0aa:	bb30      	cbnz	r0, f0fa <iterate_string_chunks+0x146>
            if (unlikely(add_check_overflow(total, chunkLen, &newTotal)))
    f0ac:	9903      	ldr	r1, [sp, #12]
    f0ae:	9b01      	ldr	r3, [sp, #4]
    f0b0:	2200      	movs	r2, #0
    f0b2:	eb11 0803 	adds.w	r8, r1, r3
    f0b6:	d2d9      	bcs.n	f06c <iterate_string_chunks+0xb8>
    f0b8:	b9ea      	cbnz	r2, f0f6 <iterate_string_chunks+0x142>
            if (chunkLen > (size_t)(value->parser->end - offset))
    f0ba:	f8d4 c000 	ldr.w	ip, [r4]
    f0be:	f8dc 0004 	ldr.w	r0, [ip, #4]
    f0c2:	9a02      	ldr	r2, [sp, #8]
    f0c4:	1a80      	subs	r0, r0, r2
    f0c6:	4283      	cmp	r3, r0
    f0c8:	d81b      	bhi.n	f102 <iterate_string_chunks+0x14e>
            if (*result && *buflen >= newTotal)
    f0ca:	7828      	ldrb	r0, [r5, #0]
    f0cc:	2800      	cmp	r0, #0
    f0ce:	d0cf      	beq.n	f070 <iterate_string_chunks+0xbc>
    f0d0:	6830      	ldr	r0, [r6, #0]
    f0d2:	4540      	cmp	r0, r8
    f0d4:	d3cc      	bcc.n	f070 <iterate_string_chunks+0xbc>
                *result = !!func(value->parser->d, buffer + total, offset, chunkLen);
    f0d6:	4449      	add	r1, r9
    f0d8:	f8dc 0000 	ldr.w	r0, [ip]
    f0dc:	9f0d      	ldr	r7, [sp, #52]	; 0x34
    f0de:	47b8      	blx	r7
    f0e0:	3800      	subs	r0, #0
    f0e2:	bf18      	it	ne
    f0e4:	2001      	movne	r0, #1
    f0e6:	7028      	strb	r0, [r5, #0]
    f0e8:	e7c4      	b.n	f074 <iterate_string_chunks+0xc0>
                return CborErrorUnexpectedEOF;
    f0ea:	f240 1301 	movw	r3, #257	; 0x101
    f0ee:	e004      	b.n	f0fa <iterate_string_chunks+0x146>
                return CborErrorIllegalType;
    f0f0:	f44f 7382 	mov.w	r3, #260	; 0x104
    f0f4:	e001      	b.n	f0fa <iterate_string_chunks+0x146>
                return CborErrorDataTooLarge;
    f0f6:	f44f 6380 	mov.w	r3, #1024	; 0x400
}
    f0fa:	4618      	mov	r0, r3
    f0fc:	b005      	add	sp, #20
    f0fe:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
                return CborErrorUnexpectedEOF;
    f102:	f240 1301 	movw	r3, #257	; 0x101
    f106:	e7f8      	b.n	f0fa <iterate_string_chunks+0x146>
        *next = *value;
    f108:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
    f10c:	9c0c      	ldr	r4, [sp, #48]	; 0x30
    f10e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
        next->offset = offset;
    f112:	9b02      	ldr	r3, [sp, #8]
    f114:	6063      	str	r3, [r4, #4]
        return preparse_next_value(next);
    f116:	4620      	mov	r0, r4
    f118:	f7ff feca 	bl	eeb0 <preparse_next_value>
    f11c:	4603      	mov	r3, r0
    f11e:	e7ec      	b.n	f0fa <iterate_string_chunks+0x146>
            return CborErrorUnexpectedEOF;
    f120:	f240 1301 	movw	r3, #257	; 0x101
    f124:	e7e9      	b.n	f0fa <iterate_string_chunks+0x146>

0000f126 <advance_internal>:
{
    f126:	b570      	push	{r4, r5, r6, lr}
    f128:	4604      	mov	r4, r0
    CborError err = extract_number(it->parser, &it->offset,  &length);
    f12a:	6806      	ldr	r6, [r0, #0]
    uint8_t additional_information = p->d->get8(p->d, *offset) & SmallValueMask;
    f12c:	6830      	ldr	r0, [r6, #0]
    f12e:	6803      	ldr	r3, [r0, #0]
    f130:	6861      	ldr	r1, [r4, #4]
    f132:	4798      	blx	r3
    f134:	f000 001f 	and.w	r0, r0, #31
    ++*offset;
    f138:	6863      	ldr	r3, [r4, #4]
    f13a:	3301      	adds	r3, #1
    f13c:	6063      	str	r3, [r4, #4]
    if (additional_information < Value8Bit) {
    f13e:	2817      	cmp	r0, #23
    f140:	d915      	bls.n	f16e <advance_internal+0x48>
    if (unlikely(additional_information > Value64Bit))
    f142:	281b      	cmp	r0, #27
    f144:	d842      	bhi.n	f1cc <advance_internal+0xa6>
    size_t bytesNeeded = (size_t)(1 << (additional_information - Value8Bit));
    f146:	3818      	subs	r0, #24
    f148:	2501      	movs	r5, #1
    f14a:	4085      	lsls	r5, r0
    if (unlikely(bytesNeeded > (size_t)(p->end - *offset))) {
    f14c:	6873      	ldr	r3, [r6, #4]
    f14e:	6861      	ldr	r1, [r4, #4]
    f150:	1a5b      	subs	r3, r3, r1
    f152:	429d      	cmp	r5, r3
    f154:	d83f      	bhi.n	f1d6 <advance_internal+0xb0>
    } else if (bytesNeeded == 1) {
    f156:	2d01      	cmp	r5, #1
    f158:	d00d      	beq.n	f176 <advance_internal+0x50>
    } else if (bytesNeeded == 2) {
    f15a:	2d02      	cmp	r5, #2
    f15c:	d02a      	beq.n	f1b4 <advance_internal+0x8e>
    } else if (bytesNeeded == 4) {
    f15e:	2d04      	cmp	r5, #4
    f160:	d02e      	beq.n	f1c0 <advance_internal+0x9a>
        *len =  p->d->get64(p->d, *offset);
    f162:	6830      	ldr	r0, [r6, #0]
    f164:	68c3      	ldr	r3, [r0, #12]
    f166:	4798      	blx	r3
    f168:	4602      	mov	r2, r0
    f16a:	460b      	mov	r3, r1
    f16c:	e008      	b.n	f180 <advance_internal+0x5a>
        *len = additional_information;
    f16e:	b2c2      	uxtb	r2, r0
    f170:	2300      	movs	r3, #0
        return CborNoError;
    f172:	2100      	movs	r1, #0
    f174:	e008      	b.n	f188 <advance_internal+0x62>
        *len = p->d->get8(p->d, *offset);
    f176:	6830      	ldr	r0, [r6, #0]
    f178:	6803      	ldr	r3, [r0, #0]
    f17a:	4798      	blx	r3
    f17c:	4602      	mov	r2, r0
    f17e:	2300      	movs	r3, #0
    *offset += bytesNeeded;
    f180:	6860      	ldr	r0, [r4, #4]
    f182:	4428      	add	r0, r5
    f184:	6060      	str	r0, [r4, #4]
    return CborNoError;
    f186:	2100      	movs	r1, #0
    assert(err == CborNoError);
    f188:	bb51      	cbnz	r1, f1e0 <advance_internal+0xba>
    if (it->type == CborByteStringType || it->type == CborTextStringType) {
    f18a:	7ba1      	ldrb	r1, [r4, #14]
    f18c:	2940      	cmp	r1, #64	; 0x40
    f18e:	d001      	beq.n	f194 <advance_internal+0x6e>
    f190:	2960      	cmp	r1, #96	; 0x60
    f192:	d10b      	bne.n	f1ac <advance_internal+0x86>
        assert(length == (size_t)length);
    f194:	2100      	movs	r1, #0
    f196:	4299      	cmp	r1, r3
    f198:	bf08      	it	eq
    f19a:	4292      	cmpeq	r2, r2
    f19c:	d12a      	bne.n	f1f4 <advance_internal+0xce>
        assert((it->flags & CborIteratorFlag_UnknownLength) == 0);
    f19e:	7be3      	ldrb	r3, [r4, #15]
    f1a0:	f013 0f04 	tst.w	r3, #4
    f1a4:	d130      	bne.n	f208 <advance_internal+0xe2>
        it->offset += length;
    f1a6:	6863      	ldr	r3, [r4, #4]
    f1a8:	4413      	add	r3, r2
    f1aa:	6063      	str	r3, [r4, #4]
    return preparse_next_value(it);
    f1ac:	4620      	mov	r0, r4
    f1ae:	f7ff fe7f 	bl	eeb0 <preparse_next_value>
}
    f1b2:	bd70      	pop	{r4, r5, r6, pc}
        *len =  p->d->get16(p->d, *offset);
    f1b4:	6830      	ldr	r0, [r6, #0]
    f1b6:	6843      	ldr	r3, [r0, #4]
    f1b8:	4798      	blx	r3
    f1ba:	4602      	mov	r2, r0
    f1bc:	2300      	movs	r3, #0
    f1be:	e7df      	b.n	f180 <advance_internal+0x5a>
        *len =  p->d->get32(p->d, *offset);
    f1c0:	6830      	ldr	r0, [r6, #0]
    f1c2:	6883      	ldr	r3, [r0, #8]
    f1c4:	4798      	blx	r3
    f1c6:	4602      	mov	r2, r0
    f1c8:	2300      	movs	r3, #0
    f1ca:	e7d9      	b.n	f180 <advance_internal+0x5a>
    *len = 1;
    f1cc:	2201      	movs	r2, #1
    f1ce:	2300      	movs	r3, #0
        return CborErrorIllegalNumber;
    f1d0:	f240 1105 	movw	r1, #261	; 0x105
    f1d4:	e7d8      	b.n	f188 <advance_internal+0x62>
    *len = 1;
    f1d6:	2201      	movs	r2, #1
    f1d8:	2300      	movs	r3, #0
        return CborErrorUnexpectedEOF;
    f1da:	f240 1101 	movw	r1, #257	; 0x101
    f1de:	e7d3      	b.n	f188 <advance_internal+0x62>
    assert(err == CborNoError);
    f1e0:	f7fc ffdc 	bl	c19c <hal_debugger_connected>
    f1e4:	b100      	cbz	r0, f1e8 <advance_internal+0xc2>
    f1e6:	be01      	bkpt	0x0001
    f1e8:	2300      	movs	r3, #0
    f1ea:	461a      	mov	r2, r3
    f1ec:	4619      	mov	r1, r3
    f1ee:	4618      	mov	r0, r3
    f1f0:	f7fd f9b2 	bl	c558 <__assert_func>
        assert(length == (size_t)length);
    f1f4:	f7fc ffd2 	bl	c19c <hal_debugger_connected>
    f1f8:	b100      	cbz	r0, f1fc <advance_internal+0xd6>
    f1fa:	be01      	bkpt	0x0001
    f1fc:	2300      	movs	r3, #0
    f1fe:	461a      	mov	r2, r3
    f200:	4619      	mov	r1, r3
    f202:	4618      	mov	r0, r3
    f204:	f7fd f9a8 	bl	c558 <__assert_func>
        assert((it->flags & CborIteratorFlag_UnknownLength) == 0);
    f208:	f7fc ffc8 	bl	c19c <hal_debugger_connected>
    f20c:	b100      	cbz	r0, f210 <advance_internal+0xea>
    f20e:	be01      	bkpt	0x0001
    f210:	2300      	movs	r3, #0
    f212:	461a      	mov	r2, r3
    f214:	4619      	mov	r1, r3
    f216:	4618      	mov	r0, r3
    f218:	f7fd f99e 	bl	c558 <__assert_func>

0000f21c <_cbor_value_decode_int64_internal>:
{
    f21c:	b510      	push	{r4, lr}
    f21e:	4604      	mov	r4, r0
    uint8_t val = value->parser->d->get8(value->parser->d, value->offset);
    f220:	6803      	ldr	r3, [r0, #0]
    f222:	6818      	ldr	r0, [r3, #0]
    f224:	6803      	ldr	r3, [r0, #0]
    f226:	6861      	ldr	r1, [r4, #4]
    f228:	4798      	blx	r3
    assert(value->flags & CborIteratorFlag_IntegerValueTooLarge ||
    f22a:	7be3      	ldrb	r3, [r4, #15]
    f22c:	f013 0f01 	tst.w	r3, #1
    f230:	d104      	bne.n	f23c <_cbor_value_decode_int64_internal+0x20>
    f232:	7ba3      	ldrb	r3, [r4, #14]
    f234:	2bfa      	cmp	r3, #250	; 0xfa
    f236:	d001      	beq.n	f23c <_cbor_value_decode_int64_internal+0x20>
    f238:	2bfb      	cmp	r3, #251	; 0xfb
    f23a:	d111      	bne.n	f260 <_cbor_value_decode_int64_internal+0x44>
    assert((val & SmallValueMask) == Value32Bit || (val & SmallValueMask) == Value64Bit);
    f23c:	f000 031e 	and.w	r3, r0, #30
    f240:	2b1a      	cmp	r3, #26
    f242:	d117      	bne.n	f274 <_cbor_value_decode_int64_internal+0x58>
    if ((val & 1) == (Value32Bit & 1))
    f244:	f010 0f01 	tst.w	r0, #1
    f248:	d01e      	beq.n	f288 <_cbor_value_decode_int64_internal+0x6c>
    assert((val & SmallValueMask) == Value64Bit);
    f24a:	f000 001f 	and.w	r0, r0, #31
    f24e:	281b      	cmp	r0, #27
    f250:	d122      	bne.n	f298 <_cbor_value_decode_int64_internal+0x7c>
        return value->parser->d->get64(value->parser->d, value->offset + 1);
    f252:	6823      	ldr	r3, [r4, #0]
    f254:	6818      	ldr	r0, [r3, #0]
    f256:	68c3      	ldr	r3, [r0, #12]
    f258:	6861      	ldr	r1, [r4, #4]
    f25a:	3101      	adds	r1, #1
    f25c:	4798      	blx	r3
}
    f25e:	bd10      	pop	{r4, pc}
    assert(value->flags & CborIteratorFlag_IntegerValueTooLarge ||
    f260:	f7fc ff9c 	bl	c19c <hal_debugger_connected>
    f264:	b100      	cbz	r0, f268 <_cbor_value_decode_int64_internal+0x4c>
    f266:	be01      	bkpt	0x0001
    f268:	2300      	movs	r3, #0
    f26a:	461a      	mov	r2, r3
    f26c:	4619      	mov	r1, r3
    f26e:	4618      	mov	r0, r3
    f270:	f7fd f972 	bl	c558 <__assert_func>
    assert((val & SmallValueMask) == Value32Bit || (val & SmallValueMask) == Value64Bit);
    f274:	f7fc ff92 	bl	c19c <hal_debugger_connected>
    f278:	b100      	cbz	r0, f27c <_cbor_value_decode_int64_internal+0x60>
    f27a:	be01      	bkpt	0x0001
    f27c:	2300      	movs	r3, #0
    f27e:	461a      	mov	r2, r3
    f280:	4619      	mov	r1, r3
    f282:	4618      	mov	r0, r3
    f284:	f7fd f968 	bl	c558 <__assert_func>
        return value->parser->d->get32(value->parser->d, value->offset + 1);
    f288:	6823      	ldr	r3, [r4, #0]
    f28a:	6818      	ldr	r0, [r3, #0]
    f28c:	6883      	ldr	r3, [r0, #8]
    f28e:	6861      	ldr	r1, [r4, #4]
    f290:	3101      	adds	r1, #1
    f292:	4798      	blx	r3
    f294:	2100      	movs	r1, #0
    f296:	e7e2      	b.n	f25e <_cbor_value_decode_int64_internal+0x42>
    assert((val & SmallValueMask) == Value64Bit);
    f298:	f7fc ff80 	bl	c19c <hal_debugger_connected>
    f29c:	b100      	cbz	r0, f2a0 <_cbor_value_decode_int64_internal+0x84>
    f29e:	be01      	bkpt	0x0001
    f2a0:	2300      	movs	r3, #0
    f2a2:	461a      	mov	r2, r3
    f2a4:	4619      	mov	r1, r3
    f2a6:	4618      	mov	r0, r3
    f2a8:	f7fd f956 	bl	c558 <__assert_func>

0000f2ac <cbor_parser_init>:
{
    f2ac:	b510      	push	{r4, lr}
    f2ae:	4604      	mov	r4, r0
    f2b0:	4618      	mov	r0, r3
    memset(parser, 0, sizeof(*parser));
    f2b2:	2300      	movs	r3, #0
    f2b4:	6053      	str	r3, [r2, #4]
    f2b6:	6093      	str	r3, [r2, #8]
    parser->d = d;
    f2b8:	6014      	str	r4, [r2, #0]
    parser->end = d->message_size;
    f2ba:	69a4      	ldr	r4, [r4, #24]
    f2bc:	6054      	str	r4, [r2, #4]
    parser->flags = flags;
    f2be:	6091      	str	r1, [r2, #8]
    it->parser = parser;
    f2c0:	6002      	str	r2, [r0, #0]
    it->offset = 0;
    f2c2:	6043      	str	r3, [r0, #4]
    it->remaining = 1;/* there's one type altogether, usually an array or map */
    f2c4:	2301      	movs	r3, #1
    f2c6:	6083      	str	r3, [r0, #8]
    return preparse_value(it);
    f2c8:	f7ff fd54 	bl	ed74 <preparse_value>
}
    f2cc:	bd10      	pop	{r4, pc}

0000f2ce <cbor_value_advance_fixed>:
{
    f2ce:	b510      	push	{r4, lr}
    f2d0:	4604      	mov	r4, r0
    assert(it->type != CborInvalidType);
    f2d2:	7b80      	ldrb	r0, [r0, #14]
    f2d4:	28ff      	cmp	r0, #255	; 0xff
    f2d6:	d008      	beq.n	f2ea <cbor_value_advance_fixed+0x1c>
    assert(is_fixed_type(it->type));
    f2d8:	f7ff fd38 	bl	ed4c <is_fixed_type>
    f2dc:	b178      	cbz	r0, f2fe <cbor_value_advance_fixed+0x30>
    if (!it->remaining)
    f2de:	68a3      	ldr	r3, [r4, #8]
    f2e0:	b1bb      	cbz	r3, f312 <cbor_value_advance_fixed+0x44>
    return advance_internal(it);
    f2e2:	4620      	mov	r0, r4
    f2e4:	f7ff ff1f 	bl	f126 <advance_internal>
}
    f2e8:	bd10      	pop	{r4, pc}
    assert(it->type != CborInvalidType);
    f2ea:	f7fc ff57 	bl	c19c <hal_debugger_connected>
    f2ee:	b100      	cbz	r0, f2f2 <cbor_value_advance_fixed+0x24>
    f2f0:	be01      	bkpt	0x0001
    f2f2:	2300      	movs	r3, #0
    f2f4:	461a      	mov	r2, r3
    f2f6:	4619      	mov	r1, r3
    f2f8:	4618      	mov	r0, r3
    f2fa:	f7fd f92d 	bl	c558 <__assert_func>
    assert(is_fixed_type(it->type));
    f2fe:	f7fc ff4d 	bl	c19c <hal_debugger_connected>
    f302:	b100      	cbz	r0, f306 <cbor_value_advance_fixed+0x38>
    f304:	be01      	bkpt	0x0001
    f306:	2300      	movs	r3, #0
    f308:	461a      	mov	r2, r3
    f30a:	4619      	mov	r1, r3
    f30c:	4618      	mov	r0, r3
    f30e:	f7fd f923 	bl	c558 <__assert_func>
        return CborErrorAdvancePastEOF;
    f312:	2003      	movs	r0, #3
    f314:	e7e8      	b.n	f2e8 <cbor_value_advance_fixed+0x1a>

0000f316 <cbor_value_enter_container>:
{
    f316:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    f318:	4605      	mov	r5, r0
    f31a:	460c      	mov	r4, r1
{ return it->type == CborArrayType || it->type == CborMapType; }
    f31c:	7b83      	ldrb	r3, [r0, #14]
    f31e:	2b80      	cmp	r3, #128	; 0x80
    f320:	d021      	beq.n	f366 <cbor_value_enter_container+0x50>
    f322:	2ba0      	cmp	r3, #160	; 0xa0
    f324:	d01d      	beq.n	f362 <cbor_value_enter_container+0x4c>
    f326:	2300      	movs	r3, #0
    assert(cbor_value_is_container(it));
    f328:	b1fb      	cbz	r3, f36a <cbor_value_enter_container+0x54>
    *recursed = *it;
    f32a:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
    f32e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    if (it->flags & CborIteratorFlag_UnknownLength) {
    f332:	7beb      	ldrb	r3, [r5, #15]
    f334:	f013 0f04 	tst.w	r3, #4
    f338:	d021      	beq.n	f37e <cbor_value_enter_container+0x68>
        recursed->remaining = UINT32_MAX;
    f33a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    f33e:	60a3      	str	r3, [r4, #8]
        ++recursed->offset;
    f340:	460b      	mov	r3, r1
    f342:	3301      	adds	r3, #1
    f344:	6063      	str	r3, [r4, #4]
        err = preparse_value(recursed);
    f346:	4620      	mov	r0, r4
    f348:	f7ff fd14 	bl	ed74 <preparse_value>
        if (err != CborErrorUnexpectedBreak)
    f34c:	f5b0 7f81 	cmp.w	r0, #258	; 0x102
    f350:	d106      	bne.n	f360 <cbor_value_enter_container+0x4a>
        ++recursed->offset;
    f352:	6863      	ldr	r3, [r4, #4]
    f354:	3301      	adds	r3, #1
    f356:	6063      	str	r3, [r4, #4]
    recursed->type = CborInvalidType;
    f358:	23ff      	movs	r3, #255	; 0xff
    f35a:	73a3      	strb	r3, [r4, #14]
    recursed->remaining = 0;
    f35c:	2000      	movs	r0, #0
    f35e:	60a0      	str	r0, [r4, #8]
}
    f360:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    f362:	2301      	movs	r3, #1
    f364:	e7e0      	b.n	f328 <cbor_value_enter_container+0x12>
    f366:	2301      	movs	r3, #1
    f368:	e7de      	b.n	f328 <cbor_value_enter_container+0x12>
    assert(cbor_value_is_container(it));
    f36a:	f7fc ff17 	bl	c19c <hal_debugger_connected>
    f36e:	b100      	cbz	r0, f372 <cbor_value_enter_container+0x5c>
    f370:	be01      	bkpt	0x0001
    f372:	2300      	movs	r3, #0
    f374:	461a      	mov	r2, r3
    f376:	4619      	mov	r1, r3
    f378:	4618      	mov	r0, r3
    f37a:	f7fd f8ed 	bl	c558 <__assert_func>
        err = extract_number(recursed->parser, &recursed->offset, &len);
    f37e:	6827      	ldr	r7, [r4, #0]
    uint8_t additional_information = p->d->get8(p->d, *offset) & SmallValueMask;
    f380:	6838      	ldr	r0, [r7, #0]
    f382:	6803      	ldr	r3, [r0, #0]
    f384:	6861      	ldr	r1, [r4, #4]
    f386:	4798      	blx	r3
    f388:	f000 001f 	and.w	r0, r0, #31
    ++*offset;
    f38c:	6863      	ldr	r3, [r4, #4]
    f38e:	3301      	adds	r3, #1
    f390:	6063      	str	r3, [r4, #4]
    if (additional_information < Value8Bit) {
    f392:	2817      	cmp	r0, #23
    f394:	d915      	bls.n	f3c2 <cbor_value_enter_container+0xac>
    if (unlikely(additional_information > Value64Bit))
    f396:	281b      	cmp	r0, #27
    f398:	d841      	bhi.n	f41e <cbor_value_enter_container+0x108>
    size_t bytesNeeded = (size_t)(1 << (additional_information - Value8Bit));
    f39a:	3818      	subs	r0, #24
    f39c:	2601      	movs	r6, #1
    f39e:	4086      	lsls	r6, r0
    if (unlikely(bytesNeeded > (size_t)(p->end - *offset))) {
    f3a0:	687b      	ldr	r3, [r7, #4]
    f3a2:	6861      	ldr	r1, [r4, #4]
    f3a4:	1a5b      	subs	r3, r3, r1
    f3a6:	429e      	cmp	r6, r3
    f3a8:	d83e      	bhi.n	f428 <cbor_value_enter_container+0x112>
    } else if (bytesNeeded == 1) {
    f3aa:	2e01      	cmp	r6, #1
    f3ac:	d00d      	beq.n	f3ca <cbor_value_enter_container+0xb4>
    } else if (bytesNeeded == 2) {
    f3ae:	2e02      	cmp	r6, #2
    f3b0:	d029      	beq.n	f406 <cbor_value_enter_container+0xf0>
    } else if (bytesNeeded == 4) {
    f3b2:	2e04      	cmp	r6, #4
    f3b4:	d02d      	beq.n	f412 <cbor_value_enter_container+0xfc>
        *len =  p->d->get64(p->d, *offset);
    f3b6:	6838      	ldr	r0, [r7, #0]
    f3b8:	68c3      	ldr	r3, [r0, #12]
    f3ba:	4798      	blx	r3
    f3bc:	4602      	mov	r2, r0
    f3be:	460b      	mov	r3, r1
    f3c0:	e008      	b.n	f3d4 <cbor_value_enter_container+0xbe>
        *len = additional_information;
    f3c2:	b2c2      	uxtb	r2, r0
    f3c4:	2300      	movs	r3, #0
        return CborNoError;
    f3c6:	2100      	movs	r1, #0
    f3c8:	e008      	b.n	f3dc <cbor_value_enter_container+0xc6>
        *len = p->d->get8(p->d, *offset);
    f3ca:	6838      	ldr	r0, [r7, #0]
    f3cc:	6803      	ldr	r3, [r0, #0]
    f3ce:	4798      	blx	r3
    f3d0:	4602      	mov	r2, r0
    f3d2:	2300      	movs	r3, #0
    *offset += bytesNeeded;
    f3d4:	6860      	ldr	r0, [r4, #4]
    f3d6:	4430      	add	r0, r6
    f3d8:	6060      	str	r0, [r4, #4]
    return CborNoError;
    f3da:	2100      	movs	r1, #0
        assert(err == CborNoError);
    f3dc:	bb49      	cbnz	r1, f432 <cbor_value_enter_container+0x11c>
        recursed->remaining = (uint32_t)len;
    f3de:	60a2      	str	r2, [r4, #8]
        if (recursed->remaining != len || len == UINT32_MAX) {
    f3e0:	2100      	movs	r1, #0
    f3e2:	4299      	cmp	r1, r3
    f3e4:	bf08      	it	eq
    f3e6:	4292      	cmpeq	r2, r2
    f3e8:	d12d      	bne.n	f446 <cbor_value_enter_container+0x130>
    f3ea:	2b00      	cmp	r3, #0
    f3ec:	bf08      	it	eq
    f3ee:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
    f3f2:	d028      	beq.n	f446 <cbor_value_enter_container+0x130>
        if (recursed->type == CborMapType) {
    f3f4:	7ba1      	ldrb	r1, [r4, #14]
    f3f6:	29a0      	cmp	r1, #160	; 0xa0
    f3f8:	d02a      	beq.n	f450 <cbor_value_enter_container+0x13a>
        if (len != 0)
    f3fa:	4313      	orrs	r3, r2
    f3fc:	d0ac      	beq.n	f358 <cbor_value_enter_container+0x42>
            return preparse_value(recursed);
    f3fe:	4620      	mov	r0, r4
    f400:	f7ff fcb8 	bl	ed74 <preparse_value>
    f404:	e7ac      	b.n	f360 <cbor_value_enter_container+0x4a>
        *len =  p->d->get16(p->d, *offset);
    f406:	6838      	ldr	r0, [r7, #0]
    f408:	6843      	ldr	r3, [r0, #4]
    f40a:	4798      	blx	r3
    f40c:	4602      	mov	r2, r0
    f40e:	2300      	movs	r3, #0
    f410:	e7e0      	b.n	f3d4 <cbor_value_enter_container+0xbe>
        *len =  p->d->get32(p->d, *offset);
    f412:	6838      	ldr	r0, [r7, #0]
    f414:	6883      	ldr	r3, [r0, #8]
    f416:	4798      	blx	r3
    f418:	4602      	mov	r2, r0
    f41a:	2300      	movs	r3, #0
    f41c:	e7da      	b.n	f3d4 <cbor_value_enter_container+0xbe>
    *len = 1;
    f41e:	2201      	movs	r2, #1
    f420:	2300      	movs	r3, #0
        return CborErrorIllegalNumber;
    f422:	f240 1105 	movw	r1, #261	; 0x105
    f426:	e7d9      	b.n	f3dc <cbor_value_enter_container+0xc6>
    *len = 1;
    f428:	2201      	movs	r2, #1
    f42a:	2300      	movs	r3, #0
        return CborErrorUnexpectedEOF;
    f42c:	f240 1101 	movw	r1, #257	; 0x101
    f430:	e7d4      	b.n	f3dc <cbor_value_enter_container+0xc6>
        assert(err == CborNoError);
    f432:	f7fc feb3 	bl	c19c <hal_debugger_connected>
    f436:	b100      	cbz	r0, f43a <cbor_value_enter_container+0x124>
    f438:	be01      	bkpt	0x0001
    f43a:	2300      	movs	r3, #0
    f43c:	461a      	mov	r2, r3
    f43e:	4619      	mov	r1, r3
    f440:	4618      	mov	r0, r3
    f442:	f7fd f889 	bl	c558 <__assert_func>
            recursed->offset = it->offset;
    f446:	686b      	ldr	r3, [r5, #4]
    f448:	6063      	str	r3, [r4, #4]
            return CborErrorDataTooLarge;
    f44a:	f44f 6080 	mov.w	r0, #1024	; 0x400
    f44e:	e787      	b.n	f360 <cbor_value_enter_container+0x4a>
            if (recursed->remaining > UINT32_MAX / 2) {
    f450:	2a00      	cmp	r2, #0
    f452:	db02      	blt.n	f45a <cbor_value_enter_container+0x144>
            recursed->remaining *= 2;
    f454:	0056      	lsls	r6, r2, #1
    f456:	60a6      	str	r6, [r4, #8]
    f458:	e7cf      	b.n	f3fa <cbor_value_enter_container+0xe4>
                recursed->offset = it->offset;
    f45a:	686b      	ldr	r3, [r5, #4]
    f45c:	6063      	str	r3, [r4, #4]
                return CborErrorDataTooLarge;
    f45e:	f44f 6080 	mov.w	r0, #1024	; 0x400
    f462:	e77d      	b.n	f360 <cbor_value_enter_container+0x4a>

0000f464 <cbor_value_leave_container>:
{
    f464:	b508      	push	{r3, lr}
    f466:	7b83      	ldrb	r3, [r0, #14]
    f468:	2b80      	cmp	r3, #128	; 0x80
    f46a:	d00d      	beq.n	f488 <cbor_value_leave_container+0x24>
    f46c:	2ba0      	cmp	r3, #160	; 0xa0
    f46e:	d009      	beq.n	f484 <cbor_value_leave_container+0x20>
    f470:	2300      	movs	r3, #0
    assert(cbor_value_is_container(it));
    f472:	b15b      	cbz	r3, f48c <cbor_value_leave_container+0x28>
    assert(recursed->type == CborInvalidType);
    f474:	7b8b      	ldrb	r3, [r1, #14]
    f476:	2bff      	cmp	r3, #255	; 0xff
    f478:	d112      	bne.n	f4a0 <cbor_value_leave_container+0x3c>
    it->offset = recursed->offset;
    f47a:	684b      	ldr	r3, [r1, #4]
    f47c:	6043      	str	r3, [r0, #4]
    return preparse_next_value(it);
    f47e:	f7ff fd17 	bl	eeb0 <preparse_next_value>
}
    f482:	bd08      	pop	{r3, pc}
    f484:	2301      	movs	r3, #1
    f486:	e7f4      	b.n	f472 <cbor_value_leave_container+0xe>
    f488:	2301      	movs	r3, #1
    f48a:	e7f2      	b.n	f472 <cbor_value_leave_container+0xe>
    assert(cbor_value_is_container(it));
    f48c:	f7fc fe86 	bl	c19c <hal_debugger_connected>
    f490:	b100      	cbz	r0, f494 <cbor_value_leave_container+0x30>
    f492:	be01      	bkpt	0x0001
    f494:	2300      	movs	r3, #0
    f496:	461a      	mov	r2, r3
    f498:	4619      	mov	r1, r3
    f49a:	4618      	mov	r0, r3
    f49c:	f7fd f85c 	bl	c558 <__assert_func>
    assert(recursed->type == CborInvalidType);
    f4a0:	f7fc fe7c 	bl	c19c <hal_debugger_connected>
    f4a4:	b100      	cbz	r0, f4a8 <cbor_value_leave_container+0x44>
    f4a6:	be01      	bkpt	0x0001
    f4a8:	2300      	movs	r3, #0
    f4aa:	461a      	mov	r2, r3
    f4ac:	4619      	mov	r1, r3
    f4ae:	4618      	mov	r0, r3
    f4b0:	f7fd f852 	bl	c558 <__assert_func>

0000f4b4 <_cbor_value_copy_string>:
 * \sa cbor_value_dup_text_string(), cbor_value_copy_text_string(), cbor_value_get_string_length(), cbor_value_calculate_string_length()
 */

CborError _cbor_value_copy_string(const CborValue *value, void *buffer,
                                 size_t *buflen, CborValue *next)
{
    f4b4:	b510      	push	{r4, lr}
    f4b6:	b084      	sub	sp, #16
    bool copied_all;
    CborError err = iterate_string_chunks(value, (char*)buffer, buflen, &copied_all, next,
    f4b8:	460c      	mov	r4, r1
    f4ba:	b179      	cbz	r1, f4dc <_cbor_value_copy_string+0x28>
                                          buffer ? (IterateFunction) value->parser->d->cpy : iterate_noop);
    f4bc:	6801      	ldr	r1, [r0, #0]
    f4be:	6809      	ldr	r1, [r1, #0]
    CborError err = iterate_string_chunks(value, (char*)buffer, buflen, &copied_all, next,
    f4c0:	6949      	ldr	r1, [r1, #20]
    f4c2:	9101      	str	r1, [sp, #4]
    f4c4:	9300      	str	r3, [sp, #0]
    f4c6:	f10d 030f 	add.w	r3, sp, #15
    f4ca:	4621      	mov	r1, r4
    f4cc:	f7ff fd72 	bl	efb4 <iterate_string_chunks>
    return err ? err :
    f4d0:	b910      	cbnz	r0, f4d8 <_cbor_value_copy_string+0x24>
                 copied_all ? CborNoError : CborErrorOutOfMemory;
    f4d2:	f89d 300f 	ldrb.w	r3, [sp, #15]
    return err ? err :
    f4d6:	b11b      	cbz	r3, f4e0 <_cbor_value_copy_string+0x2c>
}
    f4d8:	b004      	add	sp, #16
    f4da:	bd10      	pop	{r4, pc}
    CborError err = iterate_string_chunks(value, (char*)buffer, buflen, &copied_all, next,
    f4dc:	4902      	ldr	r1, [pc, #8]	; (f4e8 <_cbor_value_copy_string+0x34>)
    f4de:	e7f0      	b.n	f4c2 <_cbor_value_copy_string+0xe>
    return err ? err :
    f4e0:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
    f4e4:	e7f8      	b.n	f4d8 <_cbor_value_copy_string+0x24>
    f4e6:	bf00      	nop
    f4e8:	0000ed71 	.word	0x0000ed71

0000f4ec <hexDump>:
 *      by a colon (":"), enclosed in curly braces ("{" and "}").
 *      If the map length is indeterminate, an underscore ("_") appears immediately after the opening brace.
 */

static int hexDump(FILE *out, const uint8_t *buffer, size_t n)
{
    f4ec:	b570      	push	{r4, r5, r6, lr}
    f4ee:	4606      	mov	r6, r0
    f4f0:	460c      	mov	r4, r1
    f4f2:	4615      	mov	r5, r2
    while (n--) {
    f4f4:	462b      	mov	r3, r5
    f4f6:	3d01      	subs	r5, #1
    f4f8:	b143      	cbz	r3, f50c <hexDump+0x20>
        int r = fprintf(out, "%02" PRIx8, *buffer++);
    f4fa:	f814 2b01 	ldrb.w	r2, [r4], #1
    f4fe:	4904      	ldr	r1, [pc, #16]	; (f510 <hexDump+0x24>)
    f500:	4630      	mov	r0, r6
    f502:	f001 fcb3 	bl	10e6c <fprintf>
        if (r < 0)
    f506:	2800      	cmp	r0, #0
    f508:	daf4      	bge.n	f4f4 <hexDump+0x8>
    f50a:	e000      	b.n	f50e <hexDump+0x22>
            return r;
    }
    return 0;   /* should be n * 2, but we don't have the original n anymore */
    f50c:	2000      	movs	r0, #0
}
    f50e:	bd70      	pop	{r4, r5, r6, pc}
    f510:	00011a8c 	.word	0x00011a8c

0000f514 <utf8EscapedDump>:

/* This function decodes buffer as UTF-8 and prints as escaped UTF-16.
 * On UTF-8 decoding error, it returns CborErrorInvalidUtf8TextString */
static int utf8EscapedDump(FILE *out, const char *buffer, size_t n)
{
    f514:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    f516:	4606      	mov	r6, r0
    uint32_t uc;
    while (n--) {
    f518:	e07e      	b.n	f618 <utf8EscapedDump+0x104>
        uc = (uint8_t)*buffer++;
        if (uc < 0x80) {
            /* single-byte UTF-8 */
            if (uc < 0x7f && uc >= 0x20 && uc != '\\' && uc != '"') {
                if (fprintf(out, "%c", (char)uc) < 0)
    f51a:	4985      	ldr	r1, [pc, #532]	; (f730 <utf8EscapedDump+0x21c>)
    f51c:	4630      	mov	r0, r6
    f51e:	f001 fca5 	bl	10e6c <fprintf>
    f522:	2800      	cmp	r0, #0
    f524:	f2c0 80e0 	blt.w	f6e8 <utf8EscapedDump+0x1d4>
        uc = (uint8_t)*buffer++;
    f528:	4629      	mov	r1, r5
    f52a:	e074      	b.n	f616 <utf8EscapedDump+0x102>
                continue;
            }

            /* print as an escape sequence */
            char escaped = (char)uc;
            switch (uc) {
    f52c:	2a5c      	cmp	r2, #92	; 0x5c
    f52e:	d169      	bne.n	f604 <utf8EscapedDump+0xf0>
                escaped = 't';
                break;
            default:
                goto print_utf16;
            }
            if (fprintf(out, "\\%c", escaped) < 0)
    f530:	4980      	ldr	r1, [pc, #512]	; (f734 <utf8EscapedDump+0x220>)
    f532:	4630      	mov	r0, r6
    f534:	f001 fc9a 	bl	10e6c <fprintf>
    f538:	2800      	cmp	r0, #0
    f53a:	f2c0 80d7 	blt.w	f6ec <utf8EscapedDump+0x1d8>
        uc = (uint8_t)*buffer++;
    f53e:	4629      	mov	r1, r5
    f540:	e069      	b.n	f616 <utf8EscapedDump+0x102>
                escaped = 'f';
    f542:	2266      	movs	r2, #102	; 0x66
                break;
    f544:	e7f4      	b.n	f530 <utf8EscapedDump+0x1c>
                escaped = 'n';
    f546:	226e      	movs	r2, #110	; 0x6e
                break;
    f548:	e7f2      	b.n	f530 <utf8EscapedDump+0x1c>
                escaped = 'r';
    f54a:	2272      	movs	r2, #114	; 0x72
                break;
    f54c:	e7f0      	b.n	f530 <utf8EscapedDump+0x1c>
                escaped = 't';
    f54e:	2274      	movs	r2, #116	; 0x74
                break;
    f550:	e7ee      	b.n	f530 <utf8EscapedDump+0x1c>
                escaped = 'b';
    f552:	2262      	movs	r2, #98	; 0x62
    f554:	e7ec      	b.n	f530 <utf8EscapedDump+0x1c>
        }

        /* multi-byte UTF-8, decode it */
        unsigned charsNeeded;
        uint32_t min_uc;
        if (unlikely(uc <= 0xC1))
    f556:	2ac1      	cmp	r2, #193	; 0xc1
    f558:	f240 80ca 	bls.w	f6f0 <utf8EscapedDump+0x1dc>
            return CborErrorInvalidUtf8TextString;
        if (uc < 0xE0) {
    f55c:	2adf      	cmp	r2, #223	; 0xdf
    f55e:	d830      	bhi.n	f5c2 <utf8EscapedDump+0xae>
            /* two-byte UTF-8 */
            charsNeeded = 2;
            min_uc = 0x80;
            uc &= 0x1f;
    f560:	f002 021f 	and.w	r2, r2, #31
            min_uc = 0x80;
    f564:	f04f 0c80 	mov.w	ip, #128	; 0x80
            charsNeeded = 2;
    f568:	2302      	movs	r3, #2
            uc &= 0x07;
        } else {
            return CborErrorInvalidUtf8TextString;
        }

        if (n < charsNeeded - 1)
    f56a:	1e58      	subs	r0, r3, #1
    f56c:	42b8      	cmp	r0, r7
    f56e:	f200 80c5 	bhi.w	f6fc <utf8EscapedDump+0x1e8>
            return CborErrorInvalidUtf8TextString;

        /* first continuation character */
        uint8_t b = (uint8_t)*buffer++;
    f572:	3102      	adds	r1, #2
    f574:	782c      	ldrb	r4, [r5, #0]
        if ((b & 0xc0) != 0x80)
    f576:	f004 00c0 	and.w	r0, r4, #192	; 0xc0
    f57a:	2880      	cmp	r0, #128	; 0x80
    f57c:	f040 80c1 	bne.w	f702 <utf8EscapedDump+0x1ee>
            return CborErrorInvalidUtf8TextString;
        uc <<= 6;
        uc |= b & 0x3f;
    f580:	f004 043f 	and.w	r4, r4, #63	; 0x3f
    f584:	ea44 1482 	orr.w	r4, r4, r2, lsl #6

        if (charsNeeded > 2) {
    f588:	2b02      	cmp	r3, #2
    f58a:	d92b      	bls.n	f5e4 <utf8EscapedDump+0xd0>
            /* second continuation character */
            b = (uint8_t)*buffer++;
    f58c:	1ca8      	adds	r0, r5, #2
    f58e:	786a      	ldrb	r2, [r5, #1]
            if ((b & 0xc0) != 0x80)
    f590:	f002 01c0 	and.w	r1, r2, #192	; 0xc0
    f594:	2980      	cmp	r1, #128	; 0x80
    f596:	f040 80b7 	bne.w	f708 <utf8EscapedDump+0x1f4>
                return CborErrorInvalidUtf8TextString;
            uc <<= 6;
            uc |= b & 0x3f;
    f59a:	f002 023f 	and.w	r2, r2, #63	; 0x3f
    f59e:	ea42 1484 	orr.w	r4, r2, r4, lsl #6

            if (charsNeeded > 3) {
    f5a2:	2b03      	cmp	r3, #3
    f5a4:	f240 808c 	bls.w	f6c0 <utf8EscapedDump+0x1ac>
                /* third continuation character */
                b = (uint8_t)*buffer++;
    f5a8:	1ce8      	adds	r0, r5, #3
    f5aa:	78aa      	ldrb	r2, [r5, #2]
                if ((b & 0xc0) != 0x80)
    f5ac:	f002 01c0 	and.w	r1, r2, #192	; 0xc0
    f5b0:	2980      	cmp	r1, #128	; 0x80
    f5b2:	f040 80ac 	bne.w	f70e <utf8EscapedDump+0x1fa>
                    return CborErrorInvalidUtf8TextString;
                uc <<= 6;
                uc |= b & 0x3f;
    f5b6:	f002 023f 	and.w	r2, r2, #63	; 0x3f
    f5ba:	ea42 1484 	orr.w	r4, r2, r4, lsl #6
                b = (uint8_t)*buffer++;
    f5be:	4605      	mov	r5, r0
    f5c0:	e011      	b.n	f5e6 <utf8EscapedDump+0xd2>
        } else if (uc < 0xF0) {
    f5c2:	2aef      	cmp	r2, #239	; 0xef
    f5c4:	d805      	bhi.n	f5d2 <utf8EscapedDump+0xbe>
            uc &= 0x0f;
    f5c6:	f002 020f 	and.w	r2, r2, #15
            min_uc = 0x800;
    f5ca:	f44f 6c00 	mov.w	ip, #2048	; 0x800
            charsNeeded = 3;
    f5ce:	2303      	movs	r3, #3
    f5d0:	e7cb      	b.n	f56a <utf8EscapedDump+0x56>
        } else if (uc < 0xF5) {
    f5d2:	2af4      	cmp	r2, #244	; 0xf4
    f5d4:	f200 808f 	bhi.w	f6f6 <utf8EscapedDump+0x1e2>
            uc &= 0x07;
    f5d8:	f002 0207 	and.w	r2, r2, #7
            min_uc = 0x10000;
    f5dc:	f44f 3c80 	mov.w	ip, #65536	; 0x10000
            charsNeeded = 4;
    f5e0:	2304      	movs	r3, #4
    f5e2:	e7c2      	b.n	f56a <utf8EscapedDump+0x56>
        uint8_t b = (uint8_t)*buffer++;
    f5e4:	460d      	mov	r5, r1
            }
        }

        /* overlong sequence? surrogate pair? out or range? */
        if (uc < min_uc || uc - 0xd800U < 2048U || uc > 0x10ffff)
    f5e6:	4564      	cmp	r4, ip
    f5e8:	f0c0 8094 	bcc.w	f714 <utf8EscapedDump+0x200>
    f5ec:	f5a4 4258 	sub.w	r2, r4, #55296	; 0xd800
    f5f0:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
    f5f4:	f0c0 8091 	bcc.w	f71a <utf8EscapedDump+0x206>
    f5f8:	f5b4 1f88 	cmp.w	r4, #1114112	; 0x110000
    f5fc:	f080 8090 	bcs.w	f720 <utf8EscapedDump+0x20c>
            return CborErrorInvalidUtf8TextString;

        /* now print the sequence */
        if (charsNeeded > 3) {
    f600:	2b03      	cmp	r3, #3
    f602:	d85f      	bhi.n	f6c4 <utf8EscapedDump+0x1b0>
                        (uc % 0x0400) + 0xdc00) < 0)
                return CborErrorIO;
        } else {
print_utf16:
            /* no surrogate pair needed */
            if (fprintf(out, "\\u%04" PRIX32, uc) < 0)
    f604:	4622      	mov	r2, r4
    f606:	494c      	ldr	r1, [pc, #304]	; (f738 <utf8EscapedDump+0x224>)
    f608:	4630      	mov	r0, r6
    f60a:	f001 fc2f 	bl	10e6c <fprintf>
    f60e:	2800      	cmp	r0, #0
    f610:	f2c0 808b 	blt.w	f72a <utf8EscapedDump+0x216>
    f614:	4629      	mov	r1, r5
    f616:	463a      	mov	r2, r7
    while (n--) {
    f618:	1e57      	subs	r7, r2, #1
    f61a:	2a00      	cmp	r2, #0
    f61c:	d062      	beq.n	f6e4 <utf8EscapedDump+0x1d0>
        uc = (uint8_t)*buffer++;
    f61e:	460d      	mov	r5, r1
    f620:	f815 2b01 	ldrb.w	r2, [r5], #1
    f624:	4614      	mov	r4, r2
        if (uc < 0x80) {
    f626:	2a7f      	cmp	r2, #127	; 0x7f
    f628:	d895      	bhi.n	f556 <utf8EscapedDump+0x42>
            if (uc < 0x7f && uc >= 0x20 && uc != '\\' && uc != '"') {
    f62a:	f1a2 0320 	sub.w	r3, r2, #32
    f62e:	2b5e      	cmp	r3, #94	; 0x5e
    f630:	d804      	bhi.n	f63c <utf8EscapedDump+0x128>
    f632:	2a5c      	cmp	r2, #92	; 0x5c
    f634:	d002      	beq.n	f63c <utf8EscapedDump+0x128>
    f636:	2a22      	cmp	r2, #34	; 0x22
    f638:	f47f af6f 	bne.w	f51a <utf8EscapedDump+0x6>
            switch (uc) {
    f63c:	2a22      	cmp	r2, #34	; 0x22
    f63e:	f63f af75 	bhi.w	f52c <utf8EscapedDump+0x18>
    f642:	2a08      	cmp	r2, #8
    f644:	d3de      	bcc.n	f604 <utf8EscapedDump+0xf0>
    f646:	f1a2 0308 	sub.w	r3, r2, #8
    f64a:	2b1a      	cmp	r3, #26
    f64c:	d8da      	bhi.n	f604 <utf8EscapedDump+0xf0>
    f64e:	a101      	add	r1, pc, #4	; (adr r1, f654 <utf8EscapedDump+0x140>)
    f650:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
    f654:	0000f553 	.word	0x0000f553
    f658:	0000f54f 	.word	0x0000f54f
    f65c:	0000f547 	.word	0x0000f547
    f660:	0000f605 	.word	0x0000f605
    f664:	0000f543 	.word	0x0000f543
    f668:	0000f54b 	.word	0x0000f54b
    f66c:	0000f605 	.word	0x0000f605
    f670:	0000f605 	.word	0x0000f605
    f674:	0000f605 	.word	0x0000f605
    f678:	0000f605 	.word	0x0000f605
    f67c:	0000f605 	.word	0x0000f605
    f680:	0000f605 	.word	0x0000f605
    f684:	0000f605 	.word	0x0000f605
    f688:	0000f605 	.word	0x0000f605
    f68c:	0000f605 	.word	0x0000f605
    f690:	0000f605 	.word	0x0000f605
    f694:	0000f605 	.word	0x0000f605
    f698:	0000f605 	.word	0x0000f605
    f69c:	0000f605 	.word	0x0000f605
    f6a0:	0000f605 	.word	0x0000f605
    f6a4:	0000f605 	.word	0x0000f605
    f6a8:	0000f605 	.word	0x0000f605
    f6ac:	0000f605 	.word	0x0000f605
    f6b0:	0000f605 	.word	0x0000f605
    f6b4:	0000f605 	.word	0x0000f605
    f6b8:	0000f605 	.word	0x0000f605
    f6bc:	0000f531 	.word	0x0000f531
            b = (uint8_t)*buffer++;
    f6c0:	4605      	mov	r5, r0
    f6c2:	e790      	b.n	f5e6 <utf8EscapedDump+0xd2>
                        (uc % 0x0400) + 0xdc00) < 0)
    f6c4:	f3c4 0309 	ubfx	r3, r4, #0, #10
            if (fprintf(out, "\\u%04" PRIX32 "\\u%04" PRIX32,
    f6c8:	f503 435c 	add.w	r3, r3, #56320	; 0xdc00
    f6cc:	f24d 72c0 	movw	r2, #55232	; 0xd7c0
    f6d0:	eb02 2294 	add.w	r2, r2, r4, lsr #10
    f6d4:	4919      	ldr	r1, [pc, #100]	; (f73c <utf8EscapedDump+0x228>)
    f6d6:	4630      	mov	r0, r6
    f6d8:	f001 fbc8 	bl	10e6c <fprintf>
    f6dc:	2800      	cmp	r0, #0
    f6de:	db22      	blt.n	f726 <utf8EscapedDump+0x212>
    f6e0:	4629      	mov	r1, r5
    f6e2:	e798      	b.n	f616 <utf8EscapedDump+0x102>
                return CborErrorIO;
        }
    }
    return CborNoError;
    f6e4:	2000      	movs	r0, #0
    f6e6:	e002      	b.n	f6ee <utf8EscapedDump+0x1da>
                    return CborErrorIO;
    f6e8:	2004      	movs	r0, #4
    f6ea:	e000      	b.n	f6ee <utf8EscapedDump+0x1da>
                return CborErrorIO;
    f6ec:	2004      	movs	r0, #4
}
    f6ee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            return CborErrorInvalidUtf8TextString;
    f6f0:	f44f 7001 	mov.w	r0, #516	; 0x204
    f6f4:	e7fb      	b.n	f6ee <utf8EscapedDump+0x1da>
            return CborErrorInvalidUtf8TextString;
    f6f6:	f44f 7001 	mov.w	r0, #516	; 0x204
    f6fa:	e7f8      	b.n	f6ee <utf8EscapedDump+0x1da>
            return CborErrorInvalidUtf8TextString;
    f6fc:	f44f 7001 	mov.w	r0, #516	; 0x204
    f700:	e7f5      	b.n	f6ee <utf8EscapedDump+0x1da>
            return CborErrorInvalidUtf8TextString;
    f702:	f44f 7001 	mov.w	r0, #516	; 0x204
    f706:	e7f2      	b.n	f6ee <utf8EscapedDump+0x1da>
                return CborErrorInvalidUtf8TextString;
    f708:	f44f 7001 	mov.w	r0, #516	; 0x204
    f70c:	e7ef      	b.n	f6ee <utf8EscapedDump+0x1da>
                    return CborErrorInvalidUtf8TextString;
    f70e:	f44f 7001 	mov.w	r0, #516	; 0x204
    f712:	e7ec      	b.n	f6ee <utf8EscapedDump+0x1da>
            return CborErrorInvalidUtf8TextString;
    f714:	f44f 7001 	mov.w	r0, #516	; 0x204
    f718:	e7e9      	b.n	f6ee <utf8EscapedDump+0x1da>
    f71a:	f44f 7001 	mov.w	r0, #516	; 0x204
    f71e:	e7e6      	b.n	f6ee <utf8EscapedDump+0x1da>
    f720:	f44f 7001 	mov.w	r0, #516	; 0x204
    f724:	e7e3      	b.n	f6ee <utf8EscapedDump+0x1da>
                return CborErrorIO;
    f726:	2004      	movs	r0, #4
    f728:	e7e1      	b.n	f6ee <utf8EscapedDump+0x1da>
                return CborErrorIO;
    f72a:	2004      	movs	r0, #4
    f72c:	e7df      	b.n	f6ee <utf8EscapedDump+0x1da>
    f72e:	bf00      	nop
    f730:	00011a94 	.word	0x00011a94
    f734:	00011a98 	.word	0x00011a98
    f738:	00011aac 	.word	0x00011aac
    f73c:	00011a9c 	.word	0x00011a9c

0000f740 <value_to_pretty>:
    }
    return CborNoError;
}

static CborError value_to_pretty(FILE *out, CborValue *it)
{
    f740:	b5f0      	push	{r4, r5, r6, r7, lr}
    f742:	b087      	sub	sp, #28
    f744:	4607      	mov	r7, r0
    f746:	460d      	mov	r5, r1
{ return (CborType)value->type; }
    f748:	7b8c      	ldrb	r4, [r1, #14]
    CborError err;
    CborType type = cbor_value_get_type(it);
    switch (type) {
    f74a:	2cc0      	cmp	r4, #192	; 0xc0
    f74c:	f000 8138 	beq.w	f9c0 <value_to_pretty+0x280>
    f750:	d849      	bhi.n	f7e6 <value_to_pretty+0xa6>
    f752:	2c60      	cmp	r4, #96	; 0x60
    f754:	f000 80f5 	beq.w	f942 <value_to_pretty+0x202>
    f758:	d920      	bls.n	f79c <value_to_pretty+0x5c>
    f75a:	2c80      	cmp	r4, #128	; 0x80
    f75c:	d002      	beq.n	f764 <value_to_pretty+0x24>
    f75e:	2ca0      	cmp	r4, #160	; 0xa0
    f760:	f040 81c2 	bne.w	fae8 <value_to_pretty+0x3a8>
    case CborArrayType:
    case CborMapType: {
        /* recursive type */
        CborValue recursed;

        if (fprintf(out, type == CborArrayType ? "[" : "{") < 0)
    f764:	2c80      	cmp	r4, #128	; 0x80
    f766:	d062      	beq.n	f82e <value_to_pretty+0xee>
    f768:	49ac      	ldr	r1, [pc, #688]	; (fa1c <value_to_pretty+0x2dc>)
    f76a:	4638      	mov	r0, r7
    f76c:	f001 fb7e 	bl	10e6c <fprintf>
    f770:	2800      	cmp	r0, #0
    f772:	db7d      	blt.n	f870 <value_to_pretty+0x130>
{ return (value->flags & CborIteratorFlag_UnknownLength) == 0; }
    f774:	7beb      	ldrb	r3, [r5, #15]
            return CborErrorIO;
        if (!cbor_value_is_length_known(it)) {
    f776:	f013 0f04 	tst.w	r3, #4
    f77a:	d005      	beq.n	f788 <value_to_pretty+0x48>
            if (fprintf(out, "_ ") < 0)
    f77c:	49a8      	ldr	r1, [pc, #672]	; (fa20 <value_to_pretty+0x2e0>)
    f77e:	4638      	mov	r0, r7
    f780:	f001 fb74 	bl	10e6c <fprintf>
    f784:	2800      	cmp	r0, #0
    f786:	db75      	blt.n	f874 <value_to_pretty+0x134>
                return CborErrorIO;
        }

        err = cbor_value_enter_container(it, &recursed);
    f788:	a902      	add	r1, sp, #8
    f78a:	4628      	mov	r0, r5
    f78c:	f7ff fdc3 	bl	f316 <cbor_value_enter_container>
        if (err) {
    f790:	4606      	mov	r6, r0
    f792:	2800      	cmp	r0, #0
    f794:	d04d      	beq.n	f832 <value_to_pretty+0xf2>
            it->offset = recursed.offset;
    f796:	9b03      	ldr	r3, [sp, #12]
    f798:	606b      	str	r3, [r5, #4]
            return err;       /* parse error */
    f79a:	e181      	b.n	faa0 <value_to_pretty+0x360>
    switch (type) {
    f79c:	2c00      	cmp	r4, #0
    f79e:	d06b      	beq.n	f878 <value_to_pretty+0x138>
    f7a0:	2c40      	cmp	r4, #64	; 0x40
    f7a2:	f040 81a1 	bne.w	fae8 <value_to_pretty+0x3a8>
        }
        break;
    }

    case CborByteStringType:{
        size_t n = 0;
    f7a6:	2300      	movs	r3, #0
    f7a8:	9301      	str	r3, [sp, #4]
{ return value->type == CborByteStringType; }
    f7aa:	7b8b      	ldrb	r3, [r1, #14]
    assert(cbor_value_is_byte_string(value));
    f7ac:	2b40      	cmp	r3, #64	; 0x40
    f7ae:	f040 80ab 	bne.w	f908 <value_to_pretty+0x1c8>
    return _cbor_value_dup_string(value, (void **)buffer, buflen, next);
    f7b2:	460b      	mov	r3, r1
    f7b4:	aa01      	add	r2, sp, #4
    f7b6:	a902      	add	r1, sp, #8
    f7b8:	4628      	mov	r0, r5
    f7ba:	f000 f9e5 	bl	fb88 <_cbor_value_dup_string>
        uint8_t *buffer;
        err = cbor_value_dup_byte_string(it, &buffer, &n, it);
        if (err)
    f7be:	4606      	mov	r6, r0
    f7c0:	2800      	cmp	r0, #0
    f7c2:	f040 816d 	bne.w	faa0 <value_to_pretty+0x360>
            return err;

        bool failed = fprintf(out, "h'") < 0 || hexDump(out, buffer, n) < 0 || fprintf(out, "'") < 0;
    f7c6:	4997      	ldr	r1, [pc, #604]	; (fa24 <value_to_pretty+0x2e4>)
    f7c8:	4638      	mov	r0, r7
    f7ca:	f001 fb4f 	bl	10e6c <fprintf>
    f7ce:	2800      	cmp	r0, #0
    f7d0:	f280 80a4 	bge.w	f91c <value_to_pretty+0x1dc>
    f7d4:	2401      	movs	r4, #1
        free(buffer);
    f7d6:	9802      	ldr	r0, [sp, #8]
    f7d8:	f001 f808 	bl	107ec <free>
        return failed ? CborErrorIO : CborNoError;
    f7dc:	2c00      	cmp	r4, #0
    f7de:	f000 815f 	beq.w	faa0 <value_to_pretty+0x360>
    f7e2:	2604      	movs	r6, #4
    f7e4:	e15c      	b.n	faa0 <value_to_pretty+0x360>
    switch (type) {
    f7e6:	2cf7      	cmp	r4, #247	; 0xf7
    f7e8:	f200 817e 	bhi.w	fae8 <value_to_pretty+0x3a8>
    f7ec:	2ce0      	cmp	r4, #224	; 0xe0
    f7ee:	f0c0 817b 	bcc.w	fae8 <value_to_pretty+0x3a8>
    f7f2:	3ce0      	subs	r4, #224	; 0xe0
    f7f4:	2c17      	cmp	r4, #23
    f7f6:	f200 8177 	bhi.w	fae8 <value_to_pretty+0x3a8>
    f7fa:	e8df f014 	tbh	[pc, r4, lsl #1]
    f7fe:	0131      	.short	0x0131
    f800:	01750175 	.word	0x01750175
    f804:	01750175 	.word	0x01750175
    f808:	01750175 	.word	0x01750175
    f80c:	01750175 	.word	0x01750175
    f810:	01750175 	.word	0x01750175
    f814:	01750175 	.word	0x01750175
    f818:	01750175 	.word	0x01750175
    f81c:	01750175 	.word	0x01750175
    f820:	01750175 	.word	0x01750175
    f824:	01750175 	.word	0x01750175
    f828:	0147015c 	.word	0x0147015c
    f82c:	0154      	.short	0x0154
        if (fprintf(out, type == CborArrayType ? "[" : "{") < 0)
    f82e:	497e      	ldr	r1, [pc, #504]	; (fa28 <value_to_pretty+0x2e8>)
    f830:	e79b      	b.n	f76a <value_to_pretty+0x2a>
        err = container_to_pretty(out, &recursed, type);
    f832:	4622      	mov	r2, r4
    f834:	a902      	add	r1, sp, #8
    f836:	4638      	mov	r0, r7
    f838:	f000 f970 	bl	fb1c <container_to_pretty>
        if (err) {
    f83c:	4606      	mov	r6, r0
    f83e:	b110      	cbz	r0, f846 <value_to_pretty+0x106>
            it->offset = recursed.offset;
    f840:	9b03      	ldr	r3, [sp, #12]
    f842:	606b      	str	r3, [r5, #4]
            return err;       /* parse error */
    f844:	e12c      	b.n	faa0 <value_to_pretty+0x360>
        err = cbor_value_leave_container(it, &recursed);
    f846:	a902      	add	r1, sp, #8
    f848:	4628      	mov	r0, r5
    f84a:	f7ff fe0b 	bl	f464 <cbor_value_leave_container>
        if (err)
    f84e:	4606      	mov	r6, r0
    f850:	2800      	cmp	r0, #0
    f852:	f040 8125 	bne.w	faa0 <value_to_pretty+0x360>
        if (fprintf(out, type == CborArrayType ? "]" : "}") < 0)
    f856:	2c80      	cmp	r4, #128	; 0x80
    f858:	d008      	beq.n	f86c <value_to_pretty+0x12c>
    f85a:	4974      	ldr	r1, [pc, #464]	; (fa2c <value_to_pretty+0x2ec>)
    f85c:	4638      	mov	r0, r7
    f85e:	f001 fb05 	bl	10e6c <fprintf>
    f862:	2800      	cmp	r0, #0
    f864:	f280 811c 	bge.w	faa0 <value_to_pretty+0x360>
            return CborErrorIO;
    f868:	2604      	movs	r6, #4
    f86a:	e119      	b.n	faa0 <value_to_pretty+0x360>
        if (fprintf(out, type == CborArrayType ? "]" : "}") < 0)
    f86c:	4970      	ldr	r1, [pc, #448]	; (fa30 <value_to_pretty+0x2f0>)
    f86e:	e7f5      	b.n	f85c <value_to_pretty+0x11c>
            return CborErrorIO;
    f870:	2604      	movs	r6, #4
    f872:	e115      	b.n	faa0 <value_to_pretty+0x360>
                return CborErrorIO;
    f874:	2604      	movs	r6, #4
    f876:	e113      	b.n	faa0 <value_to_pretty+0x360>
{ return value->type == CborIntegerType; }
    f878:	7b8b      	ldrb	r3, [r1, #14]
    assert(cbor_value_is_integer(value));
    f87a:	b96b      	cbnz	r3, f898 <value_to_pretty+0x158>
    return value->flags & CborIteratorFlag_IntegerValueTooLarge ?
    f87c:	7bcb      	ldrb	r3, [r1, #15]
                _cbor_value_decode_int64_internal(value) : value->extra;
    f87e:	f013 0f01 	tst.w	r3, #1
    f882:	d113      	bne.n	f8ac <value_to_pretty+0x16c>
    f884:	898a      	ldrh	r2, [r1, #12]
    f886:	2300      	movs	r3, #0
{ return value->type == CborIntegerType; }
    f888:	7ba9      	ldrb	r1, [r5, #14]
{ return cbor_value_is_integer(value) && (value->flags & CborIteratorFlag_NegativeInteger) == 0; }
    f88a:	b9a9      	cbnz	r1, f8b8 <value_to_pretty+0x178>
    f88c:	7be9      	ldrb	r1, [r5, #15]
    f88e:	f011 0f02 	tst.w	r1, #2
    f892:	d027      	beq.n	f8e4 <value_to_pretty+0x1a4>
    f894:	2100      	movs	r1, #0
    f896:	e010      	b.n	f8ba <value_to_pretty+0x17a>
    assert(cbor_value_is_integer(value));
    f898:	f7fc fc80 	bl	c19c <hal_debugger_connected>
    f89c:	b100      	cbz	r0, f8a0 <value_to_pretty+0x160>
    f89e:	be01      	bkpt	0x0001
    f8a0:	2300      	movs	r3, #0
    f8a2:	461a      	mov	r2, r3
    f8a4:	4619      	mov	r1, r3
    f8a6:	4618      	mov	r0, r3
    f8a8:	f7fc fe56 	bl	c558 <__assert_func>
                _cbor_value_decode_int64_internal(value) : value->extra;
    f8ac:	4608      	mov	r0, r1
    f8ae:	f7ff fcb5 	bl	f21c <_cbor_value_decode_int64_internal>
    f8b2:	4602      	mov	r2, r0
    f8b4:	460b      	mov	r3, r1
    f8b6:	e7e7      	b.n	f888 <value_to_pretty+0x148>
{ return cbor_value_is_integer(value) && (value->flags & CborIteratorFlag_NegativeInteger) == 0; }
    f8b8:	2100      	movs	r1, #0
        if (cbor_value_is_unsigned_integer(it)) {
    f8ba:	b9a9      	cbnz	r1, f8e8 <value_to_pretty+0x1a8>
            if (++val) {                /* unsigned overflow may happen */
    f8bc:	1c50      	adds	r0, r2, #1
    f8be:	f143 0100 	adc.w	r1, r3, #0
    f8c2:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    f8c6:	bf08      	it	eq
    f8c8:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
    f8cc:	d014      	beq.n	f8f8 <value_to_pretty+0x1b8>
                if (fprintf(out, "-%" PRIu64, val) < 0)
    f8ce:	4602      	mov	r2, r0
    f8d0:	460b      	mov	r3, r1
    f8d2:	4958      	ldr	r1, [pc, #352]	; (fa34 <value_to_pretty+0x2f4>)
    f8d4:	4638      	mov	r0, r7
    f8d6:	f001 fac9 	bl	10e6c <fprintf>
    f8da:	2800      	cmp	r0, #0
    f8dc:	f280 80dc 	bge.w	fa98 <value_to_pretty+0x358>
        break;

    case CborBooleanType: {
        bool val;
        cbor_value_get_boolean(it, &val);       /* can't fail */
        if (fprintf(out, val ? "true" : "false") < 0)
    f8e0:	2604      	movs	r6, #4
    f8e2:	e0dd      	b.n	faa0 <value_to_pretty+0x360>
    f8e4:	2101      	movs	r1, #1
    f8e6:	e7e8      	b.n	f8ba <value_to_pretty+0x17a>
            if (fprintf(out, "%" PRIu64, val) < 0)
    f8e8:	4953      	ldr	r1, [pc, #332]	; (fa38 <value_to_pretty+0x2f8>)
    f8ea:	4638      	mov	r0, r7
    f8ec:	f001 fabe 	bl	10e6c <fprintf>
    f8f0:	2800      	cmp	r0, #0
    f8f2:	f280 80d1 	bge.w	fa98 <value_to_pretty+0x358>
    f8f6:	e7f3      	b.n	f8e0 <value_to_pretty+0x1a0>
                if (fprintf(out, "-18446744073709551616") < 0)
    f8f8:	4950      	ldr	r1, [pc, #320]	; (fa3c <value_to_pretty+0x2fc>)
    f8fa:	4638      	mov	r0, r7
    f8fc:	f001 fab6 	bl	10e6c <fprintf>
    f900:	2800      	cmp	r0, #0
    f902:	f280 80c9 	bge.w	fa98 <value_to_pretty+0x358>
    f906:	e7eb      	b.n	f8e0 <value_to_pretty+0x1a0>
    assert(cbor_value_is_byte_string(value));
    f908:	f7fc fc48 	bl	c19c <hal_debugger_connected>
    f90c:	b100      	cbz	r0, f910 <value_to_pretty+0x1d0>
    f90e:	be01      	bkpt	0x0001
    f910:	2300      	movs	r3, #0
    f912:	461a      	mov	r2, r3
    f914:	4619      	mov	r1, r3
    f916:	4618      	mov	r0, r3
    f918:	f7fc fe1e 	bl	c558 <__assert_func>
        bool failed = fprintf(out, "h'") < 0 || hexDump(out, buffer, n) < 0 || fprintf(out, "'") < 0;
    f91c:	9a01      	ldr	r2, [sp, #4]
    f91e:	9902      	ldr	r1, [sp, #8]
    f920:	4638      	mov	r0, r7
    f922:	f7ff fde3 	bl	f4ec <hexDump>
    f926:	2800      	cmp	r0, #0
    f928:	da01      	bge.n	f92e <value_to_pretty+0x1ee>
    f92a:	2401      	movs	r4, #1
    f92c:	e753      	b.n	f7d6 <value_to_pretty+0x96>
    f92e:	4944      	ldr	r1, [pc, #272]	; (fa40 <value_to_pretty+0x300>)
    f930:	4638      	mov	r0, r7
    f932:	f001 fa9b 	bl	10e6c <fprintf>
    f936:	2800      	cmp	r0, #0
    f938:	db01      	blt.n	f93e <value_to_pretty+0x1fe>
    f93a:	2400      	movs	r4, #0
    f93c:	e74b      	b.n	f7d6 <value_to_pretty+0x96>
    f93e:	2401      	movs	r4, #1
    f940:	e749      	b.n	f7d6 <value_to_pretty+0x96>
        size_t n = 0;
    f942:	2300      	movs	r3, #0
    f944:	9301      	str	r3, [sp, #4]
{ return value->type == CborTextStringType; }
    f946:	7b8b      	ldrb	r3, [r1, #14]
    assert(cbor_value_is_text_string(value));
    f948:	2b60      	cmp	r3, #96	; 0x60
    f94a:	d11c      	bne.n	f986 <value_to_pretty+0x246>
    return _cbor_value_dup_string(value, (void **)buffer, buflen, next);
    f94c:	460b      	mov	r3, r1
    f94e:	aa01      	add	r2, sp, #4
    f950:	a902      	add	r1, sp, #8
    f952:	4628      	mov	r0, r5
    f954:	f000 f918 	bl	fb88 <_cbor_value_dup_string>
        if (err)
    f958:	4606      	mov	r6, r0
    f95a:	2800      	cmp	r0, #0
    f95c:	f040 80a0 	bne.w	faa0 <value_to_pretty+0x360>
        bool failed = fprintf(out, "\"") < 0
    f960:	4938      	ldr	r1, [pc, #224]	; (fa44 <value_to_pretty+0x304>)
    f962:	4638      	mov	r0, r7
    f964:	f001 fa82 	bl	10e6c <fprintf>
                      || fprintf(out, "\"") < 0;
    f968:	2800      	cmp	r0, #0
    f96a:	da16      	bge.n	f99a <value_to_pretty+0x25a>
    f96c:	2301      	movs	r3, #1
        bool failed = fprintf(out, "\"") < 0
    f96e:	461c      	mov	r4, r3
        free(buffer);
    f970:	9802      	ldr	r0, [sp, #8]
    f972:	f000 ff3b 	bl	107ec <free>
        return err != CborNoError ? err :
    f976:	2e00      	cmp	r6, #0
    f978:	f040 8092 	bne.w	faa0 <value_to_pretty+0x360>
    f97c:	2c00      	cmp	r4, #0
    f97e:	f000 808f 	beq.w	faa0 <value_to_pretty+0x360>
    f982:	2604      	movs	r6, #4
    f984:	e08c      	b.n	faa0 <value_to_pretty+0x360>
    assert(cbor_value_is_text_string(value));
    f986:	f7fc fc09 	bl	c19c <hal_debugger_connected>
    f98a:	b100      	cbz	r0, f98e <value_to_pretty+0x24e>
    f98c:	be01      	bkpt	0x0001
    f98e:	2300      	movs	r3, #0
    f990:	461a      	mov	r2, r3
    f992:	4619      	mov	r1, r3
    f994:	4618      	mov	r0, r3
    f996:	f7fc fddf 	bl	c558 <__assert_func>
                      || (err = utf8EscapedDump(out, buffer, n)) != CborNoError
    f99a:	9a01      	ldr	r2, [sp, #4]
    f99c:	9902      	ldr	r1, [sp, #8]
    f99e:	4638      	mov	r0, r7
    f9a0:	f7ff fdb8 	bl	f514 <utf8EscapedDump>
    f9a4:	4606      	mov	r6, r0
    f9a6:	b108      	cbz	r0, f9ac <value_to_pretty+0x26c>
                      || fprintf(out, "\"") < 0;
    f9a8:	2301      	movs	r3, #1
    f9aa:	e7e0      	b.n	f96e <value_to_pretty+0x22e>
    f9ac:	4925      	ldr	r1, [pc, #148]	; (fa44 <value_to_pretty+0x304>)
    f9ae:	4638      	mov	r0, r7
    f9b0:	f001 fa5c 	bl	10e6c <fprintf>
    f9b4:	2800      	cmp	r0, #0
    f9b6:	db01      	blt.n	f9bc <value_to_pretty+0x27c>
    f9b8:	2300      	movs	r3, #0
    f9ba:	e7d8      	b.n	f96e <value_to_pretty+0x22e>
    f9bc:	2301      	movs	r3, #1
    f9be:	e7d6      	b.n	f96e <value_to_pretty+0x22e>
{ return value->type == CborTagType; }
    f9c0:	7b8b      	ldrb	r3, [r1, #14]
    assert(cbor_value_is_tag(value));
    f9c2:	2bc0      	cmp	r3, #192	; 0xc0
    f9c4:	d120      	bne.n	fa08 <value_to_pretty+0x2c8>
    return value->flags & CborIteratorFlag_IntegerValueTooLarge ?
    f9c6:	7bcb      	ldrb	r3, [r1, #15]
                _cbor_value_decode_int64_internal(value) : value->extra;
    f9c8:	f013 0f01 	tst.w	r3, #1
    f9cc:	d140      	bne.n	fa50 <value_to_pretty+0x310>
    f9ce:	898a      	ldrh	r2, [r1, #12]
    f9d0:	2300      	movs	r3, #0
        if (fprintf(out, "%" PRIu64 "(", tag) < 0)
    f9d2:	491d      	ldr	r1, [pc, #116]	; (fa48 <value_to_pretty+0x308>)
    f9d4:	4638      	mov	r0, r7
    f9d6:	f001 fa49 	bl	10e6c <fprintf>
    f9da:	2800      	cmp	r0, #0
    f9dc:	db3e      	blt.n	fa5c <value_to_pretty+0x31c>
        err = cbor_value_advance_fixed(it);
    f9de:	4628      	mov	r0, r5
    f9e0:	f7ff fc75 	bl	f2ce <cbor_value_advance_fixed>
        if (err)
    f9e4:	4606      	mov	r6, r0
    f9e6:	2800      	cmp	r0, #0
    f9e8:	d15a      	bne.n	faa0 <value_to_pretty+0x360>
        err = value_to_pretty(out, it);
    f9ea:	4629      	mov	r1, r5
    f9ec:	4638      	mov	r0, r7
    f9ee:	f7ff fea7 	bl	f740 <value_to_pretty>
        if (err)
    f9f2:	4606      	mov	r6, r0
    f9f4:	2800      	cmp	r0, #0
    f9f6:	d153      	bne.n	faa0 <value_to_pretty+0x360>
        if (fprintf(out, ")") < 0)
    f9f8:	4914      	ldr	r1, [pc, #80]	; (fa4c <value_to_pretty+0x30c>)
    f9fa:	4638      	mov	r0, r7
    f9fc:	f001 fa36 	bl	10e6c <fprintf>
    fa00:	2800      	cmp	r0, #0
    fa02:	da4d      	bge.n	faa0 <value_to_pretty+0x360>
            return CborErrorIO;
    fa04:	2604      	movs	r6, #4
    fa06:	e04b      	b.n	faa0 <value_to_pretty+0x360>
    assert(cbor_value_is_tag(value));
    fa08:	f7fc fbc8 	bl	c19c <hal_debugger_connected>
    fa0c:	b100      	cbz	r0, fa10 <value_to_pretty+0x2d0>
    fa0e:	be01      	bkpt	0x0001
    fa10:	2300      	movs	r3, #0
    fa12:	461a      	mov	r2, r3
    fa14:	4619      	mov	r1, r3
    fa16:	4618      	mov	r0, r3
    fa18:	f7fc fd9e 	bl	c558 <__assert_func>
    fa1c:	00011ab4 	.word	0x00011ab4
    fa20:	00011ad0 	.word	0x00011ad0
    fa24:	00011afc 	.word	0x00011afc
    fa28:	00011ab8 	.word	0x00011ab8
    fa2c:	00011abc 	.word	0x00011abc
    fa30:	000119f8 	.word	0x000119f8
    fa34:	00011adc 	.word	0x00011adc
    fa38:	00011ad4 	.word	0x00011ad4
    fa3c:	00011ae4 	.word	0x00011ae4
    fa40:	00011b00 	.word	0x00011b00
    fa44:	00011b04 	.word	0x00011b04
    fa48:	00011b08 	.word	0x00011b08
    fa4c:	00011b10 	.word	0x00011b10
                _cbor_value_decode_int64_internal(value) : value->extra;
    fa50:	4608      	mov	r0, r1
    fa52:	f7ff fbe3 	bl	f21c <_cbor_value_decode_int64_internal>
    fa56:	4602      	mov	r2, r0
    fa58:	460b      	mov	r3, r1
    fa5a:	e7ba      	b.n	f9d2 <value_to_pretty+0x292>
            return CborErrorIO;
    fa5c:	2604      	movs	r6, #4
    fa5e:	e01f      	b.n	faa0 <value_to_pretty+0x360>
{ return value->type == CborSimpleType; }
    fa60:	7bab      	ldrb	r3, [r5, #14]
    assert(cbor_value_is_simple_type(value));
    fa62:	2be0      	cmp	r3, #224	; 0xe0
    fa64:	d108      	bne.n	fa78 <value_to_pretty+0x338>
        if (fprintf(out, "simple(%" PRIu8 ")", simple_type) < 0)
    fa66:	7b2a      	ldrb	r2, [r5, #12]
    fa68:	4926      	ldr	r1, [pc, #152]	; (fb04 <value_to_pretty+0x3c4>)
    fa6a:	4638      	mov	r0, r7
    fa6c:	f001 f9fe 	bl	10e6c <fprintf>
    fa70:	2800      	cmp	r0, #0
    fa72:	da11      	bge.n	fa98 <value_to_pretty+0x358>
            return CborErrorIO;
    fa74:	2604      	movs	r6, #4
    fa76:	e013      	b.n	faa0 <value_to_pretty+0x360>
    fa78:	f7fc fb90 	bl	c19c <hal_debugger_connected>
    fa7c:	b100      	cbz	r0, fa80 <value_to_pretty+0x340>
    fa7e:	be01      	bkpt	0x0001
    fa80:	2300      	movs	r3, #0
    fa82:	461a      	mov	r2, r3
    fa84:	4619      	mov	r1, r3
    fa86:	4618      	mov	r0, r3
    fa88:	f7fc fd66 	bl	c558 <__assert_func>
        if (fprintf(out, "null") < 0)
    fa8c:	491e      	ldr	r1, [pc, #120]	; (fb08 <value_to_pretty+0x3c8>)
    fa8e:	4638      	mov	r0, r7
    fa90:	f001 f9ec 	bl	10e6c <fprintf>
    fa94:	2800      	cmp	r0, #0
    fa96:	db30      	blt.n	fafa <value_to_pretty+0x3ba>
        if (fprintf(out, "invalid") < 0)
            return CborErrorIO;
        return CborErrorUnknownType;
    }

    err = cbor_value_advance_fixed(it);
    fa98:	4628      	mov	r0, r5
    fa9a:	f7ff fc18 	bl	f2ce <cbor_value_advance_fixed>
    fa9e:	4606      	mov	r6, r0
    return err;
}
    faa0:	4630      	mov	r0, r6
    faa2:	b007      	add	sp, #28
    faa4:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if (fprintf(out, "undefined") < 0)
    faa6:	4919      	ldr	r1, [pc, #100]	; (fb0c <value_to_pretty+0x3cc>)
    faa8:	4638      	mov	r0, r7
    faaa:	f001 f9df 	bl	10e6c <fprintf>
    faae:	2800      	cmp	r0, #0
    fab0:	daf2      	bge.n	fa98 <value_to_pretty+0x358>
            return CborErrorIO;
    fab2:	2604      	movs	r6, #4
    fab4:	e7f4      	b.n	faa0 <value_to_pretty+0x360>
{ return value->type == CborBooleanType; }
    fab6:	7bab      	ldrb	r3, [r5, #14]
    assert(cbor_value_is_boolean(value));
    fab8:	2bf5      	cmp	r3, #245	; 0xf5
    faba:	d109      	bne.n	fad0 <value_to_pretty+0x390>
    *result = !!value->extra;
    fabc:	89ab      	ldrh	r3, [r5, #12]
        if (fprintf(out, val ? "true" : "false") < 0)
    fabe:	b18b      	cbz	r3, fae4 <value_to_pretty+0x3a4>
    fac0:	4913      	ldr	r1, [pc, #76]	; (fb10 <value_to_pretty+0x3d0>)
    fac2:	4638      	mov	r0, r7
    fac4:	f001 f9d2 	bl	10e6c <fprintf>
    fac8:	2800      	cmp	r0, #0
    faca:	dae5      	bge.n	fa98 <value_to_pretty+0x358>
            return CborErrorIO;
    facc:	2604      	movs	r6, #4
    face:	e7e7      	b.n	faa0 <value_to_pretty+0x360>
    assert(cbor_value_is_boolean(value));
    fad0:	f7fc fb64 	bl	c19c <hal_debugger_connected>
    fad4:	b100      	cbz	r0, fad8 <value_to_pretty+0x398>
    fad6:	be01      	bkpt	0x0001
    fad8:	2300      	movs	r3, #0
    fada:	461a      	mov	r2, r3
    fadc:	4619      	mov	r1, r3
    fade:	4618      	mov	r0, r3
    fae0:	f7fc fd3a 	bl	c558 <__assert_func>
        if (fprintf(out, val ? "true" : "false") < 0)
    fae4:	490b      	ldr	r1, [pc, #44]	; (fb14 <value_to_pretty+0x3d4>)
    fae6:	e7ec      	b.n	fac2 <value_to_pretty+0x382>
        if (fprintf(out, "invalid") < 0)
    fae8:	490b      	ldr	r1, [pc, #44]	; (fb18 <value_to_pretty+0x3d8>)
    faea:	4638      	mov	r0, r7
    faec:	f001 f9be 	bl	10e6c <fprintf>
    faf0:	2800      	cmp	r0, #0
    faf2:	db04      	blt.n	fafe <value_to_pretty+0x3be>
        return CborErrorUnknownType;
    faf4:	f240 1603 	movw	r6, #259	; 0x103
    faf8:	e7d2      	b.n	faa0 <value_to_pretty+0x360>
            return CborErrorIO;
    fafa:	2604      	movs	r6, #4
    fafc:	e7d0      	b.n	faa0 <value_to_pretty+0x360>
            return CborErrorIO;
    fafe:	2604      	movs	r6, #4
    fb00:	e7ce      	b.n	faa0 <value_to_pretty+0x360>
    fb02:	bf00      	nop
    fb04:	00011b14 	.word	0x00011b14
    fb08:	00011b24 	.word	0x00011b24
    fb0c:	00011b2c 	.word	0x00011b2c
    fb10:	00011ac8 	.word	0x00011ac8
    fb14:	00011ac0 	.word	0x00011ac0
    fb18:	00011b38 	.word	0x00011b38

0000fb1c <container_to_pretty>:
{
    fb1c:	b570      	push	{r4, r5, r6, lr}
    fb1e:	4604      	mov	r4, r0
    fb20:	460d      	mov	r5, r1
    fb22:	4616      	mov	r6, r2
    const char *comma = "";
    fb24:	4a12      	ldr	r2, [pc, #72]	; (fb70 <container_to_pretty+0x54>)
    while (!cbor_value_at_end(it)) {
    fb26:	e000      	b.n	fb2a <container_to_pretty+0xe>
{
    fb28:	4a12      	ldr	r2, [pc, #72]	; (fb74 <container_to_pretty+0x58>)
{ return it->remaining == 0; }
    fb2a:	68ab      	ldr	r3, [r5, #8]
    while (!cbor_value_at_end(it)) {
    fb2c:	b1e3      	cbz	r3, fb68 <container_to_pretty+0x4c>
        if (fprintf(out, "%s", comma) < 0)
    fb2e:	4912      	ldr	r1, [pc, #72]	; (fb78 <container_to_pretty+0x5c>)
    fb30:	4620      	mov	r0, r4
    fb32:	f001 f99b 	bl	10e6c <fprintf>
    fb36:	2800      	cmp	r0, #0
    fb38:	db15      	blt.n	fb66 <container_to_pretty+0x4a>
        CborError err = value_to_pretty(out, it);
    fb3a:	4629      	mov	r1, r5
    fb3c:	4620      	mov	r0, r4
    fb3e:	f7ff fdff 	bl	f740 <value_to_pretty>
        if (err)
    fb42:	4603      	mov	r3, r0
    fb44:	b980      	cbnz	r0, fb68 <container_to_pretty+0x4c>
        if (containerType == CborArrayType)
    fb46:	2e80      	cmp	r6, #128	; 0x80
    fb48:	d0ee      	beq.n	fb28 <container_to_pretty+0xc>
        if (fprintf(out, ": ") < 0)
    fb4a:	490c      	ldr	r1, [pc, #48]	; (fb7c <container_to_pretty+0x60>)
    fb4c:	4620      	mov	r0, r4
    fb4e:	f001 f98d 	bl	10e6c <fprintf>
    fb52:	2800      	cmp	r0, #0
    fb54:	db0a      	blt.n	fb6c <container_to_pretty+0x50>
        err = value_to_pretty(out, it);
    fb56:	4629      	mov	r1, r5
    fb58:	4620      	mov	r0, r4
    fb5a:	f7ff fdf1 	bl	f740 <value_to_pretty>
        if (err)
    fb5e:	4603      	mov	r3, r0
    fb60:	2800      	cmp	r0, #0
    fb62:	d0e1      	beq.n	fb28 <container_to_pretty+0xc>
    fb64:	e000      	b.n	fb68 <container_to_pretty+0x4c>
            return CborErrorIO;
    fb66:	2304      	movs	r3, #4
}
    fb68:	4618      	mov	r0, r3
    fb6a:	bd70      	pop	{r4, r5, r6, pc}
            return CborErrorIO;
    fb6c:	2304      	movs	r3, #4
    fb6e:	e7fb      	b.n	fb68 <container_to_pretty+0x4c>
    fb70:	00011888 	.word	0x00011888
    fb74:	00011b40 	.word	0x00011b40
    fb78:	00011b44 	.word	0x00011b44
    fb7c:	00011b48 	.word	0x00011b48

0000fb80 <cbor_value_to_pretty_advance>:
 * done by appending a comma to the output stream.
 *
 * \sa cbor_value_to_pretty(), cbor_value_to_json_advance()
 */
CborError cbor_value_to_pretty_advance(FILE *out, CborValue *value)
{
    fb80:	b508      	push	{r3, lr}
    return value_to_pretty(out, value);
    fb82:	f7ff fddd 	bl	f740 <value_to_pretty>
}
    fb86:	bd08      	pop	{r3, pc}

0000fb88 <_cbor_value_dup_string>:
 * malloc'ed block.
 *
 * \sa cbor_value_copy_byte_string(), cbor_value_dup_text_string()
 */
CborError _cbor_value_dup_string(const CborValue *value, void **buffer, size_t *buflen, CborValue *next)
{
    fb88:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    assert(buffer);
    fb8c:	b181      	cbz	r1, fbb0 <_cbor_value_dup_string+0x28>
    fb8e:	4605      	mov	r5, r0
    fb90:	4614      	mov	r4, r2
    fb92:	461e      	mov	r6, r3
    fb94:	460f      	mov	r7, r1
    assert(buflen);
    fb96:	b1aa      	cbz	r2, fbc4 <_cbor_value_dup_string+0x3c>
    *buflen = SIZE_MAX;
    fb98:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    fb9c:	6013      	str	r3, [r2, #0]
    CborError err = _cbor_value_copy_string(value, NULL, buflen, NULL);
    fb9e:	2300      	movs	r3, #0
    fba0:	4619      	mov	r1, r3
    fba2:	f7ff fc87 	bl	f4b4 <_cbor_value_copy_string>
    if (err)
    fba6:	4680      	mov	r8, r0
    fba8:	b1b0      	cbz	r0, fbd8 <_cbor_value_dup_string+0x50>
    if (err) {
        free(*buffer);
        return err;
    }
    return CborNoError;
}
    fbaa:	4640      	mov	r0, r8
    fbac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    assert(buffer);
    fbb0:	f7fc faf4 	bl	c19c <hal_debugger_connected>
    fbb4:	b100      	cbz	r0, fbb8 <_cbor_value_dup_string+0x30>
    fbb6:	be01      	bkpt	0x0001
    fbb8:	2300      	movs	r3, #0
    fbba:	461a      	mov	r2, r3
    fbbc:	4619      	mov	r1, r3
    fbbe:	4618      	mov	r0, r3
    fbc0:	f7fc fcca 	bl	c558 <__assert_func>
    assert(buflen);
    fbc4:	f7fc faea 	bl	c19c <hal_debugger_connected>
    fbc8:	b100      	cbz	r0, fbcc <_cbor_value_dup_string+0x44>
    fbca:	be01      	bkpt	0x0001
    fbcc:	2300      	movs	r3, #0
    fbce:	461a      	mov	r2, r3
    fbd0:	4619      	mov	r1, r3
    fbd2:	4618      	mov	r0, r3
    fbd4:	f7fc fcc0 	bl	c558 <__assert_func>
    ++*buflen;
    fbd8:	6820      	ldr	r0, [r4, #0]
    fbda:	3001      	adds	r0, #1
    fbdc:	6020      	str	r0, [r4, #0]
    *buffer = malloc(*buflen);
    fbde:	f000 fdcf 	bl	10780 <malloc>
    fbe2:	4601      	mov	r1, r0
    fbe4:	6038      	str	r0, [r7, #0]
    if (!*buffer) {
    fbe6:	b158      	cbz	r0, fc00 <_cbor_value_dup_string+0x78>
    err = _cbor_value_copy_string(value, *buffer, buflen, next);
    fbe8:	4633      	mov	r3, r6
    fbea:	4622      	mov	r2, r4
    fbec:	4628      	mov	r0, r5
    fbee:	f7ff fc61 	bl	f4b4 <_cbor_value_copy_string>
    if (err) {
    fbf2:	4680      	mov	r8, r0
    fbf4:	2800      	cmp	r0, #0
    fbf6:	d0d8      	beq.n	fbaa <_cbor_value_dup_string+0x22>
        free(*buffer);
    fbf8:	6838      	ldr	r0, [r7, #0]
    fbfa:	f000 fdf7 	bl	107ec <free>
        return err;
    fbfe:	e7d4      	b.n	fbaa <_cbor_value_dup_string+0x22>
        return CborErrorOutOfMemory;
    fc00:	f04f 4800 	mov.w	r8, #2147483648	; 0x80000000
    fc04:	e7d1      	b.n	fbaa <_cbor_value_dup_string+0x22>
	...

0000fc08 <hal_bsp_flash_dev>:
hal_bsp_flash_dev(uint8_t id)
{
    /*
     * Internal flash mapped to id 0.
     */
    if (id == 0) {
    fc08:	b908      	cbnz	r0, fc0e <hal_bsp_flash_dev+0x6>
        return &nrf52k_flash_dev;
    fc0a:	4802      	ldr	r0, [pc, #8]	; (fc14 <hal_bsp_flash_dev+0xc>)
    if (id == 1) {
        return &nrf52k_qspi_dev;
    }
#endif
    return NULL;
}
    fc0c:	4770      	bx	lr
    return NULL;
    fc0e:	2000      	movs	r0, #0
    fc10:	4770      	bx	lr
    fc12:	bf00      	nop
    fc14:	00011b4c 	.word	0x00011b4c

0000fc18 <hal_bsp_init>:
    return cfg_pri;
}

void
hal_bsp_init(void)
{
    fc18:	b508      	push	{r3, lr}
    /* Make sure system clocks have started */
    hal_system_clock_start();
    fc1a:	f7fc fadd 	bl	c1d8 <hal_system_clock_start>

    /* Create all available nRF52840 peripherals */
    nrf52_periph_create();
    fc1e:	f000 faad 	bl	1017c <nrf52_periph_create>
}
    fc22:	bd08      	pop	{r3, pc}

0000fc24 <hal_flash_init>:

static uint8_t protected_flash[1];

int
hal_flash_init(void)
{
    fc24:	b538      	push	{r3, r4, r5, lr}
    const struct hal_flash *hf;
    uint8_t i;
    int rc = 0;
    fc26:	2500      	movs	r5, #0
    const uint8_t max_id = MYNEWT_VAL(HAL_FLASH_MAX_DEVICE_COUNT) ? MYNEWT_VAL(HAL_FLASH_MAX_DEVICE_COUNT) : 0xFF;

    for (i = 0; i < max_id; i++) {
    fc28:	462c      	mov	r4, r5
    fc2a:	e001      	b.n	fc30 <hal_flash_init+0xc>
    fc2c:	3401      	adds	r4, #1
    fc2e:	b2e4      	uxtb	r4, r4
    fc30:	2cff      	cmp	r4, #255	; 0xff
    fc32:	d00b      	beq.n	fc4c <hal_flash_init+0x28>
        hf = hal_bsp_flash_dev(i);
    fc34:	4620      	mov	r0, r4
    fc36:	f7ff ffe7 	bl	fc08 <hal_bsp_flash_dev>
        if (!hf) {
    fc3a:	b138      	cbz	r0, fc4c <hal_flash_init+0x28>
                break;
            } else {
                continue;
            }
        }
        if (hf->hf_itf->hff_init(hf)) {
    fc3c:	6802      	ldr	r2, [r0, #0]
    fc3e:	6952      	ldr	r2, [r2, #20]
    fc40:	4790      	blx	r2
    fc42:	2800      	cmp	r0, #0
    fc44:	d0f2      	beq.n	fc2c <hal_flash_init+0x8>
            rc = SYS_EIO;
    fc46:	f06f 0504 	mvn.w	r5, #4
    fc4a:	e7ef      	b.n	fc2c <hal_flash_init+0x8>
        }
    }
    return rc;
}
    fc4c:	4628      	mov	r0, r5
    fc4e:	bd38      	pop	{r3, r4, r5, pc}

0000fc50 <nrf52k_flash_wait_ready>:
static int
nrf52k_flash_wait_ready(void)
{
    int i;

    for (i = 0; i < 100000; i++) {
    fc50:	2300      	movs	r3, #0
    fc52:	e000      	b.n	fc56 <nrf52k_flash_wait_ready+0x6>
    fc54:	3301      	adds	r3, #1
    fc56:	4a06      	ldr	r2, [pc, #24]	; (fc70 <nrf52k_flash_wait_ready+0x20>)
    fc58:	4293      	cmp	r3, r2
    fc5a:	dc06      	bgt.n	fc6a <nrf52k_flash_wait_ready+0x1a>
        if (NRF_NVMC->READY == NVMC_READY_READY_Ready) {
    fc5c:	4a05      	ldr	r2, [pc, #20]	; (fc74 <nrf52k_flash_wait_ready+0x24>)
    fc5e:	f8d2 2400 	ldr.w	r2, [r2, #1024]	; 0x400
    fc62:	2a01      	cmp	r2, #1
    fc64:	d1f6      	bne.n	fc54 <nrf52k_flash_wait_ready+0x4>
            return 0;
    fc66:	2000      	movs	r0, #0
        }
    }
    return -1;
}
    fc68:	4770      	bx	lr
    return -1;
    fc6a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    fc6e:	4770      	bx	lr
    fc70:	0001869f 	.word	0x0001869f
    fc74:	4001e000 	.word	0x4001e000

0000fc78 <nrf52k_flash_erase_sector>:
    return rc;
}

static int
nrf52k_flash_erase_sector(const struct hal_flash *dev, uint32_t sector_address)
{
    fc78:	b538      	push	{r3, r4, r5, lr}
    fc7a:	460c      	mov	r4, r1
    int sr;
    int rc = -1;

    if (nrf52k_flash_wait_ready()) {
    fc7c:	f7ff ffe8 	bl	fc50 <nrf52k_flash_wait_ready>
    fc80:	b9e0      	cbnz	r0, fcbc <nrf52k_flash_erase_sector+0x44>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
    fc82:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
    fc86:	b672      	cpsid	i
        return -1;
    }
    __HAL_DISABLE_INTERRUPTS(sr);
    NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Een; /* Enable erase OP */
    fc88:	4b0e      	ldr	r3, [pc, #56]	; (fcc4 <nrf52k_flash_erase_sector+0x4c>)
    fc8a:	2202      	movs	r2, #2
    fc8c:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    if (nrf52k_flash_wait_ready()) {
    fc90:	f7ff ffde 	bl	fc50 <nrf52k_flash_wait_ready>
    fc94:	b140      	cbz	r0, fca8 <nrf52k_flash_erase_sector+0x30>
    int rc = -1;
    fc96:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    if (nrf52k_flash_wait_ready()) {
        goto out;
    }
    rc = 0;
out:
    NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Ren; /* Disable erase OP */
    fc9a:	4b0a      	ldr	r3, [pc, #40]	; (fcc4 <nrf52k_flash_erase_sector+0x4c>)
    fc9c:	2200      	movs	r2, #0
    fc9e:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    __HAL_ENABLE_INTERRUPTS(sr);
    fca2:	b905      	cbnz	r5, fca6 <nrf52k_flash_erase_sector+0x2e>
  __ASM volatile ("cpsie i" : : : "memory");
    fca4:	b662      	cpsie	i
    return rc;
}
    fca6:	bd38      	pop	{r3, r4, r5, pc}
    NRF_NVMC->ERASEPAGE = sector_address;
    fca8:	4b06      	ldr	r3, [pc, #24]	; (fcc4 <nrf52k_flash_erase_sector+0x4c>)
    fcaa:	f8c3 4508 	str.w	r4, [r3, #1288]	; 0x508
    if (nrf52k_flash_wait_ready()) {
    fcae:	f7ff ffcf 	bl	fc50 <nrf52k_flash_wait_ready>
    fcb2:	2800      	cmp	r0, #0
    fcb4:	d0f1      	beq.n	fc9a <nrf52k_flash_erase_sector+0x22>
    int rc = -1;
    fcb6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    fcba:	e7ee      	b.n	fc9a <nrf52k_flash_erase_sector+0x22>
        return -1;
    fcbc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    fcc0:	e7f1      	b.n	fca6 <nrf52k_flash_erase_sector+0x2e>
    fcc2:	bf00      	nop
    fcc4:	4001e000 	.word	0x4001e000

0000fcc8 <nrf52k_flash_init>:

static int
nrf52k_flash_init(const struct hal_flash *dev)
{
    return 0;
}
    fcc8:	2000      	movs	r0, #0
    fcca:	4770      	bx	lr

0000fccc <nrf52k_flash_sector_info>:
    assert(idx < nrf52k_flash_dev.hf_sector_cnt);
    fccc:	29ff      	cmp	r1, #255	; 0xff
    fcce:	dc06      	bgt.n	fcde <nrf52k_flash_sector_info+0x12>
    *address = idx * NRF52K_FLASH_SECTOR_SZ;
    fcd0:	0309      	lsls	r1, r1, #12
    fcd2:	6011      	str	r1, [r2, #0]
    *sz = NRF52K_FLASH_SECTOR_SZ;
    fcd4:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    fcd8:	601a      	str	r2, [r3, #0]
}
    fcda:	2000      	movs	r0, #0
    fcdc:	4770      	bx	lr
{
    fcde:	b508      	push	{r3, lr}
    assert(idx < nrf52k_flash_dev.hf_sector_cnt);
    fce0:	f7fc fa5c 	bl	c19c <hal_debugger_connected>
    fce4:	b100      	cbz	r0, fce8 <nrf52k_flash_sector_info+0x1c>
    fce6:	be01      	bkpt	0x0001
    fce8:	2300      	movs	r3, #0
    fcea:	461a      	mov	r2, r3
    fcec:	4619      	mov	r1, r3
    fcee:	4618      	mov	r0, r3
    fcf0:	f7fc fc32 	bl	c558 <__assert_func>

0000fcf4 <nrf52k_flash_write>:
{
    fcf4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    fcf8:	b082      	sub	sp, #8
    fcfa:	460d      	mov	r5, r1
    fcfc:	4616      	mov	r6, r2
    fcfe:	461c      	mov	r4, r3
    if (nrf52k_flash_wait_ready()) {
    fd00:	f7ff ffa6 	bl	fc50 <nrf52k_flash_wait_ready>
    fd04:	2800      	cmp	r0, #0
    fd06:	d154      	bne.n	fdb2 <nrf52k_flash_write+0xbe>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
    fd08:	f3ef 8710 	mrs	r7, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
    fd0c:	b672      	cpsid	i
    NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Wen; /* Enable erase OP */
    fd0e:	4b2a      	ldr	r3, [pc, #168]	; (fdb8 <nrf52k_flash_write+0xc4>)
    fd10:	2201      	movs	r2, #1
    fd12:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    if (tmp) {
    fd16:	f015 0803 	ands.w	r8, r5, #3
    fd1a:	d10a      	bne.n	fd32 <nrf52k_flash_write+0x3e>
    while (num_bytes >= sizeof(uint32_t)) {
    fd1c:	2c03      	cmp	r4, #3
    fd1e:	d924      	bls.n	fd6a <nrf52k_flash_write+0x76>
        if (nrf52k_flash_wait_ready()) {
    fd20:	f7ff ff96 	bl	fc50 <nrf52k_flash_wait_ready>
    fd24:	bbb8      	cbnz	r0, fd96 <nrf52k_flash_write+0xa2>
        *(uint32_t *)address = *(uint32_t *)src;
    fd26:	f856 3b04 	ldr.w	r3, [r6], #4
    fd2a:	f845 3b04 	str.w	r3, [r5], #4
        num_bytes -= sizeof(uint32_t);
    fd2e:	3c04      	subs	r4, #4
    fd30:	e7f4      	b.n	fd1c <nrf52k_flash_write+0x28>
        if (nrf52k_flash_wait_ready()) {
    fd32:	f7ff ff8d 	bl	fc50 <nrf52k_flash_wait_ready>
    fd36:	bb58      	cbnz	r0, fd90 <nrf52k_flash_write+0x9c>
        val = *(uint32_t *)(address & ~0x3);
    fd38:	f025 0a03 	bic.w	sl, r5, #3
    fd3c:	f8da 3000 	ldr.w	r3, [sl]
    fd40:	9301      	str	r3, [sp, #4]
        cnt = 4 - tmp;
    fd42:	f1c8 0904 	rsb	r9, r8, #4
        if (cnt > num_bytes) {
    fd46:	45a1      	cmp	r9, r4
    fd48:	d900      	bls.n	fd4c <nrf52k_flash_write+0x58>
            cnt = num_bytes;
    fd4a:	46a1      	mov	r9, r4
        memcpy((uint8_t *)&val + tmp, src, cnt);
    fd4c:	464a      	mov	r2, r9
    fd4e:	4631      	mov	r1, r6
    fd50:	ab01      	add	r3, sp, #4
    fd52:	eb03 0008 	add.w	r0, r3, r8
    fd56:	f7fd fd13 	bl	d780 <memcpy>
        *(uint32_t *)(address & ~0x3) = val;
    fd5a:	9b01      	ldr	r3, [sp, #4]
    fd5c:	f8ca 3000 	str.w	r3, [sl]
        address += cnt;
    fd60:	444d      	add	r5, r9
        num_bytes -= cnt;
    fd62:	eba4 0409 	sub.w	r4, r4, r9
        src += cnt;
    fd66:	444e      	add	r6, r9
    fd68:	e7d8      	b.n	fd1c <nrf52k_flash_write+0x28>
    if (num_bytes) {
    fd6a:	b15c      	cbz	r4, fd84 <nrf52k_flash_write+0x90>
        val = *(uint32_t *)address;
    fd6c:	682b      	ldr	r3, [r5, #0]
    fd6e:	9301      	str	r3, [sp, #4]
        memcpy(&val, src, num_bytes);
    fd70:	4622      	mov	r2, r4
    fd72:	4631      	mov	r1, r6
    fd74:	a801      	add	r0, sp, #4
    fd76:	f7fd fd03 	bl	d780 <memcpy>
        if (nrf52k_flash_wait_ready()) {
    fd7a:	f7ff ff69 	bl	fc50 <nrf52k_flash_wait_ready>
    fd7e:	b9a8      	cbnz	r0, fdac <nrf52k_flash_write+0xb8>
        *(uint32_t *)address = val;
    fd80:	9b01      	ldr	r3, [sp, #4]
    fd82:	602b      	str	r3, [r5, #0]
    if (nrf52k_flash_wait_ready()) {
    fd84:	f7ff ff64 	bl	fc50 <nrf52k_flash_wait_ready>
    fd88:	b138      	cbz	r0, fd9a <nrf52k_flash_write+0xa6>
        rc = -1;
    fd8a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    fd8e:	e004      	b.n	fd9a <nrf52k_flash_write+0xa6>
    int rc = -1;
    fd90:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    fd94:	e001      	b.n	fd9a <nrf52k_flash_write+0xa6>
    fd96:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Ren;
    fd9a:	4b07      	ldr	r3, [pc, #28]	; (fdb8 <nrf52k_flash_write+0xc4>)
    fd9c:	2200      	movs	r2, #0
    fd9e:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    __HAL_ENABLE_INTERRUPTS(sr);
    fda2:	b907      	cbnz	r7, fda6 <nrf52k_flash_write+0xb2>
  __ASM volatile ("cpsie i" : : : "memory");
    fda4:	b662      	cpsie	i
}
    fda6:	b002      	add	sp, #8
    fda8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    int rc = -1;
    fdac:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    fdb0:	e7f3      	b.n	fd9a <nrf52k_flash_write+0xa6>
        return -1;
    fdb2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    fdb6:	e7f6      	b.n	fda6 <nrf52k_flash_write+0xb2>
    fdb8:	4001e000 	.word	0x4001e000

0000fdbc <nrf52k_flash_read>:
{
    fdbc:	b508      	push	{r3, lr}
    fdbe:	4610      	mov	r0, r2
    memcpy(dst, (void *)address, num_bytes);
    fdc0:	461a      	mov	r2, r3
    fdc2:	f7fd fcdd 	bl	d780 <memcpy>
}
    fdc6:	2000      	movs	r0, #0
    fdc8:	bd08      	pop	{r3, pc}
	...

0000fdcc <nrf52_timer_handler>:
    }
}

static void
nrf52_timer_handler(void)
{
    fdcc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    int ticks;
    os_sr_t sr;
    uint32_t counter;

    os_trace_isr_enter();
    OS_ENTER_CRITICAL(sr);
    fdce:	f7fd fb7b 	bl	d4c8 <os_arch_save_sr>
    return OS_TICK_TIMER->COUNTER;
    fdd2:	4b39      	ldr	r3, [pc, #228]	; (feb8 <nrf52_timer_handler+0xec>)
    fdd4:	f8d3 3504 	ldr.w	r3, [r3, #1284]	; 0x504

    /* Calculate elapsed ticks and advance OS time. */

    counter = nrf52_os_tick_counter();
    delta = sub24(counter, g_hal_os_tick.lastocmp);
    fdd8:	4a38      	ldr	r2, [pc, #224]	; (febc <nrf52_timer_handler+0xf0>)
    fdda:	6895      	ldr	r5, [r2, #8]
    assert(x <= 0xffffff);
    fddc:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
    fde0:	d22b      	bcs.n	fe3a <nrf52_timer_handler+0x6e>
    fde2:	4606      	mov	r6, r0
    assert(y <= 0xffffff);
    fde4:	f1b5 7f80 	cmp.w	r5, #16777216	; 0x1000000
    fde8:	d231      	bcs.n	fe4e <nrf52_timer_handler+0x82>
    result = x - y;
    fdea:	1b5b      	subs	r3, r3, r5
    if (result & 0x800000) {
    fdec:	f413 0f00 	tst.w	r3, #8388608	; 0x800000
    fdf0:	d037      	beq.n	fe62 <nrf52_timer_handler+0x96>
        return (result | 0xff800000);
    fdf2:	ea6f 2343 	mvn.w	r3, r3, lsl #9
    fdf6:	ea6f 2353 	mvn.w	r3, r3, lsr #9
    ticks = delta / g_hal_os_tick.ticks_per_ostick;
    fdfa:	4f30      	ldr	r7, [pc, #192]	; (febc <nrf52_timer_handler+0xf0>)
    fdfc:	683d      	ldr	r5, [r7, #0]
    fdfe:	fb93 f5f5 	sdiv	r5, r3, r5
    os_time_advance(ticks);
    fe02:	4628      	mov	r0, r5
    fe04:	f7fd fb16 	bl	d434 <os_time_advance>

    /* Clear timer interrupt */
    OS_TICK_TIMER->EVENTS_COMPARE[OS_TICK_CMPREG] = 0;
    fe08:	4b2b      	ldr	r3, [pc, #172]	; (feb8 <nrf52_timer_handler+0xec>)
    fe0a:	2200      	movs	r2, #0
    fe0c:	f8c3 214c 	str.w	r2, [r3, #332]	; 0x14c

    /* Update the time associated with the most recent tick */
    g_hal_os_tick.lastocmp = (g_hal_os_tick.lastocmp +
    fe10:	68bb      	ldr	r3, [r7, #8]
        (ticks * g_hal_os_tick.ticks_per_ostick)) & 0xffffff;
    fe12:	683c      	ldr	r4, [r7, #0]
    g_hal_os_tick.lastocmp = (g_hal_os_tick.lastocmp +
    fe14:	fb05 3304 	mla	r3, r5, r4, r3
        (ticks * g_hal_os_tick.ticks_per_ostick)) & 0xffffff;
    fe18:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    g_hal_os_tick.lastocmp = (g_hal_os_tick.lastocmp +
    fe1c:	60bb      	str	r3, [r7, #8]

    /* Update the output compare to interrupt at the next tick */
    nrf52_os_tick_set_ocmp(g_hal_os_tick.lastocmp + g_hal_os_tick.ticks_per_ostick);
    fe1e:	441c      	add	r4, r3
    OS_ASSERT_CRITICAL();
    fe20:	f7fd fb5b 	bl	d4da <os_arch_in_critical>
    fe24:	bb88      	cbnz	r0, fe8a <nrf52_timer_handler+0xbe>
    fe26:	f7fc f9b9 	bl	c19c <hal_debugger_connected>
    fe2a:	b100      	cbz	r0, fe2e <nrf52_timer_handler+0x62>
    fe2c:	be01      	bkpt	0x0001
    fe2e:	2300      	movs	r3, #0
    fe30:	461a      	mov	r2, r3
    fe32:	4619      	mov	r1, r3
    fe34:	4618      	mov	r0, r3
    fe36:	f7fc fb8f 	bl	c558 <__assert_func>
    assert(x <= 0xffffff);
    fe3a:	f7fc f9af 	bl	c19c <hal_debugger_connected>
    fe3e:	b100      	cbz	r0, fe42 <nrf52_timer_handler+0x76>
    fe40:	be01      	bkpt	0x0001
    fe42:	2300      	movs	r3, #0
    fe44:	461a      	mov	r2, r3
    fe46:	4619      	mov	r1, r3
    fe48:	4618      	mov	r0, r3
    fe4a:	f7fc fb85 	bl	c558 <__assert_func>
    assert(y <= 0xffffff);
    fe4e:	f7fc f9a5 	bl	c19c <hal_debugger_connected>
    fe52:	b100      	cbz	r0, fe56 <nrf52_timer_handler+0x8a>
    fe54:	be01      	bkpt	0x0001
    fe56:	2300      	movs	r3, #0
    fe58:	461a      	mov	r2, r3
    fe5a:	4619      	mov	r1, r3
    fe5c:	4618      	mov	r0, r3
    fe5e:	f7fc fb7b 	bl	c558 <__assert_func>
        return (result & 0x007fffff);
    fe62:	f3c3 0316 	ubfx	r3, r3, #0, #23
    fe66:	e7c8      	b.n	fdfa <nrf52_timer_handler+0x2e>
    assert(y <= 0xffffff);
    fe68:	f7fc f998 	bl	c19c <hal_debugger_connected>
    fe6c:	b100      	cbz	r0, fe70 <nrf52_timer_handler+0xa4>
    fe6e:	be01      	bkpt	0x0001
    fe70:	2300      	movs	r3, #0
    fe72:	461a      	mov	r2, r3
    fe74:	4619      	mov	r1, r3
    fe76:	4618      	mov	r0, r3
    fe78:	f7fc fb6e 	bl	c558 <__assert_func>
        return (result & 0x007fffff);
    fe7c:	f3c2 0216 	ubfx	r2, r2, #0, #23
        if (delta > 2) {
    fe80:	2a02      	cmp	r2, #2
    fe82:	dc15      	bgt.n	feb0 <nrf52_timer_handler+0xe4>
        ocmp += g_hal_os_tick.ticks_per_ostick;
    fe84:	4a0d      	ldr	r2, [pc, #52]	; (febc <nrf52_timer_handler+0xf0>)
    fe86:	6814      	ldr	r4, [r2, #0]
    fe88:	441c      	add	r4, r3
        ocmp &= 0xffffff;
    fe8a:	f024 437f 	bic.w	r3, r4, #4278190080	; 0xff000000
        OS_TICK_TIMER->CC[OS_TICK_CMPREG] = ocmp;
    fe8e:	4a0a      	ldr	r2, [pc, #40]	; (feb8 <nrf52_timer_handler+0xec>)
    fe90:	f8c2 354c 	str.w	r3, [r2, #1356]	; 0x54c
    return OS_TICK_TIMER->COUNTER;
    fe94:	f8d2 2504 	ldr.w	r2, [r2, #1284]	; 0x504
    assert(y <= 0xffffff);
    fe98:	f1b2 7f80 	cmp.w	r2, #16777216	; 0x1000000
    fe9c:	d2e4      	bcs.n	fe68 <nrf52_timer_handler+0x9c>
    result = x - y;
    fe9e:	1a9a      	subs	r2, r3, r2
    if (result & 0x800000) {
    fea0:	f412 0f00 	tst.w	r2, #8388608	; 0x800000
    fea4:	d0ea      	beq.n	fe7c <nrf52_timer_handler+0xb0>
        return (result | 0xff800000);
    fea6:	ea6f 2242 	mvn.w	r2, r2, lsl #9
    feaa:	ea6f 2252 	mvn.w	r2, r2, lsr #9
    feae:	e7e7      	b.n	fe80 <nrf52_timer_handler+0xb4>

    OS_EXIT_CRITICAL(sr);
    feb0:	4630      	mov	r0, r6
    feb2:	f7fd fb0f 	bl	d4d4 <os_arch_restore_sr>
    os_trace_isr_exit();
}
    feb6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    feb8:	40011000 	.word	0x40011000
    febc:	20002374 	.word	0x20002374

0000fec0 <os_tick_idle>:

void
os_tick_idle(os_time_t ticks)
{
    fec0:	b538      	push	{r3, r4, r5, lr}
    fec2:	4605      	mov	r5, r0
    uint32_t ocmp;

    OS_ASSERT_CRITICAL();
    fec4:	f7fd fb09 	bl	d4da <os_arch_in_critical>
    fec8:	b1c0      	cbz	r0, fefc <os_tick_idle+0x3c>

    if (ticks > 0) {
    feca:	2d00      	cmp	r5, #0
    fecc:	d044      	beq.n	ff58 <os_tick_idle+0x98>
        /*
         * Enter tickless regime during long idle durations.
         */
        if (ticks > g_hal_os_tick.max_idle_ticks) {
    fece:	4b26      	ldr	r3, [pc, #152]	; (ff68 <os_tick_idle+0xa8>)
    fed0:	685b      	ldr	r3, [r3, #4]
    fed2:	42ab      	cmp	r3, r5
    fed4:	d200      	bcs.n	fed8 <os_tick_idle+0x18>
            ticks = g_hal_os_tick.max_idle_ticks;
    fed6:	461d      	mov	r5, r3
        }
        ocmp = g_hal_os_tick.lastocmp + (ticks*g_hal_os_tick.ticks_per_ostick);
    fed8:	4b23      	ldr	r3, [pc, #140]	; (ff68 <os_tick_idle+0xa8>)
    feda:	689c      	ldr	r4, [r3, #8]
    fedc:	681a      	ldr	r2, [r3, #0]
    fede:	fb05 4402 	mla	r4, r5, r2, r4
    OS_ASSERT_CRITICAL();
    fee2:	f7fd fafa 	bl	d4da <os_arch_in_critical>
    fee6:	bb20      	cbnz	r0, ff32 <os_tick_idle+0x72>
    fee8:	f7fc f958 	bl	c19c <hal_debugger_connected>
    feec:	b100      	cbz	r0, fef0 <os_tick_idle+0x30>
    feee:	be01      	bkpt	0x0001
    fef0:	2300      	movs	r3, #0
    fef2:	461a      	mov	r2, r3
    fef4:	4619      	mov	r1, r3
    fef6:	4618      	mov	r0, r3
    fef8:	f7fc fb2e 	bl	c558 <__assert_func>
    OS_ASSERT_CRITICAL();
    fefc:	f7fc f94e 	bl	c19c <hal_debugger_connected>
    ff00:	b100      	cbz	r0, ff04 <os_tick_idle+0x44>
    ff02:	be01      	bkpt	0x0001
    ff04:	2300      	movs	r3, #0
    ff06:	461a      	mov	r2, r3
    ff08:	4619      	mov	r1, r3
    ff0a:	4618      	mov	r0, r3
    ff0c:	f7fc fb24 	bl	c558 <__assert_func>
    assert(y <= 0xffffff);
    ff10:	f7fc f944 	bl	c19c <hal_debugger_connected>
    ff14:	b100      	cbz	r0, ff18 <os_tick_idle+0x58>
    ff16:	be01      	bkpt	0x0001
    ff18:	2300      	movs	r3, #0
    ff1a:	461a      	mov	r2, r3
    ff1c:	4619      	mov	r1, r3
    ff1e:	4618      	mov	r0, r3
    ff20:	f7fc fb1a 	bl	c558 <__assert_func>
        return (result & 0x007fffff);
    ff24:	f3c3 0316 	ubfx	r3, r3, #0, #23
        if (delta > 2) {
    ff28:	2b02      	cmp	r3, #2
    ff2a:	dc15      	bgt.n	ff58 <os_tick_idle+0x98>
        ocmp += g_hal_os_tick.ticks_per_ostick;
    ff2c:	4b0e      	ldr	r3, [pc, #56]	; (ff68 <os_tick_idle+0xa8>)
    ff2e:	681c      	ldr	r4, [r3, #0]
    ff30:	4414      	add	r4, r2
        ocmp &= 0xffffff;
    ff32:	f024 427f 	bic.w	r2, r4, #4278190080	; 0xff000000
        OS_TICK_TIMER->CC[OS_TICK_CMPREG] = ocmp;
    ff36:	4b0d      	ldr	r3, [pc, #52]	; (ff6c <os_tick_idle+0xac>)
    ff38:	f8c3 254c 	str.w	r2, [r3, #1356]	; 0x54c
    return OS_TICK_TIMER->COUNTER;
    ff3c:	f8d3 3504 	ldr.w	r3, [r3, #1284]	; 0x504
    assert(y <= 0xffffff);
    ff40:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
    ff44:	d2e4      	bcs.n	ff10 <os_tick_idle+0x50>
    result = x - y;
    ff46:	1ad3      	subs	r3, r2, r3
    if (result & 0x800000) {
    ff48:	f413 0f00 	tst.w	r3, #8388608	; 0x800000
    ff4c:	d0ea      	beq.n	ff24 <os_tick_idle+0x64>
        return (result | 0xff800000);
    ff4e:	ea6f 2343 	mvn.w	r3, r3, lsl #9
    ff52:	ea6f 2353 	mvn.w	r3, r3, lsr #9
    ff56:	e7e7      	b.n	ff28 <os_tick_idle+0x68>
  __ASM volatile ("dsb 0xF":::"memory");
    ff58:	f3bf 8f4f 	dsb	sy
        nrf52_os_tick_set_ocmp(ocmp);
    }

    __DSB();
    __WFI();
    ff5c:	bf30      	wfi

    if (ticks > 0) {
    ff5e:	b905      	cbnz	r5, ff62 <os_tick_idle+0xa2>
         * Update OS time before anything else when coming out of
         * the tickless regime.
         */
        nrf52_timer_handler();
    }
}
    ff60:	bd38      	pop	{r3, r4, r5, pc}
        nrf52_timer_handler();
    ff62:	f7ff ff33 	bl	fdcc <nrf52_timer_handler>
}
    ff66:	e7fb      	b.n	ff60 <os_tick_idle+0xa0>
    ff68:	20002374 	.word	0x20002374
    ff6c:	40011000 	.word	0x40011000

0000ff70 <os_tick_init>:

void
os_tick_init(uint32_t os_ticks_per_sec, int prio)
{
    ff70:	b570      	push	{r4, r5, r6, lr}
    uint32_t sr;

    assert(RTC_FREQ % os_ticks_per_sec == 0);
    ff72:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    ff76:	fbb3 f3f0 	udiv	r3, r3, r0
    ff7a:	fb00 f303 	mul.w	r3, r0, r3
    ff7e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    ff82:	d136      	bne.n	fff2 <os_tick_init+0x82>
    ff84:	460c      	mov	r4, r1

    g_hal_os_tick.lastocmp = 0;
    ff86:	4d20      	ldr	r5, [pc, #128]	; (10008 <os_tick_init+0x98>)
    ff88:	2600      	movs	r6, #0
    ff8a:	60ae      	str	r6, [r5, #8]
    g_hal_os_tick.ticks_per_ostick = RTC_FREQ / os_ticks_per_sec;
    ff8c:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    ff90:	fbb3 f0f0 	udiv	r0, r3, r0
    ff94:	6028      	str	r0, [r5, #0]
    /*
     * The maximum number of OS ticks allowed to elapse during idle is
     * limited to 1/4th the number of timer ticks before the 24-bit counter
     * rolls over.
     */
    g_hal_os_tick.max_idle_ticks = (1UL << 22) / g_hal_os_tick.ticks_per_ostick;
    ff96:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
    ff9a:	fbb3 f0f0 	udiv	r0, r3, r0
    ff9e:	6068      	str	r0, [r5, #4]

    /* disable interrupts */
    OS_ENTER_CRITICAL(sr);
    ffa0:	f7fd fa92 	bl	d4c8 <os_arch_save_sr>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    ffa4:	0164      	lsls	r4, r4, #5
    ffa6:	b2e4      	uxtb	r4, r4
    ffa8:	4b18      	ldr	r3, [pc, #96]	; (1000c <os_tick_init+0x9c>)
    ffaa:	f883 4311 	strb.w	r4, [r3, #785]	; 0x311
  uint32_t vectors = (uint32_t )SCB->VTOR;
    ffae:	4a18      	ldr	r2, [pc, #96]	; (10010 <os_tick_init+0xa0>)
    ffb0:	6892      	ldr	r2, [r2, #8]
  (* (int *) (vectors + ((int32_t)IRQn + NVIC_USER_IRQ_OFFSET) * 4)) = vector;
    ffb2:	4918      	ldr	r1, [pc, #96]	; (10014 <os_tick_init+0xa4>)
    ffb4:	f8c2 1084 	str.w	r1, [r2, #132]	; 0x84
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    ffb8:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    ffbc:	601a      	str	r2, [r3, #0]

    /*
     * Program the OS_TICK_TIMER to operate at 32KHz and trigger an output
     * compare interrupt at a rate of 'os_ticks_per_sec'.
     */
    OS_TICK_TIMER->TASKS_STOP = 1;
    ffbe:	f103 43c0 	add.w	r3, r3, #1610612736	; 0x60000000
    ffc2:	f503 533c 	add.w	r3, r3, #12032	; 0x2f00
    ffc6:	2201      	movs	r2, #1
    ffc8:	605a      	str	r2, [r3, #4]
    OS_TICK_TIMER->TASKS_CLEAR = 1;
    ffca:	609a      	str	r2, [r3, #8]

    OS_TICK_TIMER->EVTENCLR = 0xffffffff;
    ffcc:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    ffd0:	f8c3 1348 	str.w	r1, [r3, #840]	; 0x348
    OS_TICK_TIMER->INTENCLR = 0xffffffff;
    ffd4:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
    OS_TICK_TIMER->INTENSET = RTC_COMPARE_INT_MASK(OS_TICK_CMPREG);
    ffd8:	f44f 2100 	mov.w	r1, #524288	; 0x80000
    ffdc:	f8c3 1304 	str.w	r1, [r3, #772]	; 0x304

    OS_TICK_TIMER->EVENTS_COMPARE[OS_TICK_CMPREG] = 0;
    ffe0:	f8c3 614c 	str.w	r6, [r3, #332]	; 0x14c
    OS_TICK_TIMER->CC[OS_TICK_CMPREG] = g_hal_os_tick.ticks_per_ostick;
    ffe4:	6829      	ldr	r1, [r5, #0]
    ffe6:	f8c3 154c 	str.w	r1, [r3, #1356]	; 0x54c

    OS_TICK_TIMER->TASKS_START = 1;
    ffea:	601a      	str	r2, [r3, #0]

    OS_EXIT_CRITICAL(sr);
    ffec:	f7fd fa72 	bl	d4d4 <os_arch_restore_sr>
}
    fff0:	bd70      	pop	{r4, r5, r6, pc}
    assert(RTC_FREQ % os_ticks_per_sec == 0);
    fff2:	f7fc f8d3 	bl	c19c <hal_debugger_connected>
    fff6:	b100      	cbz	r0, fffa <os_tick_init+0x8a>
    fff8:	be01      	bkpt	0x0001
    fffa:	2300      	movs	r3, #0
    fffc:	461a      	mov	r2, r3
    fffe:	4619      	mov	r1, r3
   10000:	4618      	mov	r0, r3
   10002:	f7fc faa9 	bl	c558 <__assert_func>
   10006:	bf00      	nop
   10008:	20002374 	.word	0x20002374
   1000c:	e000e100 	.word	0xe000e100
   10010:	e000ed00 	.word	0xe000ed00
   10014:	0000fdcd 	.word	0x0000fdcd

00010018 <nrf52_hal_wdt_default_handler>:
#include "mcu/cmsis_nvic.h"
#include "nrf.h"

static void
nrf52_hal_wdt_default_handler(void)
{
   10018:	b508      	push	{r3, lr}
    assert(0);
   1001a:	f7fc f8bf 	bl	c19c <hal_debugger_connected>
   1001e:	b100      	cbz	r0, 10022 <nrf52_hal_wdt_default_handler+0xa>
   10020:	be01      	bkpt	0x0001
   10022:	2300      	movs	r3, #0
   10024:	461a      	mov	r2, r3
   10026:	4619      	mov	r1, r3
   10028:	4618      	mov	r0, r3
   1002a:	f7fc fa95 	bl	c558 <__assert_func>
	...

00010030 <nrf52_wdt_irq_handler>:
}

/**@brief WDT interrupt handler. */
static void
nrf52_wdt_irq_handler(void)
{
   10030:	b508      	push	{r3, lr}
    os_trace_isr_enter();
    if (NRF_WDT->INTENSET & WDT_INTENSET_TIMEOUT_Msk) {
   10032:	4b06      	ldr	r3, [pc, #24]	; (1004c <nrf52_wdt_irq_handler+0x1c>)
   10034:	f8d3 3304 	ldr.w	r3, [r3, #772]	; 0x304
   10038:	f013 0f01 	tst.w	r3, #1
   1003c:	d100      	bne.n	10040 <nrf52_wdt_irq_handler+0x10>
        NRF_WDT->EVENTS_TIMEOUT = 0;
        nrf52_hal_wdt_default_handler();
    }
    os_trace_isr_exit();
}
   1003e:	bd08      	pop	{r3, pc}
        NRF_WDT->EVENTS_TIMEOUT = 0;
   10040:	4b02      	ldr	r3, [pc, #8]	; (1004c <nrf52_wdt_irq_handler+0x1c>)
   10042:	2200      	movs	r2, #0
   10044:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
        nrf52_hal_wdt_default_handler();
   10048:	f7ff ffe6 	bl	10018 <nrf52_hal_wdt_default_handler>
   1004c:	40010000 	.word	0x40010000

00010050 <hal_watchdog_init>:

int
hal_watchdog_init(uint32_t expire_msecs)
{
   10050:	b508      	push	{r3, lr}
    NRF_WDT->CONFIG = WDT_CONFIG_SLEEP_Msk;
   10052:	4b19      	ldr	r3, [pc, #100]	; (100b8 <hal_watchdog_init+0x68>)
   10054:	2201      	movs	r2, #1
   10056:	f8c3 250c 	str.w	r2, [r3, #1292]	; 0x50c

    if (expire_msecs >= 44739243) {
   1005a:	4b18      	ldr	r3, [pc, #96]	; (100bc <hal_watchdog_init+0x6c>)
   1005c:	4298      	cmp	r0, r3
   1005e:	d821      	bhi.n	100a4 <hal_watchdog_init+0x54>
        /* maximum allowed time is near 12.5 hours! */
        assert(0);
    } else {
        NRF_WDT->CRV = (expire_msecs * 32) + ((expire_msecs * 96) / 125);
   10060:	eb00 0340 	add.w	r3, r0, r0, lsl #1
   10064:	015b      	lsls	r3, r3, #5
   10066:	4a16      	ldr	r2, [pc, #88]	; (100c0 <hal_watchdog_init+0x70>)
   10068:	fba2 2303 	umull	r2, r3, r2, r3
   1006c:	08db      	lsrs	r3, r3, #3
   1006e:	eb03 1040 	add.w	r0, r3, r0, lsl #5
   10072:	4b11      	ldr	r3, [pc, #68]	; (100b8 <hal_watchdog_init+0x68>)
   10074:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
  uint32_t vectors = (uint32_t )SCB->VTOR;
   10078:	4a12      	ldr	r2, [pc, #72]	; (100c4 <hal_watchdog_init+0x74>)
   1007a:	6892      	ldr	r2, [r2, #8]
  (* (int *) (vectors + ((int32_t)IRQn + NVIC_USER_IRQ_OFFSET) * 4)) = vector;
   1007c:	4912      	ldr	r1, [pc, #72]	; (100c8 <hal_watchdog_init+0x78>)
   1007e:	f8c2 1080 	str.w	r1, [r2, #128]	; 0x80
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   10082:	4a12      	ldr	r2, [pc, #72]	; (100cc <hal_watchdog_init+0x7c>)
   10084:	21e0      	movs	r1, #224	; 0xe0
   10086:	f882 1310 	strb.w	r1, [r2, #784]	; 0x310
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1008a:	f44f 3180 	mov.w	r1, #65536	; 0x10000
   1008e:	f8c2 1180 	str.w	r1, [r2, #384]	; 0x180
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   10092:	6011      	str	r1, [r2, #0]

    NVIC_SetVector(WDT_IRQn, (uint32_t) nrf52_wdt_irq_handler);
    NVIC_SetPriority(WDT_IRQn, (1 << __NVIC_PRIO_BITS) - 1);
    NVIC_ClearPendingIRQ(WDT_IRQn);
    NVIC_EnableIRQ(WDT_IRQn);
    NRF_WDT->RREN |= 0x1;
   10094:	f8d3 2508 	ldr.w	r2, [r3, #1288]	; 0x508
   10098:	f042 0201 	orr.w	r2, r2, #1
   1009c:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508

    return (0);
}
   100a0:	2000      	movs	r0, #0
   100a2:	bd08      	pop	{r3, pc}
        assert(0);
   100a4:	f7fc f87a 	bl	c19c <hal_debugger_connected>
   100a8:	b100      	cbz	r0, 100ac <hal_watchdog_init+0x5c>
   100aa:	be01      	bkpt	0x0001
   100ac:	2300      	movs	r3, #0
   100ae:	461a      	mov	r2, r3
   100b0:	4619      	mov	r1, r3
   100b2:	4618      	mov	r0, r3
   100b4:	f7fc fa50 	bl	c558 <__assert_func>
   100b8:	40010000 	.word	0x40010000
   100bc:	02aaaaaa 	.word	0x02aaaaaa
   100c0:	10624dd3 	.word	0x10624dd3
   100c4:	e000ed00 	.word	0xe000ed00
   100c8:	00010031 	.word	0x00010031
   100cc:	e000e100 	.word	0xe000e100

000100d0 <hal_watchdog_enable>:

void
hal_watchdog_enable(void)
{
    NRF_WDT->INTENSET = WDT_INTENSET_TIMEOUT_Msk;
   100d0:	4b02      	ldr	r3, [pc, #8]	; (100dc <hal_watchdog_enable+0xc>)
   100d2:	2201      	movs	r2, #1
   100d4:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    NRF_WDT->TASKS_START = 1;
   100d8:	601a      	str	r2, [r3, #0]
}
   100da:	4770      	bx	lr
   100dc:	40010000 	.word	0x40010000

000100e0 <hal_watchdog_tickle>:

void
hal_watchdog_tickle(void)
{
    NRF_WDT->RR[0] = WDT_RR_RR_Reload;
   100e0:	4b02      	ldr	r3, [pc, #8]	; (100ec <hal_watchdog_tickle+0xc>)
   100e2:	4a03      	ldr	r2, [pc, #12]	; (100f0 <hal_watchdog_tickle+0x10>)
   100e4:	f8c3 2600 	str.w	r2, [r3, #1536]	; 0x600
}
   100e8:	4770      	bx	lr
   100ea:	bf00      	nop
   100ec:	40010000 	.word	0x40010000
   100f0:	6e524635 	.word	0x6e524635

000100f4 <nrf52_periph_create_timers>:
static struct temperature_dev os_bsp_temp;
#endif

static void
nrf52_periph_create_timers(void)
{
   100f4:	b508      	push	{r3, lr}
    int rc;

    (void)rc;

#if MYNEWT_VAL(TIMER_0)
    rc = hal_timer_init(0, NULL);
   100f6:	2100      	movs	r1, #0
   100f8:	4608      	mov	r0, r1
   100fa:	f000 f955 	bl	103a8 <hal_timer_init>
    assert(rc == 0);
   100fe:	b920      	cbnz	r0, 1010a <nrf52_periph_create_timers+0x16>
    rc = hal_timer_init(5, NULL);
    assert(rc == 0);
#endif

#if MYNEWT_VAL(OS_CPUTIME_TIMER_NUM) >= 0
    rc = os_cputime_init(MYNEWT_VAL(OS_CPUTIME_FREQ));
   10100:	480c      	ldr	r0, [pc, #48]	; (10134 <nrf52_periph_create_timers+0x40>)
   10102:	f000 fa21 	bl	10548 <os_cputime_init>
    assert(rc == 0);
   10106:	b950      	cbnz	r0, 1011e <nrf52_periph_create_timers+0x2a>
#endif
}
   10108:	bd08      	pop	{r3, pc}
    assert(rc == 0);
   1010a:	f7fc f847 	bl	c19c <hal_debugger_connected>
   1010e:	b100      	cbz	r0, 10112 <nrf52_periph_create_timers+0x1e>
   10110:	be01      	bkpt	0x0001
   10112:	2300      	movs	r3, #0
   10114:	461a      	mov	r2, r3
   10116:	4619      	mov	r1, r3
   10118:	4618      	mov	r0, r3
   1011a:	f7fc fa1d 	bl	c558 <__assert_func>
    assert(rc == 0);
   1011e:	f7fc f83d 	bl	c19c <hal_debugger_connected>
   10122:	b100      	cbz	r0, 10126 <nrf52_periph_create_timers+0x32>
   10124:	be01      	bkpt	0x0001
   10126:	2300      	movs	r3, #0
   10128:	461a      	mov	r2, r3
   1012a:	4619      	mov	r1, r3
   1012c:	4618      	mov	r0, r3
   1012e:	f7fc fa13 	bl	c558 <__assert_func>
   10132:	bf00      	nop
   10134:	000f4240 	.word	0x000f4240

00010138 <nrf52_periph_create_uart>:
#endif
}

static void
nrf52_periph_create_uart(void)
{
   10138:	b500      	push	{lr}
   1013a:	b083      	sub	sp, #12
    int rc;

    (void)rc;

#if MYNEWT_VAL(UART_0)
    rc = os_dev_create(&os_bsp_uart0.ud_dev, "uart0",
   1013c:	4b0b      	ldr	r3, [pc, #44]	; (1016c <nrf52_periph_create_uart+0x34>)
   1013e:	9301      	str	r3, [sp, #4]
   10140:	4b0b      	ldr	r3, [pc, #44]	; (10170 <nrf52_periph_create_uart+0x38>)
   10142:	9300      	str	r3, [sp, #0]
   10144:	2300      	movs	r3, #0
   10146:	2201      	movs	r2, #1
   10148:	490a      	ldr	r1, [pc, #40]	; (10174 <nrf52_periph_create_uart+0x3c>)
   1014a:	480b      	ldr	r0, [pc, #44]	; (10178 <nrf52_periph_create_uart+0x40>)
   1014c:	f7fc fc52 	bl	c9f4 <os_dev_create>
                       OS_DEV_INIT_PRIMARY, 0, uart_hal_init,
                       (void *)&os_bsp_uart0_cfg);
    assert(rc == 0);
   10150:	b910      	cbnz	r0, 10158 <nrf52_periph_create_uart+0x20>
    rc = os_dev_create(&os_bsp_uart1.ud_dev, "uart1",
                       OS_DEV_INIT_PRIMARY, 1, uart_hal_init,
                       (void *)&os_bsp_uart1_cfg);
    assert(rc == 0);
#endif
}
   10152:	b003      	add	sp, #12
   10154:	f85d fb04 	ldr.w	pc, [sp], #4
    assert(rc == 0);
   10158:	f7fc f820 	bl	c19c <hal_debugger_connected>
   1015c:	b100      	cbz	r0, 10160 <nrf52_periph_create_uart+0x28>
   1015e:	be01      	bkpt	0x0001
   10160:	2300      	movs	r3, #0
   10162:	461a      	mov	r2, r3
   10164:	4619      	mov	r1, r3
   10166:	4618      	mov	r0, r3
   10168:	f7fc f9f6 	bl	c558 <__assert_func>
   1016c:	00011b80 	.word	0x00011b80
   10170:	00011019 	.word	0x00011019
   10174:	000119c0 	.word	0x000119c0
   10178:	20002380 	.word	0x20002380

0001017c <nrf52_periph_create>:
#endif
}

void
nrf52_periph_create(void)
{
   1017c:	b508      	push	{r3, lr}
    nrf52_periph_create_timers();
   1017e:	f7ff ffb9 	bl	100f4 <nrf52_periph_create_timers>
    nrf52_periph_create_adc();
    nrf52_periph_create_pwm();
    nrf52_periph_create_trng();
    nrf52_periph_create_crypto();
    nrf52_periph_create_uart();
   10182:	f7ff ffd9 	bl	10138 <nrf52_periph_create_uart>
    nrf52_periph_create_i2c();
    nrf52_periph_create_spi();
    nrf52_periph_create_temp();
}
   10186:	bd08      	pop	{r3, pc}

00010188 <nrf_read_timer_cntr>:
nrf_read_timer_cntr(NRF_TIMER_Type *hwtimer)
{
    uint32_t tcntr;

    /* Force a capture of the timer into 'cntr' capture channel; read it */
    hwtimer->TASKS_CAPTURE[NRF_TIMER_CC_READ] = 1;
   10188:	2301      	movs	r3, #1
   1018a:	6483      	str	r3, [r0, #72]	; 0x48
    tcntr = hwtimer->CC[NRF_TIMER_CC_READ];
   1018c:	f8d0 0548 	ldr.w	r0, [r0, #1352]	; 0x548

    return tcntr;
}
   10190:	4770      	bx	lr
	...

00010194 <nrf_timer_set_ocmp>:
 *
 * @param timer Pointer to timer.
 */
static void
nrf_timer_set_ocmp(struct nrf52_hal_timer *bsptimer, uint32_t expiry)
{
   10194:	b538      	push	{r3, r4, r5, lr}
   10196:	4604      	mov	r4, r0
   10198:	460d      	mov	r5, r1
    uint32_t temp;
    uint32_t cntr;
    NRF_TIMER_Type *hwtimer;
    NRF_RTC_Type *rtctimer;

    if (bsptimer->tmr_rtc) {
   1019a:	7883      	ldrb	r3, [r0, #2]
   1019c:	2b00      	cmp	r3, #0
   1019e:	d052      	beq.n	10246 <nrf_timer_set_ocmp+0xb2>
        rtctimer = (NRF_RTC_Type *)bsptimer->tmr_reg;
   101a0:	6902      	ldr	r2, [r0, #16]
        rtctimer->INTENCLR = NRF_TIMER_INT_MASK(NRF_RTC_TIMER_CC_INT);
   101a2:	f44f 2380 	mov.w	r3, #262144	; 0x40000
   101a6:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308
        temp = bsptimer->tmr_cntr;
   101aa:	6843      	ldr	r3, [r0, #4]
        cntr = rtctimer->COUNTER;
   101ac:	f8d2 1504 	ldr.w	r1, [r2, #1284]	; 0x504
        if (rtctimer->EVENTS_OVRFLW) {
   101b0:	f8d2 0104 	ldr.w	r0, [r2, #260]	; 0x104
   101b4:	b118      	cbz	r0, 101be <nrf_timer_set_ocmp+0x2a>
            temp += (1UL << 24);
   101b6:	f103 7380 	add.w	r3, r3, #16777216	; 0x1000000
            cntr = rtctimer->COUNTER;
   101ba:	f8d2 1504 	ldr.w	r1, [r2, #1284]	; 0x504
        }
        temp |= cntr;
   101be:	430b      	orrs	r3, r1
        delta_t = (int32_t)(expiry - temp);
   101c0:	1aeb      	subs	r3, r5, r3
         * to be handled differently. TICK event is used to have interrupt on
         * each subsequent tick so we won't miss any and in case we detected
         * mentioned extra tick during calculations, interrupt is triggered
         * immediately. Delta 0 or less means we should always fire immediately.
         */
        if (delta_t < 1) {
   101c2:	2b00      	cmp	r3, #0
   101c4:	dd18      	ble.n	101f8 <nrf_timer_set_ocmp+0x64>
            rtctimer->INTENCLR = RTC_INTENCLR_TICK_Msk;
            NVIC_SetPendingIRQ(bsptimer->tmr_irq_num);
        } else if (delta_t < 3) {
   101c6:	2b02      	cmp	r3, #2
   101c8:	dc29      	bgt.n	1021e <nrf_timer_set_ocmp+0x8a>
            rtctimer->INTENSET = RTC_INTENSET_TICK_Msk;
   101ca:	2301      	movs	r3, #1
   101cc:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
            if (rtctimer->COUNTER != cntr) {
   101d0:	f8d2 3504 	ldr.w	r3, [r2, #1284]	; 0x504
   101d4:	428b      	cmp	r3, r1
   101d6:	d030      	beq.n	1023a <nrf_timer_set_ocmp+0xa6>
                NVIC_SetPendingIRQ(bsptimer->tmr_irq_num);
   101d8:	7862      	ldrb	r2, [r4, #1]
   101da:	f994 3001 	ldrsb.w	r3, [r4, #1]
  if ((int32_t)(IRQn) >= 0)
   101de:	2b00      	cmp	r3, #0
   101e0:	db2b      	blt.n	1023a <nrf_timer_set_ocmp+0xa6>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   101e2:	f002 021f 	and.w	r2, r2, #31
   101e6:	095b      	lsrs	r3, r3, #5
   101e8:	2101      	movs	r1, #1
   101ea:	fa01 f202 	lsl.w	r2, r1, r2
   101ee:	3340      	adds	r3, #64	; 0x40
   101f0:	4925      	ldr	r1, [pc, #148]	; (10288 <nrf_timer_set_ocmp+0xf4>)
   101f2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
   101f6:	e020      	b.n	1023a <nrf_timer_set_ocmp+0xa6>
            rtctimer->INTENCLR = RTC_INTENCLR_TICK_Msk;
   101f8:	2301      	movs	r3, #1
   101fa:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308
            NVIC_SetPendingIRQ(bsptimer->tmr_irq_num);
   101fe:	7862      	ldrb	r2, [r4, #1]
   10200:	f994 3001 	ldrsb.w	r3, [r4, #1]
  if ((int32_t)(IRQn) >= 0)
   10204:	2b00      	cmp	r3, #0
   10206:	db18      	blt.n	1023a <nrf_timer_set_ocmp+0xa6>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   10208:	f002 021f 	and.w	r2, r2, #31
   1020c:	095b      	lsrs	r3, r3, #5
   1020e:	2101      	movs	r1, #1
   10210:	fa01 f202 	lsl.w	r2, r1, r2
   10214:	3340      	adds	r3, #64	; 0x40
   10216:	491c      	ldr	r1, [pc, #112]	; (10288 <nrf_timer_set_ocmp+0xf4>)
   10218:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
   1021c:	e00d      	b.n	1023a <nrf_timer_set_ocmp+0xa6>
            }
        } else {
            rtctimer->INTENCLR = RTC_INTENCLR_TICK_Msk;
   1021e:	2001      	movs	r0, #1
   10220:	f8c2 0308 	str.w	r0, [r2, #776]	; 0x308

            if (delta_t < (1UL << 24)) {
   10224:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
   10228:	d208      	bcs.n	1023c <nrf_timer_set_ocmp+0xa8>
                rtctimer->CC[NRF_RTC_TIMER_CC_INT] = expiry & 0x00ffffff;
   1022a:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
   1022e:	f8c2 5548 	str.w	r5, [r2, #1352]	; 0x548
            } else {
                /* CC too far ahead. Just make sure we set compare far ahead */
                rtctimer->CC[NRF_RTC_TIMER_CC_INT] = cntr + (1UL << 23);
            }
            rtctimer->INTENSET = NRF_TIMER_INT_MASK(NRF_RTC_TIMER_CC_INT);
   10232:	f44f 2380 	mov.w	r3, #262144	; 0x40000
   10236:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
        /* Force interrupt to occur as we may have missed it */
        if ((int32_t)(nrf_read_timer_cntr(hwtimer) - expiry) >= 0) {
            NVIC_SetPendingIRQ(bsptimer->tmr_irq_num);
        }
    }
}
   1023a:	bd38      	pop	{r3, r4, r5, pc}
                rtctimer->CC[NRF_RTC_TIMER_CC_INT] = cntr + (1UL << 23);
   1023c:	f501 0100 	add.w	r1, r1, #8388608	; 0x800000
   10240:	f8c2 1548 	str.w	r1, [r2, #1352]	; 0x548
   10244:	e7f5      	b.n	10232 <nrf_timer_set_ocmp+0x9e>
        hwtimer = bsptimer->tmr_reg;
   10246:	6900      	ldr	r0, [r0, #16]
        hwtimer->INTENCLR = NRF_TIMER_INT_MASK(NRF_TIMER_CC_INT);
   10248:	f44f 2300 	mov.w	r3, #524288	; 0x80000
   1024c:	f8c0 3308 	str.w	r3, [r0, #776]	; 0x308
        hwtimer->CC[NRF_TIMER_CC_INT] = expiry;
   10250:	f8c0 154c 	str.w	r1, [r0, #1356]	; 0x54c
        hwtimer->EVENTS_COMPARE[NRF_TIMER_CC_INT] = 0;
   10254:	2200      	movs	r2, #0
   10256:	f8c0 214c 	str.w	r2, [r0, #332]	; 0x14c
        hwtimer->INTENSET = NRF_TIMER_INT_MASK(NRF_TIMER_CC_INT);
   1025a:	f8c0 3304 	str.w	r3, [r0, #772]	; 0x304
        if ((int32_t)(nrf_read_timer_cntr(hwtimer) - expiry) >= 0) {
   1025e:	f7ff ff93 	bl	10188 <nrf_read_timer_cntr>
   10262:	1b45      	subs	r5, r0, r5
   10264:	2d00      	cmp	r5, #0
   10266:	dbe8      	blt.n	1023a <nrf_timer_set_ocmp+0xa6>
            NVIC_SetPendingIRQ(bsptimer->tmr_irq_num);
   10268:	7862      	ldrb	r2, [r4, #1]
   1026a:	f994 3001 	ldrsb.w	r3, [r4, #1]
  if ((int32_t)(IRQn) >= 0)
   1026e:	2b00      	cmp	r3, #0
   10270:	dbe3      	blt.n	1023a <nrf_timer_set_ocmp+0xa6>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   10272:	f002 021f 	and.w	r2, r2, #31
   10276:	095b      	lsrs	r3, r3, #5
   10278:	2101      	movs	r1, #1
   1027a:	fa01 f202 	lsl.w	r2, r1, r2
   1027e:	3340      	adds	r3, #64	; 0x40
   10280:	4901      	ldr	r1, [pc, #4]	; (10288 <nrf_timer_set_ocmp+0xf4>)
   10282:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   10286:	e7d8      	b.n	1023a <nrf_timer_set_ocmp+0xa6>
   10288:	e000e100 	.word	0xe000e100

0001028c <nrf_timer_disable_ocmp>:

/* Disable output compare used for timer */
static void
nrf_timer_disable_ocmp(NRF_TIMER_Type *hwtimer)
{
    hwtimer->INTENCLR = NRF_TIMER_INT_MASK(NRF_TIMER_CC_INT);
   1028c:	f44f 2300 	mov.w	r3, #524288	; 0x80000
   10290:	f8c0 3308 	str.w	r3, [r0, #776]	; 0x308
}
   10294:	4770      	bx	lr

00010296 <nrf_rtc_disable_ocmp>:

static void
nrf_rtc_disable_ocmp(NRF_RTC_Type *rtctimer)
{
    rtctimer->INTENCLR = NRF_TIMER_INT_MASK(NRF_RTC_TIMER_CC_INT);
   10296:	f44f 2380 	mov.w	r3, #262144	; 0x40000
   1029a:	f8c0 3308 	str.w	r3, [r0, #776]	; 0x308
    rtctimer->INTENCLR = RTC_INTENCLR_TICK_Msk;
   1029e:	2301      	movs	r3, #1
   102a0:	f8c0 3308 	str.w	r3, [r0, #776]	; 0x308
}
   102a4:	4770      	bx	lr
	...

000102a8 <hal_timer_read_bsptimer>:

static uint32_t
hal_timer_read_bsptimer(struct nrf52_hal_timer *bsptimer)
{
   102a8:	b430      	push	{r4, r5}
    uint32_t low32;
    uint32_t ctx;
    uint32_t tcntr;
    NRF_RTC_Type *rtctimer;

    rtctimer = (NRF_RTC_Type *)bsptimer->tmr_reg;
   102aa:	6902      	ldr	r2, [r0, #16]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
   102ac:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
   102b0:	b672      	cpsid	i
    __HAL_DISABLE_INTERRUPTS(ctx);
    tcntr = bsptimer->tmr_cntr;
   102b2:	6841      	ldr	r1, [r0, #4]
    low32 = rtctimer->COUNTER;
   102b4:	f8d2 3504 	ldr.w	r3, [r2, #1284]	; 0x504
    if (rtctimer->EVENTS_OVRFLW) {
   102b8:	f8d2 5104 	ldr.w	r5, [r2, #260]	; 0x104
   102bc:	b1b5      	cbz	r5, 102ec <hal_timer_read_bsptimer+0x44>
        tcntr += (1UL << 24);
   102be:	f101 7180 	add.w	r1, r1, #16777216	; 0x1000000
        bsptimer->tmr_cntr = tcntr;
   102c2:	6041      	str	r1, [r0, #4]
        low32 = rtctimer->COUNTER;
   102c4:	f8d2 3504 	ldr.w	r3, [r2, #1284]	; 0x504
        rtctimer->EVENTS_OVRFLW = 0;
   102c8:	2500      	movs	r5, #0
   102ca:	f8c2 5104 	str.w	r5, [r2, #260]	; 0x104
        NVIC_SetPendingIRQ(bsptimer->tmr_irq_num);
   102ce:	7845      	ldrb	r5, [r0, #1]
   102d0:	f990 2001 	ldrsb.w	r2, [r0, #1]
  if ((int32_t)(IRQn) >= 0)
   102d4:	2a00      	cmp	r2, #0
   102d6:	db09      	blt.n	102ec <hal_timer_read_bsptimer+0x44>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   102d8:	f005 051f 	and.w	r5, r5, #31
   102dc:	0952      	lsrs	r2, r2, #5
   102de:	2001      	movs	r0, #1
   102e0:	fa00 f505 	lsl.w	r5, r0, r5
   102e4:	3240      	adds	r2, #64	; 0x40
   102e6:	4804      	ldr	r0, [pc, #16]	; (102f8 <hal_timer_read_bsptimer+0x50>)
   102e8:	f840 5022 	str.w	r5, [r0, r2, lsl #2]
    }
    tcntr |= low32;
   102ec:	ea43 0001 	orr.w	r0, r3, r1
    __HAL_ENABLE_INTERRUPTS(ctx);
   102f0:	b904      	cbnz	r4, 102f4 <hal_timer_read_bsptimer+0x4c>
  __ASM volatile ("cpsie i" : : : "memory");
   102f2:	b662      	cpsie	i

    return tcntr;
}
   102f4:	bc30      	pop	{r4, r5}
   102f6:	4770      	bx	lr
   102f8:	e000e100 	.word	0xe000e100

000102fc <hal_timer_chk_queue>:
 *
 * @param bsptimer
 */
static void
hal_timer_chk_queue(struct nrf52_hal_timer *bsptimer)
{
   102fc:	b570      	push	{r4, r5, r6, lr}
   102fe:	4605      	mov	r5, r0
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
   10300:	f3ef 8610 	mrs	r6, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
   10304:	b672      	cpsid	i
}
   10306:	e012      	b.n	1032e <hal_timer_chk_queue+0x32>
    __HAL_DISABLE_INTERRUPTS(ctx);
    while ((timer = TAILQ_FIRST(&bsptimer->hal_timer_q)) != NULL) {
        if (bsptimer->tmr_rtc) {
            tcntr = hal_timer_read_bsptimer(bsptimer);
        } else {
            tcntr = nrf_read_timer_cntr(bsptimer->tmr_reg);
   10308:	6928      	ldr	r0, [r5, #16]
   1030a:	f7ff ff3d 	bl	10188 <nrf_read_timer_cntr>
        }
        if ((int32_t)(tcntr - timer->expiry) >= 0) {
   1030e:	68e3      	ldr	r3, [r4, #12]
   10310:	1ac0      	subs	r0, r0, r3
   10312:	2800      	cmp	r0, #0
   10314:	db17      	blt.n	10346 <hal_timer_chk_queue+0x4a>
            TAILQ_REMOVE(&bsptimer->hal_timer_q, timer, link);
   10316:	6923      	ldr	r3, [r4, #16]
   10318:	b193      	cbz	r3, 10340 <hal_timer_chk_queue+0x44>
   1031a:	6962      	ldr	r2, [r4, #20]
   1031c:	615a      	str	r2, [r3, #20]
   1031e:	6963      	ldr	r3, [r4, #20]
   10320:	6922      	ldr	r2, [r4, #16]
   10322:	601a      	str	r2, [r3, #0]
            timer->link.tqe_prev = NULL;
   10324:	2300      	movs	r3, #0
   10326:	6163      	str	r3, [r4, #20]
            timer->cb_func(timer->cb_arg);
   10328:	6863      	ldr	r3, [r4, #4]
   1032a:	68a0      	ldr	r0, [r4, #8]
   1032c:	4798      	blx	r3
    while ((timer = TAILQ_FIRST(&bsptimer->hal_timer_q)) != NULL) {
   1032e:	696c      	ldr	r4, [r5, #20]
   10330:	b14c      	cbz	r4, 10346 <hal_timer_chk_queue+0x4a>
        if (bsptimer->tmr_rtc) {
   10332:	78ab      	ldrb	r3, [r5, #2]
   10334:	2b00      	cmp	r3, #0
   10336:	d0e7      	beq.n	10308 <hal_timer_chk_queue+0xc>
            tcntr = hal_timer_read_bsptimer(bsptimer);
   10338:	4628      	mov	r0, r5
   1033a:	f7ff ffb5 	bl	102a8 <hal_timer_read_bsptimer>
   1033e:	e7e6      	b.n	1030e <hal_timer_chk_queue+0x12>
            TAILQ_REMOVE(&bsptimer->hal_timer_q, timer, link);
   10340:	6963      	ldr	r3, [r4, #20]
   10342:	61ab      	str	r3, [r5, #24]
   10344:	e7eb      	b.n	1031e <hal_timer_chk_queue+0x22>
            break;
        }
    }

    /* Any timers left on queue? If so, we need to set OCMP */
    timer = TAILQ_FIRST(&bsptimer->hal_timer_q);
   10346:	696b      	ldr	r3, [r5, #20]
    if (timer) {
   10348:	b133      	cbz	r3, 10358 <hal_timer_chk_queue+0x5c>
        nrf_timer_set_ocmp(bsptimer, timer->expiry);
   1034a:	68d9      	ldr	r1, [r3, #12]
   1034c:	4628      	mov	r0, r5
   1034e:	f7ff ff21 	bl	10194 <nrf_timer_set_ocmp>
            nrf_rtc_disable_ocmp((NRF_RTC_Type *)bsptimer->tmr_reg);
        } else {
            nrf_timer_disable_ocmp(bsptimer->tmr_reg);
        }
    }
    __HAL_ENABLE_INTERRUPTS(ctx);
   10352:	b906      	cbnz	r6, 10356 <hal_timer_chk_queue+0x5a>
  __ASM volatile ("cpsie i" : : : "memory");
   10354:	b662      	cpsie	i
}
   10356:	bd70      	pop	{r4, r5, r6, pc}
        if (bsptimer->tmr_rtc) {
   10358:	78ab      	ldrb	r3, [r5, #2]
   1035a:	b11b      	cbz	r3, 10364 <hal_timer_chk_queue+0x68>
            nrf_rtc_disable_ocmp((NRF_RTC_Type *)bsptimer->tmr_reg);
   1035c:	6928      	ldr	r0, [r5, #16]
   1035e:	f7ff ff9a 	bl	10296 <nrf_rtc_disable_ocmp>
   10362:	e7f6      	b.n	10352 <hal_timer_chk_queue+0x56>
            nrf_timer_disable_ocmp(bsptimer->tmr_reg);
   10364:	6928      	ldr	r0, [r5, #16]
   10366:	f7ff ff91 	bl	1028c <nrf_timer_disable_ocmp>
   1036a:	e7f2      	b.n	10352 <hal_timer_chk_queue+0x56>

0001036c <hal_timer_irq_handler>:
#if (MYNEWT_VAL(TIMER_0) || MYNEWT_VAL(TIMER_1) || MYNEWT_VAL(TIMER_2) || \
     MYNEWT_VAL(TIMER_3) || MYNEWT_VAL(TIMER_4))

static void
hal_timer_irq_handler(struct nrf52_hal_timer *bsptimer)
{
   1036c:	b510      	push	{r4, lr}
    NRF_TIMER_Type *hwtimer;

    os_trace_isr_enter();

    /* Check interrupt source. If set, clear them */
    hwtimer = bsptimer->tmr_reg;
   1036e:	6904      	ldr	r4, [r0, #16]
    compare = hwtimer->EVENTS_COMPARE[NRF_TIMER_CC_INT];
   10370:	f8d4 314c 	ldr.w	r3, [r4, #332]	; 0x14c
    if (compare) {
   10374:	b113      	cbz	r3, 1037c <hal_timer_irq_handler+0x10>
        hwtimer->EVENTS_COMPARE[NRF_TIMER_CC_INT] = 0;
   10376:	2300      	movs	r3, #0
   10378:	f8c4 314c 	str.w	r3, [r4, #332]	; 0x14c
    }

    /* XXX: make these stats? */
    /* Count # of timer isrs */
    ++bsptimer->timer_isrs;
   1037c:	6883      	ldr	r3, [r0, #8]
   1037e:	3301      	adds	r3, #1
   10380:	6083      	str	r3, [r0, #8]
     * counter is already passed the output compare value), we use the NVIC
     * to set a pending interrupt. This means that there will be no compare
     * flag set, so all we do is check to see if the compare interrupt is
     * enabled.
     */
    if (hwtimer->INTENCLR & NRF_TIMER_INT_MASK(NRF_TIMER_CC_INT)) {
   10382:	f8d4 3308 	ldr.w	r3, [r4, #776]	; 0x308
   10386:	f413 2f00 	tst.w	r3, #524288	; 0x80000
   1038a:	d100      	bne.n	1038e <hal_timer_irq_handler+0x22>
        /* XXX: Recommended by nordic to make sure interrupts are cleared */
        compare = hwtimer->EVENTS_COMPARE[NRF_TIMER_CC_INT];
    }

    os_trace_isr_exit();
}
   1038c:	bd10      	pop	{r4, pc}
        hal_timer_chk_queue(bsptimer);
   1038e:	f7ff ffb5 	bl	102fc <hal_timer_chk_queue>
        compare = hwtimer->EVENTS_COMPARE[NRF_TIMER_CC_INT];
   10392:	f8d4 314c 	ldr.w	r3, [r4, #332]	; 0x14c
}
   10396:	e7f9      	b.n	1038c <hal_timer_irq_handler+0x20>

00010398 <nrf52_timer0_irq_handler>:
#endif

#if MYNEWT_VAL(TIMER_0)
void
nrf52_timer0_irq_handler(void)
{
   10398:	b508      	push	{r3, lr}
    hal_timer_irq_handler(&nrf52_hal_timer0);
   1039a:	4802      	ldr	r0, [pc, #8]	; (103a4 <nrf52_timer0_irq_handler+0xc>)
   1039c:	f7ff ffe6 	bl	1036c <hal_timer_irq_handler>
}
   103a0:	bd08      	pop	{r3, pc}
   103a2:	bf00      	nop
   103a4:	200023bc 	.word	0x200023bc

000103a8 <hal_timer_init>:
    uint8_t irq_num;
    struct nrf52_hal_timer *bsptimer;
    void *hwtimer;
    hal_timer_irq_handler_t irq_isr;

    NRF52_HAL_TIMER_RESOLVE(timer_num, bsptimer);
   103a8:	2805      	cmp	r0, #5
   103aa:	dc1c      	bgt.n	103e6 <hal_timer_init+0x3e>
   103ac:	4b12      	ldr	r3, [pc, #72]	; (103f8 <hal_timer_init+0x50>)
   103ae:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   103b2:	b1d3      	cbz	r3, 103ea <hal_timer_init+0x42>

    /* If timer is enabled do not allow init */
    if (bsptimer->tmr_enabled) {
   103b4:	781a      	ldrb	r2, [r3, #0]
   103b6:	b9d2      	cbnz	r2, 103ee <hal_timer_init+0x46>
        rc = EINVAL;
        goto err;
    }

    switch (timer_num) {
   103b8:	b9d8      	cbnz	r0, 103f2 <hal_timer_init+0x4a>
    if (hwtimer == NULL) {
        rc = EINVAL;
        goto err;
    }

    bsptimer->tmr_reg = hwtimer;
   103ba:	4a10      	ldr	r2, [pc, #64]	; (103fc <hal_timer_init+0x54>)
   103bc:	611a      	str	r2, [r3, #16]
    bsptimer->tmr_irq_num = irq_num;
   103be:	2208      	movs	r2, #8
   103c0:	705a      	strb	r2, [r3, #1]
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   103c2:	4b0f      	ldr	r3, [pc, #60]	; (10400 <hal_timer_init+0x58>)
   103c4:	f44f 7280 	mov.w	r2, #256	; 0x100
   103c8:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  __ASM volatile ("dsb 0xF":::"memory");
   103cc:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   103d0:	f3bf 8f6f 	isb	sy
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   103d4:	22e0      	movs	r2, #224	; 0xe0
   103d6:	f883 2308 	strb.w	r2, [r3, #776]	; 0x308
  uint32_t vectors = (uint32_t )SCB->VTOR;
   103da:	f503 6340 	add.w	r3, r3, #3072	; 0xc00
   103de:	689b      	ldr	r3, [r3, #8]
  (* (int *) (vectors + ((int32_t)IRQn + NVIC_USER_IRQ_OFFSET) * 4)) = vector;
   103e0:	4a08      	ldr	r2, [pc, #32]	; (10404 <hal_timer_init+0x5c>)
   103e2:	661a      	str	r2, [r3, #96]	; 0x60
    /* Disable IRQ, set priority and set vector in table */
    NVIC_DisableIRQ(irq_num);
    NVIC_SetPriority(irq_num, (1 << __NVIC_PRIO_BITS) - 1);
    NVIC_SetVector(irq_num, (uint32_t)irq_isr);

    return 0;
   103e4:	4770      	bx	lr

err:
    return rc;
   103e6:	2016      	movs	r0, #22
   103e8:	4770      	bx	lr
   103ea:	2016      	movs	r0, #22
   103ec:	4770      	bx	lr
   103ee:	2016      	movs	r0, #22
   103f0:	4770      	bx	lr
   103f2:	2016      	movs	r0, #22
}
   103f4:	4770      	bx	lr
   103f6:	bf00      	nop
   103f8:	00011b84 	.word	0x00011b84
   103fc:	40008000 	.word	0x40008000
   10400:	e000e100 	.word	0xe000e100
   10404:	00010399 	.word	0x00010399

00010408 <hal_timer_config>:
    NRF_TIMER_Type *hwtimer;
#if MYNEWT_VAL(TIMER_5)
    NRF_RTC_Type *rtctimer;
#endif

    NRF52_HAL_TIMER_RESOLVE(timer_num, bsptimer);
   10408:	2805      	cmp	r0, #5
   1040a:	dc51      	bgt.n	104b0 <hal_timer_config+0xa8>
{
   1040c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    NRF52_HAL_TIMER_RESOLVE(timer_num, bsptimer);
   1040e:	4b2f      	ldr	r3, [pc, #188]	; (104cc <hal_timer_config+0xc4>)
   10410:	f853 5020 	ldr.w	r5, [r3, r0, lsl #2]
   10414:	2d00      	cmp	r5, #0
   10416:	d04d      	beq.n	104b4 <hal_timer_config+0xac>
        return 0;
    }
#endif

    /* Set timer to desired frequency */
    div = NRF52_MAX_TIMER_FREQ / freq_hz;
   10418:	4a2d      	ldr	r2, [pc, #180]	; (104d0 <hal_timer_config+0xc8>)
   1041a:	fbb2 f2f1 	udiv	r2, r2, r1
    /*
     * Largest prescaler is 2^9 and must make sure frequency not too high.
     * If hwtimer is NULL it means that the timer was not initialized prior
     * to call.
     */
    if (bsptimer->tmr_enabled || (div == 0) || (div > 512) ||
   1041e:	782c      	ldrb	r4, [r5, #0]
   10420:	2c00      	cmp	r4, #0
   10422:	d149      	bne.n	104b8 <hal_timer_config+0xb0>
   10424:	4b2a      	ldr	r3, [pc, #168]	; (104d0 <hal_timer_config+0xc8>)
   10426:	4299      	cmp	r1, r3
   10428:	d848      	bhi.n	104bc <hal_timer_config+0xb4>
   1042a:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
   1042e:	d847      	bhi.n	104c0 <hal_timer_config+0xb8>
        (bsptimer->tmr_reg == NULL)) {
   10430:	692b      	ldr	r3, [r5, #16]
    if (bsptimer->tmr_enabled || (div == 0) || (div > 512) ||
   10432:	2b00      	cmp	r3, #0
   10434:	d046      	beq.n	104c4 <hal_timer_config+0xbc>
        rc = EINVAL;
        goto err;
    }

    if (div == 1) {
   10436:	2a01      	cmp	r2, #1
   10438:	d013      	beq.n	10462 <hal_timer_config+0x5a>
        prescaler = 0;
    } else {
        /* Find closest prescaler */
        for (prescaler = 1; prescaler < 10; ++prescaler) {
   1043a:	2401      	movs	r4, #1
   1043c:	2c09      	cmp	r4, #9
   1043e:	d810      	bhi.n	10462 <hal_timer_config+0x5a>
            if (div <= (1 << prescaler)) {
   10440:	2301      	movs	r3, #1
   10442:	40a3      	lsls	r3, r4
   10444:	4293      	cmp	r3, r2
   10446:	d202      	bcs.n	1044e <hal_timer_config+0x46>
        for (prescaler = 1; prescaler < 10; ++prescaler) {
   10448:	3401      	adds	r4, #1
   1044a:	b2e4      	uxtb	r4, r4
   1044c:	e7f6      	b.n	1043c <hal_timer_config+0x34>
                min_delta = div - (1 << (prescaler - 1));
   1044e:	1e61      	subs	r1, r4, #1
   10450:	2001      	movs	r0, #1
   10452:	fa00 f101 	lsl.w	r1, r0, r1
   10456:	1a51      	subs	r1, r2, r1
                max_delta = (1 << prescaler) - div;
   10458:	1a9b      	subs	r3, r3, r2
                if (min_delta < max_delta) {
   1045a:	4299      	cmp	r1, r3
   1045c:	d201      	bcs.n	10462 <hal_timer_config+0x5a>
                    prescaler -= 1;
   1045e:	3c01      	subs	r4, #1
   10460:	b2e4      	uxtb	r4, r4
            }
        }
    }

    /* Now set the actual frequency */
    bsptimer->tmr_freq = NRF52_MAX_TIMER_FREQ / (1 << prescaler);
   10462:	4b1b      	ldr	r3, [pc, #108]	; (104d0 <hal_timer_config+0xc8>)
   10464:	4123      	asrs	r3, r4
   10466:	60eb      	str	r3, [r5, #12]
    bsptimer->tmr_enabled = 1;
   10468:	2601      	movs	r6, #1
   1046a:	702e      	strb	r6, [r5, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
   1046c:	f3ef 8710 	mrs	r7, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
   10470:	b672      	cpsid	i
    /* disable interrupts */
    __HAL_DISABLE_INTERRUPTS(ctx);

#if MYNEWT_VAL_CHOICE(MCU_HFCLK_SOURCE, HFXO)
    /* Make sure HFXO is started */
    nrf52_clock_hfxo_request();
   10472:	f000 f831 	bl	104d8 <nrf52_clock_hfxo_request>
#endif
    hwtimer = bsptimer->tmr_reg;
   10476:	692b      	ldr	r3, [r5, #16]

    /* Stop the timer first */
    hwtimer->TASKS_STOP = 1;
   10478:	605e      	str	r6, [r3, #4]
    hwtimer->TASKS_CLEAR = 1;
   1047a:	60de      	str	r6, [r3, #12]

    /* Put the timer in timer mode using 32 bits. */
    hwtimer->MODE = TIMER_MODE_MODE_Timer;
   1047c:	2200      	movs	r2, #0
   1047e:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    hwtimer->BITMODE = TIMER_BITMODE_BITMODE_32Bit;
   10482:	2203      	movs	r2, #3
   10484:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508

    /* Set the pre-scalar */
    hwtimer->PRESCALER = prescaler;
   10488:	f8c3 4510 	str.w	r4, [r3, #1296]	; 0x510

    /* Start the timer */
    hwtimer->TASKS_START = 1;
   1048c:	601e      	str	r6, [r3, #0]

    NVIC_EnableIRQ(bsptimer->tmr_irq_num);
   1048e:	786a      	ldrb	r2, [r5, #1]
   10490:	f995 3001 	ldrsb.w	r3, [r5, #1]
  if ((int32_t)(IRQn) >= 0)
   10494:	2b00      	cmp	r3, #0
   10496:	db07      	blt.n	104a8 <hal_timer_config+0xa0>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   10498:	f002 021f 	and.w	r2, r2, #31
   1049c:	095b      	lsrs	r3, r3, #5
   1049e:	fa06 f202 	lsl.w	r2, r6, r2
   104a2:	490c      	ldr	r1, [pc, #48]	; (104d4 <hal_timer_config+0xcc>)
   104a4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

    __HAL_ENABLE_INTERRUPTS(ctx);
   104a8:	b977      	cbnz	r7, 104c8 <hal_timer_config+0xc0>
  __ASM volatile ("cpsie i" : : : "memory");
   104aa:	b662      	cpsie	i

    return 0;
   104ac:	2000      	movs	r0, #0
}
   104ae:	e004      	b.n	104ba <hal_timer_config+0xb2>

err:
    return rc;
   104b0:	2016      	movs	r0, #22
}
   104b2:	4770      	bx	lr
    return rc;
   104b4:	2016      	movs	r0, #22
   104b6:	e000      	b.n	104ba <hal_timer_config+0xb2>
   104b8:	2016      	movs	r0, #22
}
   104ba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return rc;
   104bc:	2016      	movs	r0, #22
   104be:	e7fc      	b.n	104ba <hal_timer_config+0xb2>
   104c0:	2016      	movs	r0, #22
   104c2:	e7fa      	b.n	104ba <hal_timer_config+0xb2>
   104c4:	2016      	movs	r0, #22
   104c6:	e7f8      	b.n	104ba <hal_timer_config+0xb2>
    return 0;
   104c8:	2000      	movs	r0, #0
   104ca:	e7f6      	b.n	104ba <hal_timer_config+0xb2>
   104cc:	00011b84 	.word	0x00011b84
   104d0:	00f42400 	.word	0x00f42400
   104d4:	e000e100 	.word	0xe000e100

000104d8 <nrf52_clock_hfxo_request>:
 *
 * @return int 0: hfxo was already on. 1: hfxo was turned on.
 */
int
nrf52_clock_hfxo_request(void)
{
   104d8:	b508      	push	{r3, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
   104da:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
   104de:	b672      	cpsid	i
    assert(0);
#endif

    started = 0;
    __HAL_DISABLE_INTERRUPTS(ctx);
    assert(nrf52_clock_hfxo_refcnt < 0xff);
   104e0:	4b18      	ldr	r3, [pc, #96]	; (10544 <nrf52_clock_hfxo_request+0x6c>)
   104e2:	781b      	ldrb	r3, [r3, #0]
   104e4:	2bff      	cmp	r3, #255	; 0xff
   104e6:	d018      	beq.n	1051a <nrf52_clock_hfxo_request+0x42>
    if (nrf52_clock_hfxo_refcnt == 0) {
   104e8:	bb0b      	cbnz	r3, 1052e <nrf52_clock_hfxo_request+0x56>
        /* Check the current STATE and SRC of HFCLK */
        if ((NRF_CLOCK->HFCLKSTAT &
   104ea:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   104ee:	f8d3 340c 	ldr.w	r3, [r3, #1036]	; 0x40c
   104f2:	f003 1301 	and.w	r3, r3, #65537	; 0x10001
   104f6:	f1b3 1f01 	cmp.w	r3, #65537	; 0x10001
   104fa:	d020      	beq.n	1053e <nrf52_clock_hfxo_request+0x66>
             (CLOCK_HFCLKSTAT_SRC_Msk | CLOCK_HFCLKSTAT_STATE_Msk)) !=
            (CLOCK_HFCLKSTAT_SRC_Xtal << CLOCK_HFCLKSTAT_SRC_Pos |
             CLOCK_HFCLKSTAT_STATE_Running << CLOCK_HFCLKSTAT_STATE_Pos)) {
            NRF_CLOCK->EVENTS_HFCLKSTARTED = 0;
   104fc:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   10500:	2200      	movs	r2, #0
   10502:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
            NRF_CLOCK->TASKS_HFCLKSTART = 1;
   10506:	2201      	movs	r2, #1
   10508:	601a      	str	r2, [r3, #0]
            while (!NRF_CLOCK->EVENTS_HFCLKSTARTED) {
   1050a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   1050e:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
   10512:	2b00      	cmp	r3, #0
   10514:	d0f9      	beq.n	1050a <nrf52_clock_hfxo_request+0x32>
            }
        }
        started = 1;
   10516:	2001      	movs	r0, #1
   10518:	e00a      	b.n	10530 <nrf52_clock_hfxo_request+0x58>
    assert(nrf52_clock_hfxo_refcnt < 0xff);
   1051a:	f7fb fe3f 	bl	c19c <hal_debugger_connected>
   1051e:	b100      	cbz	r0, 10522 <nrf52_clock_hfxo_request+0x4a>
   10520:	be01      	bkpt	0x0001
   10522:	2300      	movs	r3, #0
   10524:	461a      	mov	r2, r3
   10526:	4619      	mov	r1, r3
   10528:	4618      	mov	r0, r3
   1052a:	f7fc f815 	bl	c558 <__assert_func>
    started = 0;
   1052e:	2000      	movs	r0, #0
    }
    ++nrf52_clock_hfxo_refcnt;
   10530:	4a04      	ldr	r2, [pc, #16]	; (10544 <nrf52_clock_hfxo_request+0x6c>)
   10532:	7813      	ldrb	r3, [r2, #0]
   10534:	3301      	adds	r3, #1
   10536:	7013      	strb	r3, [r2, #0]
    __HAL_ENABLE_INTERRUPTS(ctx);
   10538:	b901      	cbnz	r1, 1053c <nrf52_clock_hfxo_request+0x64>
  __ASM volatile ("cpsie i" : : : "memory");
   1053a:	b662      	cpsie	i

    return started;
}
   1053c:	bd08      	pop	{r3, pc}
        started = 1;
   1053e:	2001      	movs	r0, #1
   10540:	e7f6      	b.n	10530 <nrf52_clock_hfxo_request+0x58>
   10542:	bf00      	nop
   10544:	200023d8 	.word	0x200023d8

00010548 <os_cputime_init>:
struct os_cputime_data g_os_cputime;
#endif

int
os_cputime_init(uint32_t clock_freq)
{
   10548:	b508      	push	{r3, lr}
   1054a:	4601      	mov	r1, r0

    /* Set the ticks per microsecond. */
#if defined(OS_CPUTIME_FREQ_HIGH)
    g_os_cputime.ticks_per_usec = clock_freq / 1000000U;
#endif
    rc = hal_timer_config(MYNEWT_VAL(OS_CPUTIME_TIMER_NUM), clock_freq);
   1054c:	2000      	movs	r0, #0
   1054e:	f7ff ff5b 	bl	10408 <hal_timer_config>
    return rc;
}
   10552:	bd08      	pop	{r3, pc}

00010554 <os_sem_init>:
{
    os_error_t ret;

    os_trace_api_u32x2(OS_TRACE_ID_SEM_INIT, (uint32_t)sem, (uint32_t)tokens);

    if (!sem) {
   10554:	4603      	mov	r3, r0
   10556:	b118      	cbz	r0, 10560 <os_sem_init+0xc>
        ret = OS_INVALID_PARM;
        goto done;
    }

    sem->sem_tokens = tokens;
   10558:	80c1      	strh	r1, [r0, #6]
    SLIST_FIRST(&sem->sem_head) = NULL;
   1055a:	2000      	movs	r0, #0
   1055c:	6018      	str	r0, [r3, #0]

    ret = OS_OK;
   1055e:	4770      	bx	lr
        ret = OS_INVALID_PARM;
   10560:	2003      	movs	r0, #3

done:
    os_trace_api_ret_u32(OS_TRACE_ID_SEM_INIT, (uint32_t)ret);
    return ret;
}
   10562:	4770      	bx	lr

00010564 <os_sem_release>:

os_error_t
os_sem_release(struct os_sem *sem)
{
   10564:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    os_error_t ret;

    os_trace_api_u32(OS_TRACE_ID_SEM_RELEASE, (uint32_t)sem);

    /* OS must be started to release semaphores */
    if (!g_os_started) {
   10566:	4b17      	ldr	r3, [pc, #92]	; (105c4 <os_sem_release+0x60>)
   10568:	681b      	ldr	r3, [r3, #0]
   1056a:	b33b      	cbz	r3, 105bc <os_sem_release+0x58>
   1056c:	4604      	mov	r4, r0
        ret = OS_NOT_STARTED;
        goto done;
    }

    /* Check for valid semaphore */
    if (!sem) {
   1056e:	b338      	cbz	r0, 105c0 <os_sem_release+0x5c>
        goto done;
    }

    /* Get current task */
    resched = 0;
    current = os_sched_get_current_task();
   10570:	f7fc fd7a 	bl	d068 <os_sched_get_current_task>
   10574:	4607      	mov	r7, r0

    OS_ENTER_CRITICAL(sr);
   10576:	f7fc ffa7 	bl	d4c8 <os_arch_save_sr>
   1057a:	4606      	mov	r6, r0

    /* Check if tasks are waiting for the semaphore */
    rdy = SLIST_FIRST(&sem->sem_head);
   1057c:	6825      	ldr	r5, [r4, #0]
    if (rdy) {
   1057e:	b165      	cbz	r5, 1059a <os_sem_release+0x36>
        /* Clear flag that we are waiting on the semaphore; wake up task */
        rdy->t_flags &= ~OS_TASK_FLAG_SEM_WAIT;
   10580:	7b6b      	ldrb	r3, [r5, #13]
   10582:	f023 0302 	bic.w	r3, r3, #2
   10586:	736b      	strb	r3, [r5, #13]
        os_sched_wakeup(rdy);
   10588:	4628      	mov	r0, r5
   1058a:	f7fc fdc1 	bl	d110 <os_sched_wakeup>
         * switch may already started, in that case start next
         * context switch. In worst case scenario second task
         * switch interrupt will check that there is no need
         * for switching.
         */
        if (current->t_prio >= rdy->t_prio) {
   1058e:	7afa      	ldrb	r2, [r7, #11]
   10590:	7aeb      	ldrb	r3, [r5, #11]
   10592:	429a      	cmp	r2, r3
   10594:	d20b      	bcs.n	105ae <os_sem_release+0x4a>
    resched = 0;
   10596:	2400      	movs	r4, #0
   10598:	e003      	b.n	105a2 <os_sem_release+0x3e>
            resched = 1;
        }
    } else {
        /* Add to the number of tokens */
        sem->sem_tokens++;
   1059a:	88e3      	ldrh	r3, [r4, #6]
   1059c:	3301      	adds	r3, #1
   1059e:	80e3      	strh	r3, [r4, #6]
    resched = 0;
   105a0:	2400      	movs	r4, #0
    }

    OS_EXIT_CRITICAL(sr);
   105a2:	4630      	mov	r0, r6
   105a4:	f7fc ff96 	bl	d4d4 <os_arch_restore_sr>

    /* Re-schedule if needed */
    if (resched) {
   105a8:	b91c      	cbnz	r4, 105b2 <os_sem_release+0x4e>
        os_sched(rdy);
    }

    ret = OS_OK;
   105aa:	2000      	movs	r0, #0

done:
    os_trace_api_ret_u32(OS_TRACE_ID_SEM_RELEASE, (uint32_t)ret);
    return ret;
}
   105ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            resched = 1;
   105ae:	2401      	movs	r4, #1
   105b0:	e7f7      	b.n	105a2 <os_sem_release+0x3e>
        os_sched(rdy);
   105b2:	4628      	mov	r0, r5
   105b4:	f7fc fe38 	bl	d228 <os_sched>
    ret = OS_OK;
   105b8:	2000      	movs	r0, #0
   105ba:	e7f7      	b.n	105ac <os_sem_release+0x48>
        ret = OS_NOT_STARTED;
   105bc:	2009      	movs	r0, #9
   105be:	e7f5      	b.n	105ac <os_sem_release+0x48>
        ret = OS_INVALID_PARM;
   105c0:	2003      	movs	r0, #3
   105c2:	e7f3      	b.n	105ac <os_sem_release+0x48>
   105c4:	20001320 	.word	0x20001320

000105c8 <os_sem_pend>:

os_error_t
os_sem_pend(struct os_sem *sem, os_time_t timeout)
{
   105c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    os_error_t ret;

    os_trace_api_u32x2(OS_TRACE_ID_SEM_PEND, (uint32_t)sem, (uint32_t)timeout);

    /* Check if OS is started */
    if (!g_os_started) {
   105ca:	4b2b      	ldr	r3, [pc, #172]	; (10678 <os_sem_pend+0xb0>)
   105cc:	681b      	ldr	r3, [r3, #0]
   105ce:	2b00      	cmp	r3, #0
   105d0:	d04d      	beq.n	1066e <os_sem_pend+0xa6>
   105d2:	4604      	mov	r4, r0
   105d4:	460f      	mov	r7, r1
        ret = OS_NOT_STARTED;
        goto done;
    }

    /* Check for valid semaphore */
    if (!sem) {
   105d6:	2800      	cmp	r0, #0
   105d8:	d04b      	beq.n	10672 <os_sem_pend+0xaa>
        goto done;
    }

    /* Assume we dont have to put task to sleep; get current task */
    sched = 0;
    current = os_sched_get_current_task();
   105da:	f7fc fd45 	bl	d068 <os_sched_get_current_task>
   105de:	4605      	mov	r5, r0

    OS_ENTER_CRITICAL(sr);
   105e0:	f7fc ff72 	bl	d4c8 <os_arch_save_sr>
   105e4:	4606      	mov	r6, r0

    /*
     * If there is a token available, take it. If no token, either return
     * with error if timeout was 0 or put this task to sleep.
     */
    if (sem->sem_tokens != 0) {
   105e6:	88e3      	ldrh	r3, [r4, #6]
   105e8:	b14b      	cbz	r3, 105fe <os_sem_pend+0x36>
        sem->sem_tokens--;
   105ea:	3b01      	subs	r3, #1
   105ec:	80e3      	strh	r3, [r4, #6]
        ret = OS_OK;
   105ee:	2400      	movs	r4, #0
    sched = 0;
   105f0:	4627      	mov	r7, r4
        /* We will put this task to sleep */
        sched = 1;
        os_sched_sleep(current, timeout);
    }

    OS_EXIT_CRITICAL(sr);
   105f2:	4630      	mov	r0, r6
   105f4:	f7fc ff6e 	bl	d4d4 <os_arch_restore_sr>

    if (sched) {
   105f8:	bb47      	cbnz	r7, 1064c <os_sem_pend+0x84>
    }

done:
    os_trace_api_ret_u32(OS_TRACE_ID_SEM_PEND, (uint32_t)ret);
    return ret;
}
   105fa:	4620      	mov	r0, r4
   105fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    } else if (timeout == 0) {
   105fe:	b317      	cbz	r7, 10646 <os_sem_pend+0x7e>
        current->t_obj = sem;
   10600:	61ec      	str	r4, [r5, #28]
        current->t_flags |= OS_TASK_FLAG_SEM_WAIT;
   10602:	7b6b      	ldrb	r3, [r5, #13]
   10604:	f043 0302 	orr.w	r3, r3, #2
   10608:	736b      	strb	r3, [r5, #13]
        if (!SLIST_EMPTY(&sem->sem_head)) {
   1060a:	f8d4 c000 	ldr.w	ip, [r4]
   1060e:	f1bc 0f00 	cmp.w	ip, #0
   10612:	d00e      	beq.n	10632 <os_sem_pend+0x6a>
            SLIST_FOREACH(entry, &sem->sem_head, t_obj_list) {
   10614:	4663      	mov	r3, ip
        last = NULL;
   10616:	2000      	movs	r0, #0
            SLIST_FOREACH(entry, &sem->sem_head, t_obj_list) {
   10618:	b133      	cbz	r3, 10628 <os_sem_pend+0x60>
                if (current->t_prio < entry->t_prio) {
   1061a:	7ae9      	ldrb	r1, [r5, #11]
   1061c:	7ada      	ldrb	r2, [r3, #11]
   1061e:	4291      	cmp	r1, r2
   10620:	d302      	bcc.n	10628 <os_sem_pend+0x60>
                last = entry;
   10622:	4618      	mov	r0, r3
            SLIST_FOREACH(entry, &sem->sem_head, t_obj_list) {
   10624:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
   10626:	e7f7      	b.n	10618 <os_sem_pend+0x50>
        if (last) {
   10628:	b118      	cbz	r0, 10632 <os_sem_pend+0x6a>
            SLIST_INSERT_AFTER(last, current, t_obj_list);
   1062a:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
   1062c:	64eb      	str	r3, [r5, #76]	; 0x4c
   1062e:	64c5      	str	r5, [r0, #76]	; 0x4c
   10630:	e002      	b.n	10638 <os_sem_pend+0x70>
            SLIST_INSERT_HEAD(&sem->sem_head, current, t_obj_list);
   10632:	f8c5 c04c 	str.w	ip, [r5, #76]	; 0x4c
   10636:	6025      	str	r5, [r4, #0]
        os_sched_sleep(current, timeout);
   10638:	4639      	mov	r1, r7
   1063a:	4628      	mov	r0, r5
   1063c:	f7fc fd20 	bl	d080 <os_sched_sleep>
        ret = OS_OK;
   10640:	2400      	movs	r4, #0
        sched = 1;
   10642:	2701      	movs	r7, #1
   10644:	e7d5      	b.n	105f2 <os_sem_pend+0x2a>
        ret = OS_TIMEOUT;
   10646:	2406      	movs	r4, #6
    sched = 0;
   10648:	2700      	movs	r7, #0
   1064a:	e7d2      	b.n	105f2 <os_sem_pend+0x2a>
        os_sched(NULL);
   1064c:	2000      	movs	r0, #0
   1064e:	f7fc fdeb 	bl	d228 <os_sched>
        if (current->t_flags & OS_TASK_FLAG_SEM_WAIT) {
   10652:	7b6c      	ldrb	r4, [r5, #13]
   10654:	f014 0402 	ands.w	r4, r4, #2
   10658:	d0cf      	beq.n	105fa <os_sem_pend+0x32>
            OS_ENTER_CRITICAL(sr);
   1065a:	f7fc ff35 	bl	d4c8 <os_arch_save_sr>
            current->t_flags &= ~OS_TASK_FLAG_SEM_WAIT;
   1065e:	7b6b      	ldrb	r3, [r5, #13]
   10660:	f023 0302 	bic.w	r3, r3, #2
   10664:	736b      	strb	r3, [r5, #13]
            OS_EXIT_CRITICAL(sr);
   10666:	f7fc ff35 	bl	d4d4 <os_arch_restore_sr>
            ret = OS_TIMEOUT;
   1066a:	2406      	movs	r4, #6
   1066c:	e7c5      	b.n	105fa <os_sem_pend+0x32>
        ret = OS_NOT_STARTED;
   1066e:	2409      	movs	r4, #9
   10670:	e7c3      	b.n	105fa <os_sem_pend+0x32>
        ret = OS_INVALID_PARM;
   10672:	2403      	movs	r4, #3
   10674:	e7c1      	b.n	105fa <os_sem_pend+0x32>
   10676:	bf00      	nop
   10678:	20001320 	.word	0x20001320

0001067c <malloc_lock_nop>:
    },
    &__malloc_head,
    &__malloc_head
};

static bool malloc_lock_nop() {return true;}
   1067c:	2001      	movs	r0, #1
   1067e:	4770      	bx	lr

00010680 <malloc_unlock_nop>:
static void malloc_unlock_nop() {}
   10680:	4770      	bx	lr

00010682 <__malloc_from_block>:
static void *__malloc_from_block(struct free_arena_header *fp, size_t size)
{
    size_t fsize;
    struct free_arena_header *nfp, *na, *fpn, *fpp;

    fsize = fp->a.size;
   10682:	6842      	ldr	r2, [r0, #4]

    /* We need the 2* to account for the larger requirements of a
       free block */
    if (fsize >= size + 2 * sizeof(struct arena_header)) {
   10684:	f101 0320 	add.w	r3, r1, #32
   10688:	4293      	cmp	r3, r2
   1068a:	d816      	bhi.n	106ba <__malloc_from_block+0x38>
{
   1068c:	b430      	push	{r4, r5}
        /* Bigger block than required -- split block */
        nfp = (struct free_arena_header *)((char *)fp + size);
   1068e:	1843      	adds	r3, r0, r1
        na = fp->a.next;
   10690:	6884      	ldr	r4, [r0, #8]

        nfp->a.type = ARENA_TYPE_FREE;
   10692:	2501      	movs	r5, #1
   10694:	5045      	str	r5, [r0, r1]
        nfp->a.size = fsize - size;
   10696:	1a52      	subs	r2, r2, r1
   10698:	605a      	str	r2, [r3, #4]
        fp->a.type = ARENA_TYPE_USED;
   1069a:	2200      	movs	r2, #0
   1069c:	6002      	str	r2, [r0, #0]
        fp->a.size = size;
   1069e:	6041      	str	r1, [r0, #4]

        /* Insert into all-block chain */
        nfp->a.prev = fp;
   106a0:	60d8      	str	r0, [r3, #12]
        nfp->a.next = na;
   106a2:	609c      	str	r4, [r3, #8]
        na->a.prev = nfp;
   106a4:	60e3      	str	r3, [r4, #12]
        fp->a.next = nfp;
   106a6:	6083      	str	r3, [r0, #8]

        /* Replace current block on free chain */
        nfp->next_free = fpn = fp->next_free;
   106a8:	6901      	ldr	r1, [r0, #16]
   106aa:	6119      	str	r1, [r3, #16]
        nfp->prev_free = fpp = fp->prev_free;
   106ac:	6942      	ldr	r2, [r0, #20]
   106ae:	615a      	str	r2, [r3, #20]
        fpn->prev_free = nfp;
   106b0:	614b      	str	r3, [r1, #20]
        fpp->next_free = nfp;
   106b2:	6113      	str	r3, [r2, #16]
        fp->a.type = ARENA_TYPE_USED; /* Allocate the whole block */
        remove_from_free_chain(fp);
    }

    return (void *)(&fp->a + 1);
}
   106b4:	3010      	adds	r0, #16
   106b6:	bc30      	pop	{r4, r5}
   106b8:	4770      	bx	lr
        fp->a.type = ARENA_TYPE_USED; /* Allocate the whole block */
   106ba:	2300      	movs	r3, #0
   106bc:	6003      	str	r3, [r0, #0]
    ap = ah->prev_free;
   106be:	6942      	ldr	r2, [r0, #20]
    an = ah->next_free;
   106c0:	6903      	ldr	r3, [r0, #16]
    ap->next_free = an;
   106c2:	6113      	str	r3, [r2, #16]
    an->prev_free = ap;
   106c4:	615a      	str	r2, [r3, #20]
}
   106c6:	3010      	adds	r0, #16
   106c8:	4770      	bx	lr
	...

000106cc <__free_block>:

static struct free_arena_header *__free_block(struct free_arena_header *ah)
{
   106cc:	b410      	push	{r4}
   106ce:	4603      	mov	r3, r0
    struct free_arena_header *pah, *nah;

    pah = ah->a.prev;
   106d0:	68c0      	ldr	r0, [r0, #12]
    nah = ah->a.next;
   106d2:	6899      	ldr	r1, [r3, #8]
    if (pah->a.type == ARENA_TYPE_FREE &&
   106d4:	6802      	ldr	r2, [r0, #0]
   106d6:	2a01      	cmp	r2, #1
   106d8:	d00e      	beq.n	106f8 <__free_block+0x2c>

        ah = pah;
        pah = ah->a.prev;
    } else {
        /* Need to add this block to the free chain */
        ah->a.type = ARENA_TYPE_FREE;
   106da:	2201      	movs	r2, #1
   106dc:	601a      	str	r2, [r3, #0]

        ah->next_free = __malloc_head.next_free;
   106de:	4a13      	ldr	r2, [pc, #76]	; (1072c <__free_block+0x60>)
   106e0:	6910      	ldr	r0, [r2, #16]
   106e2:	6118      	str	r0, [r3, #16]
        ah->prev_free = &__malloc_head;
   106e4:	615a      	str	r2, [r3, #20]
        __malloc_head.next_free = ah;
   106e6:	6113      	str	r3, [r2, #16]
        ah->next_free->prev_free = ah;
   106e8:	691a      	ldr	r2, [r3, #16]
   106ea:	6153      	str	r3, [r2, #20]
   106ec:	4618      	mov	r0, r3
    }

    /* In either of the previous cases, we might be able to merge
       with the subsequent block... */
    if (nah->a.type == ARENA_TYPE_FREE &&
   106ee:	680b      	ldr	r3, [r1, #0]
   106f0:	2b01      	cmp	r3, #1
   106f2:	d00b      	beq.n	1070c <__free_block+0x40>
        remove_from_chains(nah);
    }

    /* Return the block that contains the called block */
    return ah;
}
   106f4:	bc10      	pop	{r4}
   106f6:	4770      	bx	lr
        (char *)pah + pah->a.size == (char *)ah) {
   106f8:	6842      	ldr	r2, [r0, #4]
   106fa:	1884      	adds	r4, r0, r2
    if (pah->a.type == ARENA_TYPE_FREE &&
   106fc:	429c      	cmp	r4, r3
   106fe:	d1ec      	bne.n	106da <__free_block+0xe>
        pah->a.size += ah->a.size;
   10700:	685b      	ldr	r3, [r3, #4]
   10702:	441a      	add	r2, r3
   10704:	6042      	str	r2, [r0, #4]
        pah->a.next = nah;
   10706:	6081      	str	r1, [r0, #8]
        nah->a.prev = pah;
   10708:	60c8      	str	r0, [r1, #12]
        pah = ah->a.prev;
   1070a:	e7f0      	b.n	106ee <__free_block+0x22>
        (char *)ah + ah->a.size == (char *)nah) {
   1070c:	6843      	ldr	r3, [r0, #4]
   1070e:	18c2      	adds	r2, r0, r3
    if (nah->a.type == ARENA_TYPE_FREE &&
   10710:	428a      	cmp	r2, r1
   10712:	d1ef      	bne.n	106f4 <__free_block+0x28>
        ah->a.size += nah->a.size;
   10714:	684a      	ldr	r2, [r1, #4]
   10716:	4413      	add	r3, r2
   10718:	6043      	str	r3, [r0, #4]
    ap = ah->prev_free;
   1071a:	694a      	ldr	r2, [r1, #20]
    an = ah->next_free;
   1071c:	690b      	ldr	r3, [r1, #16]
    ap->next_free = an;
   1071e:	6113      	str	r3, [r2, #16]
    an->prev_free = ap;
   10720:	615a      	str	r2, [r3, #20]
    ap = ah->a.prev;
   10722:	68ca      	ldr	r2, [r1, #12]
    an = ah->a.next;
   10724:	688b      	ldr	r3, [r1, #8]
    ap->a.next = an;
   10726:	6093      	str	r3, [r2, #8]
    an->a.prev = ap;
   10728:	60da      	str	r2, [r3, #12]
    return ah;
   1072a:	e7e3      	b.n	106f4 <__free_block+0x28>
   1072c:	20000134 	.word	0x20000134

00010730 <add_malloc_block>:
void add_malloc_block(void *buf, size_t size)
{
    struct free_arena_header *fp = buf;
    struct free_arena_header *pah;

    if (size < sizeof(struct free_arena_header))
   10730:	2917      	cmp	r1, #23
   10732:	d91e      	bls.n	10772 <add_malloc_block+0x42>
{
   10734:	b510      	push	{r4, lr}
   10736:	4604      	mov	r4, r0
        return; // Too small.

    /* Insert the block into the management chains.  We need to set
       up the size and the main block list pointer, the rest of
       the work is logically identical to free(). */
    fp->a.type = ARENA_TYPE_FREE;
   10738:	2301      	movs	r3, #1
   1073a:	6003      	str	r3, [r0, #0]
    fp->a.size = size;
   1073c:	6041      	str	r1, [r0, #4]

    if (!malloc_lock())
   1073e:	4b0d      	ldr	r3, [pc, #52]	; (10774 <add_malloc_block+0x44>)
   10740:	681b      	ldr	r3, [r3, #0]
   10742:	4798      	blx	r3
   10744:	b1a0      	cbz	r0, 10770 <add_malloc_block+0x40>

    /* We need to insert this into the main block list in the proper
       place -- this list is required to be sorted.  Since we most likely
       get memory assignments in ascending order, search backwards for
       the proper place. */
    for (pah = __malloc_head.a.prev; pah->a.type != ARENA_TYPE_HEAD;
   10746:	4b0c      	ldr	r3, [pc, #48]	; (10778 <add_malloc_block+0x48>)
   10748:	68db      	ldr	r3, [r3, #12]
   1074a:	681a      	ldr	r2, [r3, #0]
   1074c:	2a02      	cmp	r2, #2
   1074e:	d003      	beq.n	10758 <add_malloc_block+0x28>
         pah = pah->a.prev) {
        if (pah < fp)
   10750:	42a3      	cmp	r3, r4
   10752:	d301      	bcc.n	10758 <add_malloc_block+0x28>
         pah = pah->a.prev) {
   10754:	68db      	ldr	r3, [r3, #12]
   10756:	e7f8      	b.n	1074a <add_malloc_block+0x1a>
            break;
    }

    /* Now pah points to the node that should be the predecessor of
       the new node */
    fp->a.next = pah->a.next;
   10758:	689a      	ldr	r2, [r3, #8]
   1075a:	60a2      	str	r2, [r4, #8]
    fp->a.prev = pah;
   1075c:	60e3      	str	r3, [r4, #12]
    pah->a.next = fp;
   1075e:	609c      	str	r4, [r3, #8]
    fp->a.next->a.prev = fp;
   10760:	68a3      	ldr	r3, [r4, #8]
   10762:	60dc      	str	r4, [r3, #12]

    /* Insert into the free chain and coalesce with adjacent blocks */
    fp = __free_block(fp);
   10764:	4620      	mov	r0, r4
   10766:	f7ff ffb1 	bl	106cc <__free_block>

    malloc_unlock();
   1076a:	4b04      	ldr	r3, [pc, #16]	; (1077c <add_malloc_block+0x4c>)
   1076c:	681b      	ldr	r3, [r3, #0]
   1076e:	4798      	blx	r3
}
   10770:	bd10      	pop	{r4, pc}
   10772:	4770      	bx	lr
   10774:	2000014c 	.word	0x2000014c
   10778:	20000134 	.word	0x20000134
   1077c:	20000150 	.word	0x20000150

00010780 <malloc>:
{
   10780:	b538      	push	{r3, r4, r5, lr}
    if (size == 0 || size > (SIZE_MAX - sizeof(struct arena_header))) {
   10782:	1e43      	subs	r3, r0, #1
   10784:	f113 0f12 	cmn.w	r3, #18
   10788:	d825      	bhi.n	107d6 <malloc+0x56>
    size = (size + 2 * sizeof(struct arena_header) - 1) & ARENA_SIZE_MASK;
   1078a:	301f      	adds	r0, #31
   1078c:	f020 040f 	bic.w	r4, r0, #15
    if (!malloc_lock())
   10790:	4b13      	ldr	r3, [pc, #76]	; (107e0 <malloc+0x60>)
   10792:	681b      	ldr	r3, [r3, #0]
   10794:	4798      	blx	r3
   10796:	b300      	cbz	r0, 107da <malloc+0x5a>
    void *result = NULL;
   10798:	2500      	movs	r5, #0
   1079a:	e00d      	b.n	107b8 <malloc+0x38>
            result = __malloc_from_block(fp, size);
   1079c:	4621      	mov	r1, r4
   1079e:	f7ff ff70 	bl	10682 <__malloc_from_block>
   107a2:	4605      	mov	r5, r0
    if (result == NULL) {
   107a4:	b995      	cbnz	r5, 107cc <malloc+0x4c>
        more_mem = _sbrk(size);
   107a6:	4620      	mov	r0, r4
   107a8:	f7fb feba 	bl	c520 <_sbrk>
        if (more_mem != (void *)-1) {
   107ac:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
   107b0:	d00c      	beq.n	107cc <malloc+0x4c>
            add_malloc_block(more_mem, size);
   107b2:	4621      	mov	r1, r4
   107b4:	f7ff ffbc 	bl	10730 <add_malloc_block>
    for (fp = __malloc_head.next_free; fp->a.type != ARENA_TYPE_HEAD;
   107b8:	4b0a      	ldr	r3, [pc, #40]	; (107e4 <malloc+0x64>)
   107ba:	6918      	ldr	r0, [r3, #16]
   107bc:	6803      	ldr	r3, [r0, #0]
   107be:	2b02      	cmp	r3, #2
   107c0:	d0f0      	beq.n	107a4 <malloc+0x24>
        if (fp->a.size >= size) {
   107c2:	6843      	ldr	r3, [r0, #4]
   107c4:	42a3      	cmp	r3, r4
   107c6:	d2e9      	bcs.n	1079c <malloc+0x1c>
         fp = fp->next_free) {
   107c8:	6900      	ldr	r0, [r0, #16]
   107ca:	e7f7      	b.n	107bc <malloc+0x3c>
    malloc_unlock();
   107cc:	4b06      	ldr	r3, [pc, #24]	; (107e8 <malloc+0x68>)
   107ce:	681b      	ldr	r3, [r3, #0]
   107d0:	4798      	blx	r3
}
   107d2:	4628      	mov	r0, r5
   107d4:	bd38      	pop	{r3, r4, r5, pc}
        return NULL;
   107d6:	2500      	movs	r5, #0
   107d8:	e7fb      	b.n	107d2 <malloc+0x52>
        return NULL;
   107da:	2500      	movs	r5, #0
   107dc:	e7f9      	b.n	107d2 <malloc+0x52>
   107de:	bf00      	nop
   107e0:	2000014c 	.word	0x2000014c
   107e4:	20000134 	.word	0x20000134
   107e8:	20000150 	.word	0x20000150

000107ec <free>:

void free(void *ptr)
{
    struct free_arena_header *ah;

    if (!ptr)
   107ec:	b170      	cbz	r0, 1080c <free+0x20>
{
   107ee:	b510      	push	{r4, lr}
        return;

    ah = (struct free_arena_header *)
   107f0:	f1a0 0410 	sub.w	r4, r0, #16

#ifdef DEBUG_MALLOC
    assert(ah->a.type == ARENA_TYPE_USED);
#endif

    if (!malloc_lock())
   107f4:	4b06      	ldr	r3, [pc, #24]	; (10810 <free+0x24>)
   107f6:	681b      	ldr	r3, [r3, #0]
   107f8:	4798      	blx	r3
   107fa:	b900      	cbnz	r0, 107fe <free+0x12>
        return;

    /* Merge into adjacent free blocks */
    ah = __free_block(ah);
    malloc_unlock();
}
   107fc:	bd10      	pop	{r4, pc}
    ah = __free_block(ah);
   107fe:	4620      	mov	r0, r4
   10800:	f7ff ff64 	bl	106cc <__free_block>
    malloc_unlock();
   10804:	4b03      	ldr	r3, [pc, #12]	; (10814 <free+0x28>)
   10806:	681b      	ldr	r3, [r3, #0]
   10808:	4798      	blx	r3
   1080a:	e7f7      	b.n	107fc <free+0x10>
   1080c:	4770      	bx	lr
   1080e:	bf00      	nop
   10810:	2000014c 	.word	0x2000014c
   10814:	20000150 	.word	0x20000150

00010818 <stdin_read>:

static size_t
stdin_read(FILE *fp, char *bp, size_t n)
{
    return 0;
}
   10818:	2000      	movs	r0, #0
   1081a:	4770      	bx	lr

0001081c <stdout_write>:

static size_t
stdout_write(FILE *fp, const char *bp, size_t n)
{
   1081c:	b510      	push	{r4, lr}
   1081e:	4608      	mov	r0, r1
   10820:	4614      	mov	r4, r2
    console_write(bp, n);
   10822:	4611      	mov	r1, r2
   10824:	f7fd fb60 	bl	dee8 <console_write>
    return n;
}
   10828:	4620      	mov	r0, r4
   1082a:	bd10      	pop	{r4, pc}

0001082c <ui2a>:
    char base;  /**<  number base (e.g.: 8, 10, 16) */
    char *bf;           /**<  Buffer to output */
};

static void ui2a(unsigned long long int num, struct param *p)
{
   1082c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10830:	b087      	sub	sp, #28
   10832:	4604      	mov	r4, r0
   10834:	4692      	mov	sl, r2
    int n = 0;
    unsigned long long int d = 1;
    char *bf = p->bf;
   10836:	6853      	ldr	r3, [r2, #4]
   10838:	9304      	str	r3, [sp, #16]

    if (p->hh == 1) {
   1083a:	7893      	ldrb	r3, [r2, #2]
   1083c:	f003 0330 	and.w	r3, r3, #48	; 0x30
   10840:	2b10      	cmp	r3, #16
   10842:	d018      	beq.n	10876 <ui2a+0x4a>
   10844:	460d      	mov	r5, r1
        num = (unsigned short int)num;
    } else if (p->hh == 2) {
   10846:	2b20      	cmp	r3, #32
   10848:	d019      	beq.n	1087e <ui2a+0x52>
{
   1084a:	2601      	movs	r6, #1
   1084c:	2700      	movs	r7, #0
        num = (unsigned char)num;
    }

    while (num / d >= p->base)
   1084e:	4632      	mov	r2, r6
   10850:	463b      	mov	r3, r7
   10852:	4620      	mov	r0, r4
   10854:	4629      	mov	r1, r5
   10856:	f000 fe69 	bl	1152c <__aeabi_uldivmod>
   1085a:	f89a 8003 	ldrb.w	r8, [sl, #3]
   1085e:	f04f 0900 	mov.w	r9, #0
   10862:	4549      	cmp	r1, r9
   10864:	bf08      	it	eq
   10866:	4540      	cmpeq	r0, r8
   10868:	d30e      	bcc.n	10888 <ui2a+0x5c>
        d *= p->base;
   1086a:	fb08 f307 	mul.w	r3, r8, r7
   1086e:	fba6 6708 	umull	r6, r7, r6, r8
   10872:	441f      	add	r7, r3
   10874:	e7eb      	b.n	1084e <ui2a+0x22>
        num = (unsigned short int)num;
   10876:	b283      	uxth	r3, r0
   10878:	461c      	mov	r4, r3
   1087a:	2500      	movs	r5, #0
   1087c:	e7e5      	b.n	1084a <ui2a+0x1e>
        num = (unsigned char)num;
   1087e:	f000 03ff 	and.w	r3, r0, #255	; 0xff
   10882:	461c      	mov	r4, r3
   10884:	2500      	movs	r5, #0
   10886:	e7e0      	b.n	1084a <ui2a+0x1e>
    int n = 0;
   10888:	f04f 0b00 	mov.w	fp, #0
   1088c:	f8cd a014 	str.w	sl, [sp, #20]
   10890:	e00c      	b.n	108ac <ui2a+0x80>
    while (d != 0) {
        unsigned long long  dgt = num / d;
        num %= d;
        d /= p->base;
        if (n || dgt > 0 || d == 0) {
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
   10892:	2230      	movs	r2, #48	; 0x30
   10894:	9b04      	ldr	r3, [sp, #16]
   10896:	9c00      	ldr	r4, [sp, #0]
   10898:	4414      	add	r4, r2
   1089a:	f803 4b01 	strb.w	r4, [r3], #1
            ++n;
   1089e:	f10b 0b01 	add.w	fp, fp, #1
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
   108a2:	9304      	str	r3, [sp, #16]
   108a4:	4606      	mov	r6, r0
   108a6:	460f      	mov	r7, r1
   108a8:	9c02      	ldr	r4, [sp, #8]
   108aa:	9d03      	ldr	r5, [sp, #12]
    while (d != 0) {
   108ac:	ea56 0307 	orrs.w	r3, r6, r7
   108b0:	d034      	beq.n	1091c <ui2a+0xf0>
        unsigned long long  dgt = num / d;
   108b2:	4632      	mov	r2, r6
   108b4:	463b      	mov	r3, r7
   108b6:	4620      	mov	r0, r4
   108b8:	4629      	mov	r1, r5
   108ba:	f000 fe37 	bl	1152c <__aeabi_uldivmod>
   108be:	9000      	str	r0, [sp, #0]
   108c0:	9101      	str	r1, [sp, #4]
        num %= d;
   108c2:	4632      	mov	r2, r6
   108c4:	463b      	mov	r3, r7
   108c6:	4620      	mov	r0, r4
   108c8:	4629      	mov	r1, r5
   108ca:	f000 fe2f 	bl	1152c <__aeabi_uldivmod>
   108ce:	9202      	str	r2, [sp, #8]
   108d0:	9303      	str	r3, [sp, #12]
        d /= p->base;
   108d2:	9b05      	ldr	r3, [sp, #20]
   108d4:	f893 8003 	ldrb.w	r8, [r3, #3]
   108d8:	f04f 0900 	mov.w	r9, #0
   108dc:	4642      	mov	r2, r8
   108de:	464b      	mov	r3, r9
   108e0:	4630      	mov	r0, r6
   108e2:	4639      	mov	r1, r7
   108e4:	f000 fe22 	bl	1152c <__aeabi_uldivmod>
        if (n || dgt > 0 || d == 0) {
   108e8:	f1bb 0f00 	cmp.w	fp, #0
   108ec:	d107      	bne.n	108fe <ui2a+0xd2>
   108ee:	42bd      	cmp	r5, r7
   108f0:	bf08      	it	eq
   108f2:	42b4      	cmpeq	r4, r6
   108f4:	d203      	bcs.n	108fe <ui2a+0xd2>
   108f6:	454f      	cmp	r7, r9
   108f8:	bf08      	it	eq
   108fa:	4546      	cmpeq	r6, r8
   108fc:	d2d2      	bcs.n	108a4 <ui2a+0x78>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
   108fe:	e9dd 3400 	ldrd	r3, r4, [sp]
   10902:	2c00      	cmp	r4, #0
   10904:	bf08      	it	eq
   10906:	2b0a      	cmpeq	r3, #10
   10908:	d3c3      	bcc.n	10892 <ui2a+0x66>
   1090a:	9b05      	ldr	r3, [sp, #20]
   1090c:	789b      	ldrb	r3, [r3, #2]
   1090e:	f013 0f04 	tst.w	r3, #4
   10912:	d001      	beq.n	10918 <ui2a+0xec>
   10914:	2237      	movs	r2, #55	; 0x37
   10916:	e7bd      	b.n	10894 <ui2a+0x68>
   10918:	2257      	movs	r2, #87	; 0x57
   1091a:	e7bb      	b.n	10894 <ui2a+0x68>
        }
    }
    *bf = 0;
   1091c:	2300      	movs	r3, #0
   1091e:	9a04      	ldr	r2, [sp, #16]
   10920:	7013      	strb	r3, [r2, #0]
}
   10922:	b007      	add	sp, #28
   10924:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00010928 <i2a>:

static void i2a(long long int num, struct param *p)
{
   10928:	b510      	push	{r4, lr}
   1092a:	4604      	mov	r4, r0
   1092c:	460b      	mov	r3, r1
   1092e:	4620      	mov	r0, r4
   10930:	4619      	mov	r1, r3
    if (num < 0) {
   10932:	2c00      	cmp	r4, #0
   10934:	f173 0300 	sbcs.w	r3, r3, #0
   10938:	db02      	blt.n	10940 <i2a+0x18>
        num = -num;
        p->sign = 1;
    }
    ui2a(num, p);
   1093a:	f7ff ff77 	bl	1082c <ui2a>
}
   1093e:	bd10      	pop	{r4, pc}
        num = -num;
   10940:	4260      	negs	r0, r4
   10942:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
        p->sign = 1;
   10946:	7893      	ldrb	r3, [r2, #2]
   10948:	f043 0301 	orr.w	r3, r3, #1
   1094c:	7093      	strb	r3, [r2, #2]
   1094e:	e7f4      	b.n	1093a <i2a+0x12>

00010950 <a2d>:

static int a2d(char ch)
{
    if (ch >= '0' && ch <= '9')
   10950:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
   10954:	b2db      	uxtb	r3, r3
   10956:	2b09      	cmp	r3, #9
   10958:	d90b      	bls.n	10972 <a2d+0x22>
        return ch - '0';
    else if (ch >= 'a' && ch <= 'f')
   1095a:	f1a0 0361 	sub.w	r3, r0, #97	; 0x61
   1095e:	b2db      	uxtb	r3, r3
   10960:	2b05      	cmp	r3, #5
   10962:	d908      	bls.n	10976 <a2d+0x26>
        return ch - 'a' + 10;
    else if (ch >= 'A' && ch <= 'F')
   10964:	f1a0 0341 	sub.w	r3, r0, #65	; 0x41
   10968:	b2db      	uxtb	r3, r3
   1096a:	2b05      	cmp	r3, #5
   1096c:	d805      	bhi.n	1097a <a2d+0x2a>
        return ch - 'A' + 10;
   1096e:	3837      	subs	r0, #55	; 0x37
   10970:	4770      	bx	lr
        return ch - '0';
   10972:	3830      	subs	r0, #48	; 0x30
   10974:	4770      	bx	lr
        return ch - 'a' + 10;
   10976:	3857      	subs	r0, #87	; 0x57
   10978:	4770      	bx	lr
    else
        return -1;
   1097a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   1097e:	4770      	bx	lr

00010980 <a2i>:

static char a2i(char ch, const char **src, int base, unsigned char *nump)
{
   10980:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   10984:	4605      	mov	r5, r0
   10986:	4688      	mov	r8, r1
   10988:	4616      	mov	r6, r2
   1098a:	4699      	mov	r9, r3
    const char *p = *src;
   1098c:	680c      	ldr	r4, [r1, #0]
    int num = 0;
   1098e:	2700      	movs	r7, #0
    int digit;
    while ((digit = a2d(ch)) >= 0) {
   10990:	4628      	mov	r0, r5
   10992:	f7ff ffdd 	bl	10950 <a2d>
   10996:	2800      	cmp	r0, #0
   10998:	db06      	blt.n	109a8 <a2i+0x28>
        if (digit > base)
   1099a:	42b0      	cmp	r0, r6
   1099c:	dc04      	bgt.n	109a8 <a2i+0x28>
            break;
        num = num * base + digit;
   1099e:	fb06 0707 	mla	r7, r6, r7, r0
        ch = *p++;
   109a2:	f814 5b01 	ldrb.w	r5, [r4], #1
   109a6:	e7f3      	b.n	10990 <a2i+0x10>
    }
    *src = p;
   109a8:	f8c8 4000 	str.w	r4, [r8]
    *nump = num;
   109ac:	f889 7000 	strb.w	r7, [r9]
    return ch;
}
   109b0:	4628      	mov	r0, r5
   109b2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

000109b6 <putf>:

static int putf(FILE *putp, char c)
{
   109b6:	b500      	push	{lr}
   109b8:	b083      	sub	sp, #12
	return fwrite(s, 1, strlen(s), stdout) + fwrite("\n", 1, 1, stdout);
}

__extern_inline int fputc(int c, FILE *f)
{
	unsigned char ch = c;
   109ba:	f88d 1007 	strb.w	r1, [sp, #7]
    if (stream->vmt->write == NULL) return 0;
   109be:	6803      	ldr	r3, [r0, #0]
   109c0:	681b      	ldr	r3, [r3, #0]
   109c2:	b143      	cbz	r3, 109d6 <putf+0x20>
    return stream->vmt->write(stream, (char*)buf, size*nmemb) / size;
   109c4:	2201      	movs	r2, #1
   109c6:	f10d 0107 	add.w	r1, sp, #7
   109ca:	4798      	blx	r3
	return fwrite(&ch, 1, 1, f) == 1 ? ch : EOF;
   109cc:	2801      	cmp	r0, #1
   109ce:	d102      	bne.n	109d6 <putf+0x20>
    if (fputc(c, putp) == EOF)
        return 0;
    else
        return 1;
}
   109d0:	b003      	add	sp, #12
   109d2:	f85d fb04 	ldr.w	pc, [sp], #4
        return 0;
   109d6:	2000      	movs	r0, #0
   109d8:	e7fa      	b.n	109d0 <putf+0x1a>
	...

000109dc <putchw>:

static unsigned putchw(FILE *putp, struct param *p)
{
   109dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   109e0:	4607      	mov	r7, r0
   109e2:	4688      	mov	r8, r1
    unsigned written = 0;
    char ch;
    int n = p->width;
   109e4:	780c      	ldrb	r4, [r1, #0]
    char *bf = p->bf;
   109e6:	684b      	ldr	r3, [r1, #4]

    /* Number of filling characters */
    while (*bf++ && n > 0)
   109e8:	f813 2b01 	ldrb.w	r2, [r3], #1
   109ec:	b11a      	cbz	r2, 109f6 <putchw+0x1a>
   109ee:	2c00      	cmp	r4, #0
   109f0:	dd01      	ble.n	109f6 <putchw+0x1a>
        n--;
   109f2:	3c01      	subs	r4, #1
   109f4:	e7f8      	b.n	109e8 <putchw+0xc>
    if (p->sign)
   109f6:	f898 3002 	ldrb.w	r3, [r8, #2]
   109fa:	f013 0f01 	tst.w	r3, #1
   109fe:	d000      	beq.n	10a02 <putchw+0x26>
        n--;
   10a00:	3c01      	subs	r4, #1
    if (p->alt && p->base == 16)
   10a02:	f8b8 3002 	ldrh.w	r3, [r8, #2]
   10a06:	f023 03fd 	bic.w	r3, r3, #253	; 0xfd
   10a0a:	b29b      	uxth	r3, r3
   10a0c:	f241 0202 	movw	r2, #4098	; 0x1002
   10a10:	4293      	cmp	r3, r2
   10a12:	d028      	beq.n	10a66 <putchw+0x8a>
        n -= 2;
    else if (p->alt && p->base == 8)
   10a14:	f640 0202 	movw	r2, #2050	; 0x802
   10a18:	4293      	cmp	r3, r2
   10a1a:	d026      	beq.n	10a6a <putchw+0x8e>
        n--;

    /* Unless left-aligned, fill with space, before alternate or sign */
    if (!p->lz && !p->left) {
   10a1c:	f8d8 3000 	ldr.w	r3, [r8]
   10a20:	4e36      	ldr	r6, [pc, #216]	; (10afc <putchw+0x120>)
   10a22:	401e      	ands	r6, r3
   10a24:	b34e      	cbz	r6, 10a7a <putchw+0x9e>
    unsigned written = 0;
   10a26:	2600      	movs	r6, #0
        while (n-- > 0)
            written += putf(putp, ' ');
    }

    /* print sign */
    if (p->sign)
   10a28:	f898 3002 	ldrb.w	r3, [r8, #2]
   10a2c:	f013 0f01 	tst.w	r3, #1
   10a30:	d128      	bne.n	10a84 <putchw+0xa8>
        written += putf(putp, '-');

    /* Alternate */
    if (p->alt && p->base == 16) {
   10a32:	f8b8 3002 	ldrh.w	r3, [r8, #2]
   10a36:	f023 03fd 	bic.w	r3, r3, #253	; 0xfd
   10a3a:	b29b      	uxth	r3, r3
   10a3c:	f241 0202 	movw	r2, #4098	; 0x1002
   10a40:	4293      	cmp	r3, r2
   10a42:	d025      	beq.n	10a90 <putchw+0xb4>
        written += putf(putp, '0');
        written += putf(putp, (p->uc ? 'X' : 'x'));
    } else if (p->alt && p->base == 8) {
   10a44:	f640 0202 	movw	r2, #2050	; 0x802
   10a48:	4293      	cmp	r3, r2
   10a4a:	d033      	beq.n	10ab4 <putchw+0xd8>
        written += putf(putp, '0');
    }

    /* Fill with zeros, after alternate or sign */
    if (p->lz) {
   10a4c:	f898 3001 	ldrb.w	r3, [r8, #1]
   10a50:	bbe3      	cbnz	r3, 10acc <putchw+0xf0>
        while (n-- > 0)
            written += putf(putp, '0');
    }

    /* Put actual buffer */
    bf = p->bf;
   10a52:	f8d8 5004 	ldr.w	r5, [r8, #4]
    while ((ch = *bf++))
   10a56:	f815 1b01 	ldrb.w	r1, [r5], #1
   10a5a:	b3e1      	cbz	r1, 10ad6 <putchw+0xfa>
        written += putf(putp, ch);
   10a5c:	4638      	mov	r0, r7
   10a5e:	f7ff ffaa 	bl	109b6 <putf>
   10a62:	4406      	add	r6, r0
   10a64:	e7f7      	b.n	10a56 <putchw+0x7a>
        n -= 2;
   10a66:	3c02      	subs	r4, #2
   10a68:	e7d8      	b.n	10a1c <putchw+0x40>
        n--;
   10a6a:	3c01      	subs	r4, #1
   10a6c:	e7d6      	b.n	10a1c <putchw+0x40>
            written += putf(putp, ' ');
   10a6e:	2120      	movs	r1, #32
   10a70:	4638      	mov	r0, r7
   10a72:	f7ff ffa0 	bl	109b6 <putf>
   10a76:	4406      	add	r6, r0
        while (n-- > 0)
   10a78:	462c      	mov	r4, r5
   10a7a:	1e65      	subs	r5, r4, #1
   10a7c:	2c00      	cmp	r4, #0
   10a7e:	dcf6      	bgt.n	10a6e <putchw+0x92>
   10a80:	462c      	mov	r4, r5
   10a82:	e7d1      	b.n	10a28 <putchw+0x4c>
        written += putf(putp, '-');
   10a84:	212d      	movs	r1, #45	; 0x2d
   10a86:	4638      	mov	r0, r7
   10a88:	f7ff ff95 	bl	109b6 <putf>
   10a8c:	4406      	add	r6, r0
   10a8e:	e7d0      	b.n	10a32 <putchw+0x56>
        written += putf(putp, '0');
   10a90:	2130      	movs	r1, #48	; 0x30
   10a92:	4638      	mov	r0, r7
   10a94:	f7ff ff8f 	bl	109b6 <putf>
   10a98:	4406      	add	r6, r0
        written += putf(putp, (p->uc ? 'X' : 'x'));
   10a9a:	f898 3002 	ldrb.w	r3, [r8, #2]
   10a9e:	f013 0f04 	tst.w	r3, #4
   10aa2:	d005      	beq.n	10ab0 <putchw+0xd4>
   10aa4:	2158      	movs	r1, #88	; 0x58
   10aa6:	4638      	mov	r0, r7
   10aa8:	f7ff ff85 	bl	109b6 <putf>
   10aac:	4406      	add	r6, r0
   10aae:	e7cd      	b.n	10a4c <putchw+0x70>
   10ab0:	2178      	movs	r1, #120	; 0x78
   10ab2:	e7f8      	b.n	10aa6 <putchw+0xca>
        written += putf(putp, '0');
   10ab4:	2130      	movs	r1, #48	; 0x30
   10ab6:	4638      	mov	r0, r7
   10ab8:	f7ff ff7d 	bl	109b6 <putf>
   10abc:	4406      	add	r6, r0
   10abe:	e7c5      	b.n	10a4c <putchw+0x70>
            written += putf(putp, '0');
   10ac0:	2130      	movs	r1, #48	; 0x30
   10ac2:	4638      	mov	r0, r7
   10ac4:	f7ff ff77 	bl	109b6 <putf>
   10ac8:	4406      	add	r6, r0
        while (n-- > 0)
   10aca:	462c      	mov	r4, r5
   10acc:	1e65      	subs	r5, r4, #1
   10ace:	2c00      	cmp	r4, #0
   10ad0:	dcf6      	bgt.n	10ac0 <putchw+0xe4>
   10ad2:	462c      	mov	r4, r5
   10ad4:	e7bd      	b.n	10a52 <putchw+0x76>

    /* If left-aligned, pad the end with spaces. */
    if (p->left) {
   10ad6:	f898 3002 	ldrb.w	r3, [r8, #2]
   10ada:	f013 0f08 	tst.w	r3, #8
   10ade:	d102      	bne.n	10ae6 <putchw+0x10a>
        while (n-- > 0)
            written += putf(putp, ' ');
    }
    
    return written;
}
   10ae0:	4630      	mov	r0, r6
   10ae2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        while (n-- > 0)
   10ae6:	1e65      	subs	r5, r4, #1
   10ae8:	2c00      	cmp	r4, #0
   10aea:	ddf9      	ble.n	10ae0 <putchw+0x104>
            written += putf(putp, ' ');
   10aec:	2120      	movs	r1, #32
   10aee:	4638      	mov	r0, r7
   10af0:	f7ff ff61 	bl	109b6 <putf>
   10af4:	4406      	add	r6, r0
        while (n-- > 0)
   10af6:	462c      	mov	r4, r5
   10af8:	e7f5      	b.n	10ae6 <putchw+0x10a>
   10afa:	bf00      	nop
   10afc:	0008ff00 	.word	0x0008ff00

00010b00 <intarg>:
static unsigned long long
intarg(int lng, int sign, va_list *va)
{
    unsigned long long val;

    switch (lng) {
   10b00:	b160      	cbz	r0, 10b1c <intarg+0x1c>
   10b02:	2801      	cmp	r0, #1
   10b04:	d017      	beq.n	10b36 <intarg+0x36>
        }
        break;

    case 2:
    default:
        if (sign) {
   10b06:	b319      	cbz	r1, 10b50 <intarg+0x50>
            val = va_arg(*va, long long);
   10b08:	6813      	ldr	r3, [r2, #0]
   10b0a:	3307      	adds	r3, #7
   10b0c:	f023 0307 	bic.w	r3, r3, #7
   10b10:	f103 0108 	add.w	r1, r3, #8
   10b14:	6011      	str	r1, [r2, #0]
   10b16:	e9d3 0100 	ldrd	r0, r1, [r3]
   10b1a:	4770      	bx	lr
        if (sign) {
   10b1c:	b129      	cbz	r1, 10b2a <intarg+0x2a>
            val = va_arg(*va, int);
   10b1e:	6813      	ldr	r3, [r2, #0]
   10b20:	1d19      	adds	r1, r3, #4
   10b22:	6011      	str	r1, [r2, #0]
   10b24:	6818      	ldr	r0, [r3, #0]
   10b26:	17c1      	asrs	r1, r0, #31
   10b28:	4770      	bx	lr
            val = va_arg(*va, unsigned int);
   10b2a:	6813      	ldr	r3, [r2, #0]
   10b2c:	1d19      	adds	r1, r3, #4
   10b2e:	6011      	str	r1, [r2, #0]
   10b30:	6818      	ldr	r0, [r3, #0]
   10b32:	2100      	movs	r1, #0
   10b34:	4770      	bx	lr
        if (sign) {
   10b36:	b129      	cbz	r1, 10b44 <intarg+0x44>
            val = va_arg(*va, long);
   10b38:	6813      	ldr	r3, [r2, #0]
   10b3a:	1d19      	adds	r1, r3, #4
   10b3c:	6011      	str	r1, [r2, #0]
   10b3e:	6818      	ldr	r0, [r3, #0]
   10b40:	17c1      	asrs	r1, r0, #31
   10b42:	4770      	bx	lr
            val = va_arg(*va, unsigned long);
   10b44:	6813      	ldr	r3, [r2, #0]
   10b46:	1d19      	adds	r1, r3, #4
   10b48:	6011      	str	r1, [r2, #0]
   10b4a:	6818      	ldr	r0, [r3, #0]
   10b4c:	2100      	movs	r1, #0
   10b4e:	4770      	bx	lr
        } else {
            val = va_arg(*va, unsigned long long);
   10b50:	6813      	ldr	r3, [r2, #0]
   10b52:	3307      	adds	r3, #7
   10b54:	f023 0307 	bic.w	r3, r3, #7
   10b58:	f103 0108 	add.w	r1, r3, #8
   10b5c:	6011      	str	r1, [r2, #0]
   10b5e:	e9d3 0100 	ldrd	r0, r1, [r3]
        }
        break;
    }

    return val;
}
   10b62:	4770      	bx	lr

00010b64 <tfp_format>:

size_t tfp_format(FILE *putp, const char *fmt, va_list va)
{
   10b64:	b570      	push	{r4, r5, r6, lr}
   10b66:	b08a      	sub	sp, #40	; 0x28
   10b68:	4606      	mov	r6, r0
   10b6a:	9101      	str	r1, [sp, #4]
   10b6c:	9200      	str	r2, [sp, #0]
    double d;
    int n;
#endif
    int i;

    p.bf = bf;
   10b6e:	ab02      	add	r3, sp, #8
   10b70:	9309      	str	r3, [sp, #36]	; 0x24
    size_t written = 0;
   10b72:	2500      	movs	r5, #0

    while ((ch = *(fmt++))) {
   10b74:	9b01      	ldr	r3, [sp, #4]
   10b76:	1c5a      	adds	r2, r3, #1
   10b78:	9201      	str	r2, [sp, #4]
   10b7a:	7819      	ldrb	r1, [r3, #0]
   10b7c:	2900      	cmp	r1, #0
   10b7e:	f000 816e 	beq.w	10e5e <tfp_format+0x2fa>
        if (ch != '%') {
   10b82:	2925      	cmp	r1, #37	; 0x25
   10b84:	d004      	beq.n	10b90 <tfp_format+0x2c>
            written += putf(putp, ch);
   10b86:	4630      	mov	r0, r6
   10b88:	f7ff ff15 	bl	109b6 <putf>
   10b8c:	4405      	add	r5, r0
   10b8e:	e7f1      	b.n	10b74 <tfp_format+0x10>
        } else {
            /* Init parameter struct */
            p.lz = 0;
   10b90:	2200      	movs	r2, #0
   10b92:	f88d 2021 	strb.w	r2, [sp, #33]	; 0x21
            p.alt = 0;
   10b96:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
            p.width = 0;
   10b9a:	f88d 2020 	strb.w	r2, [sp, #32]
            p.sign = 0;
            p.left = 0;
            p.uc = 0;
            p.hh = 0;
   10b9e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
   10ba2:	f362 1305 	bfi	r3, r2, #4, #2
   10ba6:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
            lng = 0;

            /* Flags */
            while ((ch = *(fmt++))) {
   10baa:	9b01      	ldr	r3, [sp, #4]
   10bac:	1c5a      	adds	r2, r3, #1
   10bae:	9201      	str	r2, [sp, #4]
   10bb0:	781c      	ldrb	r4, [r3, #0]
   10bb2:	b12c      	cbz	r4, 10bc0 <tfp_format+0x5c>
                switch (ch) {
   10bb4:	2c2d      	cmp	r4, #45	; 0x2d
   10bb6:	d073      	beq.n	10ca0 <tfp_format+0x13c>
   10bb8:	2c30      	cmp	r4, #48	; 0x30
   10bba:	d061      	beq.n	10c80 <tfp_format+0x11c>
   10bbc:	2c23      	cmp	r4, #35	; 0x23
   10bbe:	d068      	beq.n	10c92 <tfp_format+0x12e>
                }
                break;
            }

            /* Width */
            if (ch == '*') {
   10bc0:	2c2a      	cmp	r4, #42	; 0x2a
   10bc2:	d077      	beq.n	10cb4 <tfp_format+0x150>
                    p.width = UCHAR_MAX;
                } else if (i > 0) {
                    p.width = i;
                }
                ch = *(fmt++);
            } else if (ch >= '0' && ch <= '9') {
   10bc4:	f1a4 0330 	sub.w	r3, r4, #48	; 0x30
   10bc8:	b2db      	uxtb	r3, r3
   10bca:	2b09      	cmp	r3, #9
   10bcc:	f240 8086 	bls.w	10cdc <tfp_format+0x178>
                ch = a2i(ch, &fmt, 10, &(p.width));
            }
            if (ch == 'l') {
   10bd0:	2c6c      	cmp	r4, #108	; 0x6c
   10bd2:	f000 808b 	beq.w	10cec <tfp_format+0x188>

                if (ch == 'l') {
                    ch = *(fmt++);
                    lng = 2;
                }
            } else if (ch == 'h') {
   10bd6:	2c68      	cmp	r4, #104	; 0x68
   10bd8:	f000 8095 	beq.w	10d06 <tfp_format+0x1a2>
            lng = 0;
   10bdc:	2000      	movs	r0, #0
                    ch = *(fmt++);
                    p.hh = 2;
                }
            }

            if (ch == 'z') {
   10bde:	2c7a      	cmp	r4, #122	; 0x7a
   10be0:	f000 80ab 	beq.w	10d3a <tfp_format+0x1d6>
                ch = *(fmt++);
            }

            switch (ch) {
   10be4:	2c78      	cmp	r4, #120	; 0x78
   10be6:	d8c5      	bhi.n	10b74 <tfp_format+0x10>
   10be8:	2c58      	cmp	r4, #88	; 0x58
   10bea:	f0c0 80ab 	bcc.w	10d44 <tfp_format+0x1e0>
   10bee:	f1a4 0358 	sub.w	r3, r4, #88	; 0x58
   10bf2:	2b20      	cmp	r3, #32
   10bf4:	d8be      	bhi.n	10b74 <tfp_format+0x10>
   10bf6:	a201      	add	r2, pc, #4	; (adr r2, 10bfc <tfp_format+0x98>)
   10bf8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   10bfc:	00010d9d 	.word	0x00010d9d
   10c00:	00010b75 	.word	0x00010b75
   10c04:	00010b75 	.word	0x00010b75
   10c08:	00010b75 	.word	0x00010b75
   10c0c:	00010b75 	.word	0x00010b75
   10c10:	00010b75 	.word	0x00010b75
   10c14:	00010b75 	.word	0x00010b75
   10c18:	00010b75 	.word	0x00010b75
   10c1c:	00010b75 	.word	0x00010b75
   10c20:	00010b75 	.word	0x00010b75
   10c24:	00010b75 	.word	0x00010b75
   10c28:	00010e33 	.word	0x00010e33
   10c2c:	00010d7d 	.word	0x00010d7d
   10c30:	00010b75 	.word	0x00010b75
   10c34:	00010b75 	.word	0x00010b75
   10c38:	00010b75 	.word	0x00010b75
   10c3c:	00010b75 	.word	0x00010b75
   10c40:	00010d7d 	.word	0x00010d7d
   10c44:	00010b75 	.word	0x00010b75
   10c48:	00010b75 	.word	0x00010b75
   10c4c:	00010b75 	.word	0x00010b75
   10c50:	00010b75 	.word	0x00010b75
   10c54:	00010b75 	.word	0x00010b75
   10c58:	00010dd1 	.word	0x00010dd1
   10c5c:	00010df1 	.word	0x00010df1
   10c60:	00010b75 	.word	0x00010b75
   10c64:	00010b75 	.word	0x00010b75
   10c68:	00010e45 	.word	0x00010e45
   10c6c:	00010b75 	.word	0x00010b75
   10c70:	00010d5d 	.word	0x00010d5d
   10c74:	00010b75 	.word	0x00010b75
   10c78:	00010b75 	.word	0x00010b75
   10c7c:	00010d9d 	.word	0x00010d9d
                    if (!p.left) {
   10c80:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
   10c84:	f013 0f08 	tst.w	r3, #8
   10c88:	d18f      	bne.n	10baa <tfp_format+0x46>
                        p.lz = 1;
   10c8a:	2301      	movs	r3, #1
   10c8c:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
                    continue;
   10c90:	e78b      	b.n	10baa <tfp_format+0x46>
                    p.alt = 1;
   10c92:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
   10c96:	f043 0302 	orr.w	r3, r3, #2
   10c9a:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
                    continue;
   10c9e:	e784      	b.n	10baa <tfp_format+0x46>
                    p.left = 1;
   10ca0:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
   10ca4:	f043 0308 	orr.w	r3, r3, #8
   10ca8:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
                    p.lz = 0;
   10cac:	2300      	movs	r3, #0
   10cae:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
                    continue;
   10cb2:	e77a      	b.n	10baa <tfp_format+0x46>
                i = intarg(0, 1, &va);
   10cb4:	466a      	mov	r2, sp
   10cb6:	2101      	movs	r1, #1
   10cb8:	2000      	movs	r0, #0
   10cba:	f7ff ff21 	bl	10b00 <intarg>
                if (i > UCHAR_MAX) {
   10cbe:	28ff      	cmp	r0, #255	; 0xff
   10cc0:	dd07      	ble.n	10cd2 <tfp_format+0x16e>
                    p.width = UCHAR_MAX;
   10cc2:	23ff      	movs	r3, #255	; 0xff
   10cc4:	f88d 3020 	strb.w	r3, [sp, #32]
                ch = *(fmt++);
   10cc8:	9b01      	ldr	r3, [sp, #4]
   10cca:	1c5a      	adds	r2, r3, #1
   10ccc:	9201      	str	r2, [sp, #4]
   10cce:	781c      	ldrb	r4, [r3, #0]
   10cd0:	e77e      	b.n	10bd0 <tfp_format+0x6c>
                } else if (i > 0) {
   10cd2:	2800      	cmp	r0, #0
   10cd4:	ddf8      	ble.n	10cc8 <tfp_format+0x164>
                    p.width = i;
   10cd6:	f88d 0020 	strb.w	r0, [sp, #32]
   10cda:	e7f5      	b.n	10cc8 <tfp_format+0x164>
                ch = a2i(ch, &fmt, 10, &(p.width));
   10cdc:	ab08      	add	r3, sp, #32
   10cde:	220a      	movs	r2, #10
   10ce0:	a901      	add	r1, sp, #4
   10ce2:	4620      	mov	r0, r4
   10ce4:	f7ff fe4c 	bl	10980 <a2i>
   10ce8:	4604      	mov	r4, r0
   10cea:	e771      	b.n	10bd0 <tfp_format+0x6c>
                ch = *(fmt++);
   10cec:	9b01      	ldr	r3, [sp, #4]
   10cee:	1c5a      	adds	r2, r3, #1
   10cf0:	9201      	str	r2, [sp, #4]
   10cf2:	781c      	ldrb	r4, [r3, #0]
                if (ch == 'l') {
   10cf4:	2c6c      	cmp	r4, #108	; 0x6c
   10cf6:	d001      	beq.n	10cfc <tfp_format+0x198>
                lng = 1;
   10cf8:	2001      	movs	r0, #1
   10cfa:	e770      	b.n	10bde <tfp_format+0x7a>
                    ch = *(fmt++);
   10cfc:	1c9a      	adds	r2, r3, #2
   10cfe:	9201      	str	r2, [sp, #4]
   10d00:	785c      	ldrb	r4, [r3, #1]
                    lng = 2;
   10d02:	2002      	movs	r0, #2
   10d04:	e76b      	b.n	10bde <tfp_format+0x7a>
                ch = *(fmt++);
   10d06:	9b01      	ldr	r3, [sp, #4]
   10d08:	1c5a      	adds	r2, r3, #1
   10d0a:	9201      	str	r2, [sp, #4]
   10d0c:	781c      	ldrb	r4, [r3, #0]
                p.hh = 1;
   10d0e:	f89d 1022 	ldrb.w	r1, [sp, #34]	; 0x22
   10d12:	2001      	movs	r0, #1
   10d14:	f360 1105 	bfi	r1, r0, #4, #2
   10d18:	f88d 1022 	strb.w	r1, [sp, #34]	; 0x22
                if (ch == 'h') {
   10d1c:	2c68      	cmp	r4, #104	; 0x68
   10d1e:	d001      	beq.n	10d24 <tfp_format+0x1c0>
            lng = 0;
   10d20:	2000      	movs	r0, #0
   10d22:	e75c      	b.n	10bde <tfp_format+0x7a>
                    ch = *(fmt++);
   10d24:	4402      	add	r2, r0
   10d26:	9201      	str	r2, [sp, #4]
   10d28:	785c      	ldrb	r4, [r3, #1]
                    p.hh = 2;
   10d2a:	b2cb      	uxtb	r3, r1
   10d2c:	2202      	movs	r2, #2
   10d2e:	f362 1305 	bfi	r3, r2, #4, #2
   10d32:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
            lng = 0;
   10d36:	2000      	movs	r0, #0
   10d38:	e751      	b.n	10bde <tfp_format+0x7a>
                ch = *(fmt++);
   10d3a:	9b01      	ldr	r3, [sp, #4]
   10d3c:	1c5a      	adds	r2, r3, #1
   10d3e:	9201      	str	r2, [sp, #4]
   10d40:	781c      	ldrb	r4, [r3, #0]
   10d42:	e74f      	b.n	10be4 <tfp_format+0x80>
            switch (ch) {
   10d44:	2c00      	cmp	r4, #0
   10d46:	f000 808a 	beq.w	10e5e <tfp_format+0x2fa>
   10d4a:	2c25      	cmp	r4, #37	; 0x25
   10d4c:	f47f af12 	bne.w	10b74 <tfp_format+0x10>
                /* Output the decimal part. */
                written += putchw(putp, &p);
                break;
#endif
            case '%':
                written += putf(putp, ch);
   10d50:	4621      	mov	r1, r4
   10d52:	4630      	mov	r0, r6
   10d54:	f7ff fe2f 	bl	109b6 <putf>
   10d58:	4405      	add	r5, r0
                break;
   10d5a:	e70b      	b.n	10b74 <tfp_format+0x10>
                p.base = 10;
   10d5c:	230a      	movs	r3, #10
   10d5e:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
                ui2a(intarg(lng, 0, &va), &p);
   10d62:	466a      	mov	r2, sp
   10d64:	2100      	movs	r1, #0
   10d66:	f7ff fecb 	bl	10b00 <intarg>
   10d6a:	aa08      	add	r2, sp, #32
   10d6c:	f7ff fd5e 	bl	1082c <ui2a>
                written += putchw(putp, &p);
   10d70:	a908      	add	r1, sp, #32
   10d72:	4630      	mov	r0, r6
   10d74:	f7ff fe32 	bl	109dc <putchw>
   10d78:	4405      	add	r5, r0
                break;
   10d7a:	e6fb      	b.n	10b74 <tfp_format+0x10>
                p.base = 10;
   10d7c:	230a      	movs	r3, #10
   10d7e:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
                i2a(intarg(lng, 1, &va), &p);
   10d82:	466a      	mov	r2, sp
   10d84:	2101      	movs	r1, #1
   10d86:	f7ff febb 	bl	10b00 <intarg>
   10d8a:	aa08      	add	r2, sp, #32
   10d8c:	f7ff fdcc 	bl	10928 <i2a>
                written += putchw(putp, &p);
   10d90:	a908      	add	r1, sp, #32
   10d92:	4630      	mov	r0, r6
   10d94:	f7ff fe22 	bl	109dc <putchw>
   10d98:	4405      	add	r5, r0
                break;
   10d9a:	e6eb      	b.n	10b74 <tfp_format+0x10>
                p.base = 16;
   10d9c:	2310      	movs	r3, #16
   10d9e:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
                p.uc = (ch == 'X');
   10da2:	2c58      	cmp	r4, #88	; 0x58
   10da4:	bf14      	ite	ne
   10da6:	2400      	movne	r4, #0
   10da8:	2401      	moveq	r4, #1
   10daa:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
   10dae:	f364 0382 	bfi	r3, r4, #2, #1
   10db2:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
                ui2a(intarg(lng, 0, &va), &p);
   10db6:	466a      	mov	r2, sp
   10db8:	2100      	movs	r1, #0
   10dba:	f7ff fea1 	bl	10b00 <intarg>
   10dbe:	aa08      	add	r2, sp, #32
   10dc0:	f7ff fd34 	bl	1082c <ui2a>
                written += putchw(putp, &p);
   10dc4:	a908      	add	r1, sp, #32
   10dc6:	4630      	mov	r0, r6
   10dc8:	f7ff fe08 	bl	109dc <putchw>
   10dcc:	4405      	add	r5, r0
                break;
   10dce:	e6d1      	b.n	10b74 <tfp_format+0x10>
                p.base = 8;
   10dd0:	2308      	movs	r3, #8
   10dd2:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
                ui2a(intarg(lng, 0, &va), &p);
   10dd6:	466a      	mov	r2, sp
   10dd8:	2100      	movs	r1, #0
   10dda:	f7ff fe91 	bl	10b00 <intarg>
   10dde:	aa08      	add	r2, sp, #32
   10de0:	f7ff fd24 	bl	1082c <ui2a>
                written += putchw(putp, &p);
   10de4:	a908      	add	r1, sp, #32
   10de6:	4630      	mov	r0, r6
   10de8:	f7ff fdf8 	bl	109dc <putchw>
   10dec:	4405      	add	r5, r0
                break;
   10dee:	e6c1      	b.n	10b74 <tfp_format+0x10>
                v = va_arg(va, void *);
   10df0:	9b00      	ldr	r3, [sp, #0]
   10df2:	1d1a      	adds	r2, r3, #4
   10df4:	9200      	str	r2, [sp, #0]
   10df6:	6818      	ldr	r0, [r3, #0]
                p.base = 16;
   10df8:	2310      	movs	r3, #16
   10dfa:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
                ui2a((uintptr_t)v, &p);
   10dfe:	aa08      	add	r2, sp, #32
   10e00:	2100      	movs	r1, #0
   10e02:	f7ff fd13 	bl	1082c <ui2a>
                p.width = 2 * sizeof(void*);
   10e06:	2308      	movs	r3, #8
   10e08:	f88d 3020 	strb.w	r3, [sp, #32]
                p.lz = 1;
   10e0c:	2301      	movs	r3, #1
   10e0e:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
                written += putf(putp, '0');
   10e12:	2130      	movs	r1, #48	; 0x30
   10e14:	4630      	mov	r0, r6
   10e16:	f7ff fdce 	bl	109b6 <putf>
   10e1a:	4405      	add	r5, r0
                written += putf(putp, 'x');
   10e1c:	2178      	movs	r1, #120	; 0x78
   10e1e:	4630      	mov	r0, r6
   10e20:	f7ff fdc9 	bl	109b6 <putf>
   10e24:	4405      	add	r5, r0
                written += putchw(putp, &p);
   10e26:	a908      	add	r1, sp, #32
   10e28:	4630      	mov	r0, r6
   10e2a:	f7ff fdd7 	bl	109dc <putchw>
   10e2e:	4405      	add	r5, r0
                break;
   10e30:	e6a0      	b.n	10b74 <tfp_format+0x10>
                written += putf(putp, (char)(va_arg(va, int)));
   10e32:	9b00      	ldr	r3, [sp, #0]
   10e34:	1d1a      	adds	r2, r3, #4
   10e36:	9200      	str	r2, [sp, #0]
   10e38:	7819      	ldrb	r1, [r3, #0]
   10e3a:	4630      	mov	r0, r6
   10e3c:	f7ff fdbb 	bl	109b6 <putf>
   10e40:	4405      	add	r5, r0
                break;
   10e42:	e697      	b.n	10b74 <tfp_format+0x10>
                p.bf = va_arg(va, char *);
   10e44:	9b00      	ldr	r3, [sp, #0]
   10e46:	1d1a      	adds	r2, r3, #4
   10e48:	9200      	str	r2, [sp, #0]
   10e4a:	681b      	ldr	r3, [r3, #0]
   10e4c:	9309      	str	r3, [sp, #36]	; 0x24
                written += putchw(putp, &p);
   10e4e:	a908      	add	r1, sp, #32
   10e50:	4630      	mov	r0, r6
   10e52:	f7ff fdc3 	bl	109dc <putchw>
   10e56:	4405      	add	r5, r0
                p.bf = bf;
   10e58:	ab02      	add	r3, sp, #8
   10e5a:	9309      	str	r3, [sp, #36]	; 0x24
                break;
   10e5c:	e68a      	b.n	10b74 <tfp_format+0x10>
        }
    }
 abort:;
 
 return written;
}
   10e5e:	4628      	mov	r0, r5
   10e60:	b00a      	add	sp, #40	; 0x28
   10e62:	bd70      	pop	{r4, r5, r6, pc}

00010e64 <vfprintf>:

int vfprintf(FILE *f, const char *fmt, va_list va)
{
   10e64:	b508      	push	{r3, lr}
    return tfp_format(f, fmt, va);
   10e66:	f7ff fe7d 	bl	10b64 <tfp_format>
}
   10e6a:	bd08      	pop	{r3, pc}

00010e6c <fprintf>:

int fprintf(FILE *f, const char *fmt, ...)
{
   10e6c:	b40e      	push	{r1, r2, r3}
   10e6e:	b500      	push	{lr}
   10e70:	b082      	sub	sp, #8
   10e72:	aa03      	add	r2, sp, #12
   10e74:	f852 1b04 	ldr.w	r1, [r2], #4
    va_list va;
    va_start(va, fmt);
   10e78:	9201      	str	r2, [sp, #4]
    int rv = vfprintf(f, fmt, va);
   10e7a:	f7ff fff3 	bl	10e64 <vfprintf>
    va_end(va);
    return rv;
}
   10e7e:	b002      	add	sp, #8
   10e80:	f85d eb04 	ldr.w	lr, [sp], #4
   10e84:	b003      	add	sp, #12
   10e86:	4770      	bx	lr

00010e88 <printf>:

int printf(const char *fmt, ...)
{
   10e88:	b40f      	push	{r0, r1, r2, r3}
   10e8a:	b500      	push	{lr}
   10e8c:	b083      	sub	sp, #12
   10e8e:	aa04      	add	r2, sp, #16
   10e90:	f852 1b04 	ldr.w	r1, [r2], #4
    va_list va;
    va_start(va, fmt);
   10e94:	9201      	str	r2, [sp, #4]
    int rv = vfprintf(stdout, fmt, va);
   10e96:	4b04      	ldr	r3, [pc, #16]	; (10ea8 <printf+0x20>)
   10e98:	6818      	ldr	r0, [r3, #0]
   10e9a:	f7ff ffe3 	bl	10e64 <vfprintf>
    va_end(va);
    return rv;
}
   10e9e:	b003      	add	sp, #12
   10ea0:	f85d eb04 	ldr.w	lr, [sp], #4
   10ea4:	b004      	add	sp, #16
   10ea6:	4770      	bx	lr
   10ea8:	00011b9c 	.word	0x00011b9c

00010eac <vprintf>:

#include <stdio.h>
#include <stdarg.h>

int vprintf(const char *format, va_list ap)
{
   10eac:	b508      	push	{r3, lr}
   10eae:	460a      	mov	r2, r1
	return vfprintf(stdout, format, ap);
   10eb0:	4601      	mov	r1, r0
   10eb2:	4b02      	ldr	r3, [pc, #8]	; (10ebc <vprintf+0x10>)
   10eb4:	6818      	ldr	r0, [r3, #0]
   10eb6:	f7ff ffd5 	bl	10e64 <vfprintf>
}
   10eba:	bd08      	pop	{r3, pc}
   10ebc:	00011b9c 	.word	0x00011b9c

00010ec0 <uart_hal_blocking_tx>:
    hal_uart_start_rx(uart_hal_dev_get_id(dev));
}

static void
uart_hal_blocking_tx(struct uart_dev *dev, uint8_t byte)
{
   10ec0:	b508      	push	{r3, lr}
    assert(dev->ud_priv);
   10ec2:	6b80      	ldr	r0, [r0, #56]	; 0x38
   10ec4:	b118      	cbz	r0, 10ece <uart_hal_blocking_tx+0xe>

    hal_uart_blocking_tx(uart_hal_dev_get_id(dev), byte);
   10ec6:	3801      	subs	r0, #1
   10ec8:	f000 fa2e 	bl	11328 <hal_uart_blocking_tx>
}
   10ecc:	bd08      	pop	{r3, pc}
    assert(dev->ud_priv);
   10ece:	f7fb f965 	bl	c19c <hal_debugger_connected>
   10ed2:	b100      	cbz	r0, 10ed6 <uart_hal_blocking_tx+0x16>
   10ed4:	be01      	bkpt	0x0001
   10ed6:	2300      	movs	r3, #0
   10ed8:	461a      	mov	r2, r3
   10eda:	4619      	mov	r1, r3
   10edc:	4618      	mov	r0, r3
   10ede:	f7fb fb3b 	bl	c558 <__assert_func>

00010ee2 <uart_hal_start_rx>:
{
   10ee2:	b508      	push	{r3, lr}
    assert(dev->ud_priv);
   10ee4:	6b80      	ldr	r0, [r0, #56]	; 0x38
   10ee6:	b118      	cbz	r0, 10ef0 <uart_hal_start_rx+0xe>
    hal_uart_start_rx(uart_hal_dev_get_id(dev));
   10ee8:	3801      	subs	r0, #1
   10eea:	f000 f9f7 	bl	112dc <hal_uart_start_rx>
}
   10eee:	bd08      	pop	{r3, pc}
    assert(dev->ud_priv);
   10ef0:	f7fb f954 	bl	c19c <hal_debugger_connected>
   10ef4:	b100      	cbz	r0, 10ef8 <uart_hal_start_rx+0x16>
   10ef6:	be01      	bkpt	0x0001
   10ef8:	2300      	movs	r3, #0
   10efa:	461a      	mov	r2, r3
   10efc:	4619      	mov	r1, r3
   10efe:	4618      	mov	r0, r3
   10f00:	f7fb fb2a 	bl	c558 <__assert_func>

00010f04 <uart_hal_start_tx>:
{
   10f04:	b508      	push	{r3, lr}
    assert(dev->ud_priv);
   10f06:	6b80      	ldr	r0, [r0, #56]	; 0x38
   10f08:	b118      	cbz	r0, 10f12 <uart_hal_start_tx+0xe>
    hal_uart_start_tx(uart_hal_dev_get_id(dev));
   10f0a:	3801      	subs	r0, #1
   10f0c:	f000 f9b6 	bl	1127c <hal_uart_start_tx>
}
   10f10:	bd08      	pop	{r3, pc}
    assert(dev->ud_priv);
   10f12:	f7fb f943 	bl	c19c <hal_debugger_connected>
   10f16:	b100      	cbz	r0, 10f1a <uart_hal_start_tx+0x16>
   10f18:	be01      	bkpt	0x0001
   10f1a:	2300      	movs	r3, #0
   10f1c:	461a      	mov	r2, r3
   10f1e:	4619      	mov	r1, r3
   10f20:	4618      	mov	r0, r3
   10f22:	f7fb fb19 	bl	c558 <__assert_func>

00010f26 <uart_hal_resume>:
    return OS_OK;
}

static int
uart_hal_resume(struct os_dev *odev)
{
   10f26:	b510      	push	{r4, lr}
   10f28:	b082      	sub	sp, #8
    return (intptr_t)(dev->ud_priv) - 1;
   10f2a:	6b84      	ldr	r4, [r0, #56]	; 0x38
    struct uart_conf_port *ucp = &dev->ud_conf_port;
    int rc;

    rc = hal_uart_config(uart_hal_dev_get_id(dev), ucp->uc_speed,
                         ucp->uc_databits, ucp->uc_stopbits,
                         (enum hal_uart_parity)ucp->uc_parity,
   10f2c:	f890 3036 	ldrb.w	r3, [r0, #54]	; 0x36
                         (enum hal_uart_flow_ctl)ucp->uc_flow_ctl);
   10f30:	f890 2037 	ldrb.w	r2, [r0, #55]	; 0x37
    rc = hal_uart_config(uart_hal_dev_get_id(dev), ucp->uc_speed,
   10f34:	9201      	str	r2, [sp, #4]
   10f36:	9300      	str	r3, [sp, #0]
   10f38:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
   10f3c:	f890 2034 	ldrb.w	r2, [r0, #52]	; 0x34
   10f40:	6b01      	ldr	r1, [r0, #48]	; 0x30
   10f42:	1e60      	subs	r0, r4, #1
   10f44:	f000 fa50 	bl	113e8 <hal_uart_config>
    if (rc) {
   10f48:	b908      	cbnz	r0, 10f4e <uart_hal_resume+0x28>
        return OS_EINVAL;
    }

    return OS_OK;
}
   10f4a:	b002      	add	sp, #8
   10f4c:	bd10      	pop	{r4, pc}
        return OS_EINVAL;
   10f4e:	2002      	movs	r0, #2
   10f50:	e7fb      	b.n	10f4a <uart_hal_resume+0x24>

00010f52 <uart_hal_suspend>:
{
   10f52:	b570      	push	{r4, r5, r6, lr}
   10f54:	4606      	mov	r6, r0
   10f56:	460c      	mov	r4, r1
   10f58:	4615      	mov	r5, r2
    if (OS_TIME_TICK_GT(suspend_at, os_time_get()) || !force) {
   10f5a:	f7fc fa65 	bl	d428 <os_time_get>
   10f5e:	1a24      	subs	r4, r4, r0
   10f60:	2c00      	cmp	r4, #0
   10f62:	dc06      	bgt.n	10f72 <uart_hal_suspend+0x20>
   10f64:	b13d      	cbz	r5, 10f76 <uart_hal_suspend+0x24>
    return (intptr_t)(dev->ud_priv) - 1;
   10f66:	6bb0      	ldr	r0, [r6, #56]	; 0x38
    rc = hal_uart_close(uart_hal_dev_get_id(dev));
   10f68:	3801      	subs	r0, #1
   10f6a:	f000 fabb 	bl	114e4 <hal_uart_close>
    if (rc) {
   10f6e:	b920      	cbnz	r0, 10f7a <uart_hal_suspend+0x28>
}
   10f70:	bd70      	pop	{r4, r5, r6, pc}
        return OS_EINVAL;
   10f72:	2002      	movs	r0, #2
   10f74:	e7fc      	b.n	10f70 <uart_hal_suspend+0x1e>
   10f76:	2002      	movs	r0, #2
   10f78:	e7fa      	b.n	10f70 <uart_hal_suspend+0x1e>
        return OS_EINVAL;
   10f7a:	2002      	movs	r0, #2
   10f7c:	e7f8      	b.n	10f70 <uart_hal_suspend+0x1e>

00010f7e <uart_hal_close>:
{
   10f7e:	b508      	push	{r3, lr}
    return (intptr_t)(dev->ud_priv) - 1;
   10f80:	6b80      	ldr	r0, [r0, #56]	; 0x38
    rc = hal_uart_close(uart_hal_dev_get_id(dev));
   10f82:	3801      	subs	r0, #1
   10f84:	f000 faae 	bl	114e4 <hal_uart_close>
    if (rc) {
   10f88:	b900      	cbnz	r0, 10f8c <uart_hal_close+0xe>
}
   10f8a:	bd08      	pop	{r3, pc}
        return OS_EINVAL;
   10f8c:	2002      	movs	r0, #2
   10f8e:	e7fc      	b.n	10f8a <uart_hal_close+0xc>

00010f90 <uart_hal_open>:
{
   10f90:	b550      	push	{r4, r6, lr}
   10f92:	b083      	sub	sp, #12
   10f94:	4606      	mov	r6, r0
    assert(dev->ud_priv);
   10f96:	6b80      	ldr	r0, [r0, #56]	; 0x38
   10f98:	2800      	cmp	r0, #0
   10f9a:	d02b      	beq.n	10ff4 <uart_hal_open+0x64>
   10f9c:	4614      	mov	r4, r2
    if (!uc) {
   10f9e:	2a00      	cmp	r2, #0
   10fa0:	d032      	beq.n	11008 <uart_hal_open+0x78>
    if (odev->od_flags & OS_DEV_F_STATUS_OPEN) {
   10fa2:	7ef3      	ldrb	r3, [r6, #27]
   10fa4:	f013 0f02 	tst.w	r3, #2
   10fa8:	d130      	bne.n	1100c <uart_hal_open+0x7c>
    dev->ud_conf_port.uc_databits = uc->uc_databits;
   10faa:	7913      	ldrb	r3, [r2, #4]
   10fac:	f886 3034 	strb.w	r3, [r6, #52]	; 0x34
    dev->ud_conf_port.uc_flow_ctl = uc->uc_flow_ctl;
   10fb0:	79d3      	ldrb	r3, [r2, #7]
   10fb2:	f886 3037 	strb.w	r3, [r6, #55]	; 0x37
    dev->ud_conf_port.uc_parity = uc->uc_parity;
   10fb6:	7993      	ldrb	r3, [r2, #6]
   10fb8:	f886 3036 	strb.w	r3, [r6, #54]	; 0x36
    dev->ud_conf_port.uc_speed = uc->uc_speed;
   10fbc:	6813      	ldr	r3, [r2, #0]
   10fbe:	6333      	str	r3, [r6, #48]	; 0x30
    dev->ud_conf_port.uc_stopbits = uc->uc_stopbits;
   10fc0:	7953      	ldrb	r3, [r2, #5]
   10fc2:	f886 3035 	strb.w	r3, [r6, #53]	; 0x35
    rc = hal_uart_init_cbs(uart_hal_dev_get_id(dev), uc->uc_tx_char, uc->uc_tx_done,
   10fc6:	6953      	ldr	r3, [r2, #20]
   10fc8:	9300      	str	r3, [sp, #0]
   10fca:	68d3      	ldr	r3, [r2, #12]
   10fcc:	6912      	ldr	r2, [r2, #16]
   10fce:	68a1      	ldr	r1, [r4, #8]
   10fd0:	3801      	subs	r0, #1
   10fd2:	f000 f935 	bl	11240 <hal_uart_init_cbs>
    if (rc) {
   10fd6:	b9e0      	cbnz	r0, 11012 <uart_hal_open+0x82>
    return (intptr_t)(dev->ud_priv) - 1;
   10fd8:	6bb0      	ldr	r0, [r6, #56]	; 0x38
      uc->uc_stopbits, (enum hal_uart_parity)uc->uc_parity, (enum hal_uart_flow_ctl)uc->uc_flow_ctl);
   10fda:	79a3      	ldrb	r3, [r4, #6]
   10fdc:	79e2      	ldrb	r2, [r4, #7]
    rc = hal_uart_config(uart_hal_dev_get_id(dev), uc->uc_speed, uc->uc_databits,
   10fde:	9201      	str	r2, [sp, #4]
   10fe0:	9300      	str	r3, [sp, #0]
   10fe2:	7963      	ldrb	r3, [r4, #5]
   10fe4:	7922      	ldrb	r2, [r4, #4]
   10fe6:	6821      	ldr	r1, [r4, #0]
   10fe8:	3801      	subs	r0, #1
   10fea:	f000 f9fd 	bl	113e8 <hal_uart_config>
    if (rc) {
   10fee:	b170      	cbz	r0, 1100e <uart_hal_open+0x7e>
        return OS_EINVAL;
   10ff0:	2002      	movs	r0, #2
   10ff2:	e00c      	b.n	1100e <uart_hal_open+0x7e>
    assert(dev->ud_priv);
   10ff4:	f7fb f8d2 	bl	c19c <hal_debugger_connected>
   10ff8:	b100      	cbz	r0, 10ffc <uart_hal_open+0x6c>
   10ffa:	be01      	bkpt	0x0001
   10ffc:	2300      	movs	r3, #0
   10ffe:	461a      	mov	r2, r3
   11000:	4619      	mov	r1, r3
   11002:	4618      	mov	r0, r3
   11004:	f7fb faa8 	bl	c558 <__assert_func>
        return OS_EINVAL;
   11008:	2002      	movs	r0, #2
   1100a:	e000      	b.n	1100e <uart_hal_open+0x7e>
        return OS_EBUSY;
   1100c:	200b      	movs	r0, #11
}
   1100e:	b003      	add	sp, #12
   11010:	bd50      	pop	{r4, r6, pc}
        return OS_EINVAL;
   11012:	2002      	movs	r0, #2
   11014:	e7fb      	b.n	1100e <uart_hal_open+0x7e>
	...

00011018 <uart_hal_init>:
/*
 * Arg points to BSP specific UART configuration.
 */
int
uart_hal_init(struct os_dev *odev, void *arg)
{
   11018:	b570      	push	{r4, r5, r6, lr}
   1101a:	4604      	mov	r4, r0
   1101c:	460e      	mov	r6, r1
    struct uart_dev *dev;
    char ch;

    dev = (struct uart_dev *)odev;

    ch = odev->od_name[strlen(odev->od_name) - 1];
   1101e:	69c5      	ldr	r5, [r0, #28]
   11020:	4628      	mov	r0, r5
   11022:	f7fc fbe2 	bl	d7ea <strlen>
   11026:	3801      	subs	r0, #1
   11028:	5c28      	ldrb	r0, [r5, r0]
    if (!isdigit((unsigned char)ch)) {
   1102a:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
   1102e:	2b09      	cmp	r3, #9
   11030:	d816      	bhi.n	11060 <uart_hal_init+0x48>
    dev->ud_priv = (void *)((intptr_t)(id + 1));
   11032:	f1a0 032f 	sub.w	r3, r0, #47	; 0x2f
   11036:	63a3      	str	r3, [r4, #56]	; 0x38
        return OS_EINVAL;
    }
    uart_hal_dev_set_id(dev, ch - '0');

    OS_DEV_SETHANDLERS(odev, uart_hal_open, uart_hal_close);
   11038:	4b0a      	ldr	r3, [pc, #40]	; (11064 <uart_hal_init+0x4c>)
   1103a:	6023      	str	r3, [r4, #0]
   1103c:	4b0a      	ldr	r3, [pc, #40]	; (11068 <uart_hal_init+0x50>)
   1103e:	60e3      	str	r3, [r4, #12]
    odev->od_handlers.od_suspend = uart_hal_suspend;
   11040:	4b0a      	ldr	r3, [pc, #40]	; (1106c <uart_hal_init+0x54>)
   11042:	6063      	str	r3, [r4, #4]
    odev->od_handlers.od_resume = uart_hal_resume;
   11044:	4b0a      	ldr	r3, [pc, #40]	; (11070 <uart_hal_init+0x58>)
   11046:	60a3      	str	r3, [r4, #8]

    dev->ud_funcs.uf_start_tx = uart_hal_start_tx;
   11048:	4b0a      	ldr	r3, [pc, #40]	; (11074 <uart_hal_init+0x5c>)
   1104a:	6263      	str	r3, [r4, #36]	; 0x24
    dev->ud_funcs.uf_start_rx = uart_hal_start_rx;
   1104c:	4b0a      	ldr	r3, [pc, #40]	; (11078 <uart_hal_init+0x60>)
   1104e:	62a3      	str	r3, [r4, #40]	; 0x28
    dev->ud_funcs.uf_blocking_tx = uart_hal_blocking_tx;
   11050:	4b0a      	ldr	r3, [pc, #40]	; (1107c <uart_hal_init+0x64>)
   11052:	62e3      	str	r3, [r4, #44]	; 0x2c

    hal_uart_init(uart_hal_dev_get_id(dev), arg);
   11054:	4631      	mov	r1, r6
   11056:	3830      	subs	r0, #48	; 0x30
   11058:	f000 f998 	bl	1138c <hal_uart_init>

    return OS_OK;
   1105c:	2000      	movs	r0, #0
}
   1105e:	bd70      	pop	{r4, r5, r6, pc}
        return OS_EINVAL;
   11060:	2002      	movs	r0, #2
   11062:	e7fc      	b.n	1105e <uart_hal_init+0x46>
   11064:	00010f91 	.word	0x00010f91
   11068:	00010f7f 	.word	0x00010f7f
   1106c:	00010f53 	.word	0x00010f53
   11070:	00010f27 	.word	0x00010f27
   11074:	00010f05 	.word	0x00010f05
   11078:	00010ee3 	.word	0x00010ee3
   1107c:	00010ec1 	.word	0x00010ec1

00011080 <hal_uart_tx_fill_buf>:
    return 0;
}

static int
hal_uart_tx_fill_buf(struct hal_uart *u)
{
   11080:	b538      	push	{r3, r4, r5, lr}
   11082:	4605      	mov	r5, r0
    int data;
    int i;

    for (i = 0; i < sizeof(u->u_tx_buf); i++) {
   11084:	2400      	movs	r4, #0
   11086:	e002      	b.n	1108e <hal_uart_tx_fill_buf+0xe>
        data = u->u_tx_func(u->u_func_arg);
        if (data < 0) {
            break;
        }
        u->u_tx_buf[i] = data;
   11088:	192b      	adds	r3, r5, r4
   1108a:	7098      	strb	r0, [r3, #2]
    for (i = 0; i < sizeof(u->u_tx_buf); i++) {
   1108c:	3401      	adds	r4, #1
   1108e:	2c07      	cmp	r4, #7
   11090:	d804      	bhi.n	1109c <hal_uart_tx_fill_buf+0x1c>
        data = u->u_tx_func(u->u_func_arg);
   11092:	692b      	ldr	r3, [r5, #16]
   11094:	69a8      	ldr	r0, [r5, #24]
   11096:	4798      	blx	r3
        if (data < 0) {
   11098:	2800      	cmp	r0, #0
   1109a:	daf5      	bge.n	11088 <hal_uart_tx_fill_buf+0x8>
    }
    return i;
}
   1109c:	4620      	mov	r0, r4
   1109e:	bd38      	pop	{r3, r4, r5, pc}

000110a0 <uart_irq_handler>:
    nrf_uart->TASKS_STOPTX = 1;
}

static void
uart_irq_handler(NRF_UARTE_Type *nrf_uart, struct hal_uart *u)
{
   110a0:	b538      	push	{r3, r4, r5, lr}
   110a2:	4604      	mov	r4, r0
   110a4:	460d      	mov	r5, r1
    int rc;

    os_trace_isr_enter();

    if (nrf_uart->EVENTS_ENDTX) {
   110a6:	f8d0 3120 	ldr.w	r3, [r0, #288]	; 0x120
   110aa:	b973      	cbnz	r3, 110ca <uart_irq_handler+0x2a>
            nrf_uart->INTENCLR = UARTE_INT_ENDTX;
            nrf_uart->TASKS_STOPTX = 1;
            u->u_tx_started = 0;
        }
    }
    if (nrf_uart->EVENTS_ENDRX) {
   110ac:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
   110b0:	b153      	cbz	r3, 110c8 <uart_irq_handler+0x28>
        nrf_uart->EVENTS_ENDRX = 0;
   110b2:	2300      	movs	r3, #0
   110b4:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
        rc = u->u_rx_func(u->u_func_arg, u->u_rx_buf);
   110b8:	68eb      	ldr	r3, [r5, #12]
   110ba:	7869      	ldrb	r1, [r5, #1]
   110bc:	69a8      	ldr	r0, [r5, #24]
   110be:	4798      	blx	r3
        if (rc < 0) {
   110c0:	2800      	cmp	r0, #0
   110c2:	db21      	blt.n	11108 <uart_irq_handler+0x68>
            u->u_rx_stall = 1;
        } else {
            nrf_uart->TASKS_STARTRX = 1;
   110c4:	2301      	movs	r3, #1
   110c6:	6023      	str	r3, [r4, #0]
        }
    }
    os_trace_isr_exit();
}
   110c8:	bd38      	pop	{r3, r4, r5, pc}
        nrf_uart->EVENTS_ENDTX = 0;
   110ca:	2300      	movs	r3, #0
   110cc:	f8c0 3120 	str.w	r3, [r0, #288]	; 0x120
        rc = hal_uart_tx_fill_buf(u);
   110d0:	4608      	mov	r0, r1
   110d2:	f7ff ffd5 	bl	11080 <hal_uart_tx_fill_buf>
        if (rc > 0) {
   110d6:	2800      	cmp	r0, #0
   110d8:	dd07      	ble.n	110ea <uart_irq_handler+0x4a>
            nrf_uart->TXD.PTR = (uint32_t)&u->u_tx_buf;
   110da:	1cab      	adds	r3, r5, #2
   110dc:	f8c4 3544 	str.w	r3, [r4, #1348]	; 0x544
            nrf_uart->TXD.MAXCNT = rc;
   110e0:	f8c4 0548 	str.w	r0, [r4, #1352]	; 0x548
            nrf_uart->TASKS_STARTTX = 1;
   110e4:	2301      	movs	r3, #1
   110e6:	60a3      	str	r3, [r4, #8]
   110e8:	e7e0      	b.n	110ac <uart_irq_handler+0xc>
            if (u->u_tx_done) {
   110ea:	696b      	ldr	r3, [r5, #20]
   110ec:	b10b      	cbz	r3, 110f2 <uart_irq_handler+0x52>
                u->u_tx_done(u->u_func_arg);
   110ee:	69a8      	ldr	r0, [r5, #24]
   110f0:	4798      	blx	r3
            nrf_uart->INTENCLR = UARTE_INT_ENDTX;
   110f2:	f44f 7380 	mov.w	r3, #256	; 0x100
   110f6:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
            nrf_uart->TASKS_STOPTX = 1;
   110fa:	2301      	movs	r3, #1
   110fc:	60e3      	str	r3, [r4, #12]
            u->u_tx_started = 0;
   110fe:	782b      	ldrb	r3, [r5, #0]
   11100:	f36f 0382 	bfc	r3, #2, #1
   11104:	702b      	strb	r3, [r5, #0]
   11106:	e7d1      	b.n	110ac <uart_irq_handler+0xc>
            u->u_rx_stall = 1;
   11108:	782b      	ldrb	r3, [r5, #0]
   1110a:	f043 0302 	orr.w	r3, r3, #2
   1110e:	702b      	strb	r3, [r5, #0]
   11110:	e7da      	b.n	110c8 <uart_irq_handler+0x28>
	...

00011114 <uart0_irq_handler>:

static void
uart0_irq_handler(void)
{
   11114:	b508      	push	{r3, lr}
    uart_irq_handler(NRF_UARTE0, &uart0);
   11116:	4902      	ldr	r1, [pc, #8]	; (11120 <uart0_irq_handler+0xc>)
   11118:	4802      	ldr	r0, [pc, #8]	; (11124 <uart0_irq_handler+0x10>)
   1111a:	f7ff ffc1 	bl	110a0 <uart_irq_handler>
}
   1111e:	bd08      	pop	{r3, pc}
   11120:	200023dc 	.word	0x200023dc
   11124:	40002000 	.word	0x40002000

00011128 <uart1_irq_handler>:

#if defined(NRF52840_XXAA)
static void
uart1_irq_handler(void)
{
   11128:	b508      	push	{r3, lr}
    uart_irq_handler(NRF_UARTE1, &uart1);
   1112a:	4902      	ldr	r1, [pc, #8]	; (11134 <uart1_irq_handler+0xc>)
   1112c:	4802      	ldr	r0, [pc, #8]	; (11138 <uart1_irq_handler+0x10>)
   1112e:	f7ff ffb7 	bl	110a0 <uart_irq_handler>
}
   11132:	bd08      	pop	{r3, pc}
   11134:	200023f8 	.word	0x200023f8
   11138:	40028000 	.word	0x40028000

0001113c <hal_uart_baudrate>:
#endif

static uint32_t
hal_uart_baudrate(int baudrate)
{
    switch (baudrate) {
   1113c:	f64d 23c0 	movw	r3, #56000	; 0xdac0
   11140:	4298      	cmp	r0, r3
   11142:	d049      	beq.n	111d8 <hal_uart_baudrate+0x9c>
   11144:	dc23      	bgt.n	1118e <hal_uart_baudrate+0x52>
   11146:	f5b0 5f61 	cmp.w	r0, #14400	; 0x3840
   1114a:	d048      	beq.n	111de <hal_uart_baudrate+0xa2>
   1114c:	dd08      	ble.n	11160 <hal_uart_baudrate+0x24>
   1114e:	f5b0 4fe1 	cmp.w	r0, #28800	; 0x7080
   11152:	d04f      	beq.n	111f4 <hal_uart_baudrate+0xb8>
   11154:	f5b0 4f16 	cmp.w	r0, #38400	; 0x9600
   11158:	d114      	bne.n	11184 <hal_uart_baudrate+0x48>
    case 19200:
        return UARTE_BAUDRATE_BAUDRATE_Baud19200;
    case 28800:
        return UARTE_BAUDRATE_BAUDRATE_Baud28800;
    case 38400:
        return UARTE_BAUDRATE_BAUDRATE_Baud38400;
   1115a:	f44f 001d 	mov.w	r0, #10289152	; 0x9d0000
   1115e:	4770      	bx	lr
    switch (baudrate) {
   11160:	f5b0 5f96 	cmp.w	r0, #4800	; 0x12c0
   11164:	d03d      	beq.n	111e2 <hal_uart_baudrate+0xa6>
   11166:	dd04      	ble.n	11172 <hal_uart_baudrate+0x36>
   11168:	f5b0 5f16 	cmp.w	r0, #9600	; 0x2580
   1116c:	d140      	bne.n	111f0 <hal_uart_baudrate+0xb4>
        return UARTE_BAUDRATE_BAUDRATE_Baud9600;
   1116e:	482c      	ldr	r0, [pc, #176]	; (11220 <hal_uart_baudrate+0xe4>)
   11170:	4770      	bx	lr
    switch (baudrate) {
   11172:	f5b0 6f96 	cmp.w	r0, #1200	; 0x4b0
   11176:	d036      	beq.n	111e6 <hal_uart_baudrate+0xaa>
   11178:	f5b0 6f16 	cmp.w	r0, #2400	; 0x960
   1117c:	d136      	bne.n	111ec <hal_uart_baudrate+0xb0>
        return UARTE_BAUDRATE_BAUDRATE_Baud2400;
   1117e:	f44f 201d 	mov.w	r0, #643072	; 0x9d000
   11182:	4770      	bx	lr
    switch (baudrate) {
   11184:	f5b0 4f96 	cmp.w	r0, #19200	; 0x4b00
   11188:	d136      	bne.n	111f8 <hal_uart_baudrate+0xbc>
        return UARTE_BAUDRATE_BAUDRATE_Baud19200;
   1118a:	4826      	ldr	r0, [pc, #152]	; (11224 <hal_uart_baudrate+0xe8>)
   1118c:	4770      	bx	lr
    switch (baudrate) {
   1118e:	4b26      	ldr	r3, [pc, #152]	; (11228 <hal_uart_baudrate+0xec>)
   11190:	4298      	cmp	r0, r3
   11192:	d033      	beq.n	111fc <hal_uart_baudrate+0xc0>
   11194:	dd08      	ble.n	111a8 <hal_uart_baudrate+0x6c>
   11196:	f5b0 2f61 	cmp.w	r0, #921600	; 0xe1000
   1119a:	d03c      	beq.n	11216 <hal_uart_baudrate+0xda>
   1119c:	4b23      	ldr	r3, [pc, #140]	; (1122c <hal_uart_baudrate+0xf0>)
   1119e:	4298      	cmp	r0, r3
   111a0:	d114      	bne.n	111cc <hal_uart_baudrate+0x90>
    case 460800:
        return UARTE_BAUDRATE_BAUDRATE_Baud460800;
    case 921600:
        return UARTE_BAUDRATE_BAUDRATE_Baud921600;
    case 1000000:
        return UARTE_BAUDRATE_BAUDRATE_Baud1M;
   111a2:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
   111a6:	4770      	bx	lr
    switch (baudrate) {
   111a8:	f5b0 3fe1 	cmp.w	r0, #115200	; 0x1c200
   111ac:	d029      	beq.n	11202 <hal_uart_baudrate+0xc6>
   111ae:	dd05      	ble.n	111bc <hal_uart_baudrate+0x80>
   111b0:	f5b0 3f61 	cmp.w	r0, #230400	; 0x38400
   111b4:	d12d      	bne.n	11212 <hal_uart_baudrate+0xd6>
        return UARTE_BAUDRATE_BAUDRATE_Baud230400;
   111b6:	f04f 706c 	mov.w	r0, #61865984	; 0x3b00000
   111ba:	4770      	bx	lr
    switch (baudrate) {
   111bc:	f5b0 4f61 	cmp.w	r0, #57600	; 0xe100
   111c0:	d022      	beq.n	11208 <hal_uart_baudrate+0xcc>
   111c2:	f5b0 3f96 	cmp.w	r0, #76800	; 0x12c00
   111c6:	d122      	bne.n	1120e <hal_uart_baudrate+0xd2>
        return UARTE_BAUDRATE_BAUDRATE_Baud76800;
   111c8:	4819      	ldr	r0, [pc, #100]	; (11230 <hal_uart_baudrate+0xf4>)
   111ca:	4770      	bx	lr
    switch (baudrate) {
   111cc:	f5b0 2fe1 	cmp.w	r0, #460800	; 0x70800
   111d0:	d124      	bne.n	1121c <hal_uart_baudrate+0xe0>
        return UARTE_BAUDRATE_BAUDRATE_Baud460800;
   111d2:	f04f 60e8 	mov.w	r0, #121634816	; 0x7400000
   111d6:	4770      	bx	lr
        return UARTE_BAUDRATE_BAUDRATE_Baud56000;
   111d8:	f44f 0065 	mov.w	r0, #15007744	; 0xe50000
   111dc:	4770      	bx	lr
        return UARTE_BAUDRATE_BAUDRATE_Baud14400;
   111de:	4815      	ldr	r0, [pc, #84]	; (11234 <hal_uart_baudrate+0xf8>)
   111e0:	4770      	bx	lr
        return UARTE_BAUDRATE_BAUDRATE_Baud4800;
   111e2:	4815      	ldr	r0, [pc, #84]	; (11238 <hal_uart_baudrate+0xfc>)
   111e4:	4770      	bx	lr
    switch (baudrate) {
   111e6:	f44f 209e 	mov.w	r0, #323584	; 0x4f000
   111ea:	4770      	bx	lr
    default:
        return 0;
   111ec:	2000      	movs	r0, #0
   111ee:	4770      	bx	lr
   111f0:	2000      	movs	r0, #0
   111f2:	4770      	bx	lr
        return UARTE_BAUDRATE_BAUDRATE_Baud28800;
   111f4:	4811      	ldr	r0, [pc, #68]	; (1123c <hal_uart_baudrate+0x100>)
   111f6:	4770      	bx	lr
        return 0;
   111f8:	2000      	movs	r0, #0
   111fa:	4770      	bx	lr
        return UARTE_BAUDRATE_BAUDRATE_Baud250000;
   111fc:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
   11200:	4770      	bx	lr
        return UARTE_BAUDRATE_BAUDRATE_Baud115200;
   11202:	f04f 70eb 	mov.w	r0, #30801920	; 0x1d60000
   11206:	4770      	bx	lr
        return UARTE_BAUDRATE_BAUDRATE_Baud57600;
   11208:	f44f 006b 	mov.w	r0, #15400960	; 0xeb0000
   1120c:	4770      	bx	lr
        return 0;
   1120e:	2000      	movs	r0, #0
   11210:	4770      	bx	lr
   11212:	2000      	movs	r0, #0
   11214:	4770      	bx	lr
        return UARTE_BAUDRATE_BAUDRATE_Baud921600;
   11216:	f04f 6070 	mov.w	r0, #251658240	; 0xf000000
   1121a:	4770      	bx	lr
        return 0;
   1121c:	2000      	movs	r0, #0
    }
}
   1121e:	4770      	bx	lr
   11220:	00275000 	.word	0x00275000
   11224:	004ea000 	.word	0x004ea000
   11228:	0003d090 	.word	0x0003d090
   1122c:	000f4240 	.word	0x000f4240
   11230:	013a9000 	.word	0x013a9000
   11234:	003af000 	.word	0x003af000
   11238:	0013b000 	.word	0x0013b000
   1123c:	0075c000 	.word	0x0075c000

00011240 <hal_uart_init_cbs>:
{
   11240:	b410      	push	{r4}
    if (port == 0) {
   11242:	b118      	cbz	r0, 1124c <hal_uart_init_cbs+0xc>
    } else if (port == 1) {
   11244:	2801      	cmp	r0, #1
   11246:	d10e      	bne.n	11266 <hal_uart_init_cbs+0x26>
        u = &uart1;
   11248:	480a      	ldr	r0, [pc, #40]	; (11274 <hal_uart_init_cbs+0x34>)
   1124a:	e000      	b.n	1124e <hal_uart_init_cbs+0xe>
        u = &uart0;
   1124c:	480a      	ldr	r0, [pc, #40]	; (11278 <hal_uart_init_cbs+0x38>)
    if (u->u_open) {
   1124e:	7804      	ldrb	r4, [r0, #0]
   11250:	f014 0f01 	tst.w	r4, #1
   11254:	d10a      	bne.n	1126c <hal_uart_init_cbs+0x2c>
    u->u_rx_func = rx_func;
   11256:	60c3      	str	r3, [r0, #12]
    u->u_tx_func = tx_func;
   11258:	6101      	str	r1, [r0, #16]
    u->u_tx_done = tx_done;
   1125a:	6142      	str	r2, [r0, #20]
    u->u_func_arg = arg;
   1125c:	9b01      	ldr	r3, [sp, #4]
   1125e:	6183      	str	r3, [r0, #24]
    return 0;
   11260:	2000      	movs	r0, #0
}
   11262:	bc10      	pop	{r4}
   11264:	4770      	bx	lr
        return -1;
   11266:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1126a:	e7fa      	b.n	11262 <hal_uart_init_cbs+0x22>
        return -1;
   1126c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   11270:	e7f7      	b.n	11262 <hal_uart_init_cbs+0x22>
   11272:	bf00      	nop
   11274:	200023f8 	.word	0x200023f8
   11278:	200023dc 	.word	0x200023dc

0001127c <hal_uart_start_tx>:
{
   1127c:	b570      	push	{r4, r5, r6, lr}
    if (port == 0) {
   1127e:	b120      	cbz	r0, 1128a <hal_uart_start_tx+0xe>
    } else if (port == 1) {
   11280:	2801      	cmp	r0, #1
   11282:	d10d      	bne.n	112a0 <hal_uart_start_tx+0x24>
        u = &uart1;
   11284:	4c11      	ldr	r4, [pc, #68]	; (112cc <hal_uart_start_tx+0x50>)
        nrf_uart = NRF_UARTE1;
   11286:	4e12      	ldr	r6, [pc, #72]	; (112d0 <hal_uart_start_tx+0x54>)
   11288:	e001      	b.n	1128e <hal_uart_start_tx+0x12>
        u = &uart0;
   1128a:	4c12      	ldr	r4, [pc, #72]	; (112d4 <hal_uart_start_tx+0x58>)
        nrf_uart = NRF_UARTE0;
   1128c:	4e12      	ldr	r6, [pc, #72]	; (112d8 <hal_uart_start_tx+0x5c>)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
   1128e:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
   11292:	b672      	cpsid	i
    if (u->u_tx_started == 0) {
   11294:	7823      	ldrb	r3, [r4, #0]
   11296:	f013 0f04 	tst.w	r3, #4
   1129a:	d002      	beq.n	112a2 <hal_uart_start_tx+0x26>
    __HAL_ENABLE_INTERRUPTS(sr);
   1129c:	b905      	cbnz	r5, 112a0 <hal_uart_start_tx+0x24>
  __ASM volatile ("cpsie i" : : : "memory");
   1129e:	b662      	cpsie	i
}
   112a0:	bd70      	pop	{r4, r5, r6, pc}
        rc = hal_uart_tx_fill_buf(u);
   112a2:	4620      	mov	r0, r4
   112a4:	f7ff feec 	bl	11080 <hal_uart_tx_fill_buf>
        if (rc > 0) {
   112a8:	2800      	cmp	r0, #0
   112aa:	ddf7      	ble.n	1129c <hal_uart_start_tx+0x20>
            nrf_uart->INTENSET = UARTE_INT_ENDTX;
   112ac:	f44f 7380 	mov.w	r3, #256	; 0x100
   112b0:	f8c6 3304 	str.w	r3, [r6, #772]	; 0x304
            nrf_uart->TXD.PTR = (uint32_t)&u->u_tx_buf;
   112b4:	1ca3      	adds	r3, r4, #2
   112b6:	f8c6 3544 	str.w	r3, [r6, #1348]	; 0x544
            nrf_uart->TXD.MAXCNT = rc;
   112ba:	f8c6 0548 	str.w	r0, [r6, #1352]	; 0x548
            nrf_uart->TASKS_STARTTX = 1;
   112be:	2301      	movs	r3, #1
   112c0:	60b3      	str	r3, [r6, #8]
            u->u_tx_started = 1;
   112c2:	7823      	ldrb	r3, [r4, #0]
   112c4:	f043 0304 	orr.w	r3, r3, #4
   112c8:	7023      	strb	r3, [r4, #0]
   112ca:	e7e7      	b.n	1129c <hal_uart_start_tx+0x20>
   112cc:	200023f8 	.word	0x200023f8
   112d0:	40028000 	.word	0x40028000
   112d4:	200023dc 	.word	0x200023dc
   112d8:	40002000 	.word	0x40002000

000112dc <hal_uart_start_rx>:
{
   112dc:	b570      	push	{r4, r5, r6, lr}
    if (port == 0) {
   112de:	b120      	cbz	r0, 112ea <hal_uart_start_rx+0xe>
    } else if (port == 1) {
   112e0:	2801      	cmp	r0, #1
   112e2:	d118      	bne.n	11316 <hal_uart_start_rx+0x3a>
        u = &uart1;
   112e4:	4c0c      	ldr	r4, [pc, #48]	; (11318 <hal_uart_start_rx+0x3c>)
        nrf_uart = NRF_UARTE1;
   112e6:	4d0d      	ldr	r5, [pc, #52]	; (1131c <hal_uart_start_rx+0x40>)
   112e8:	e001      	b.n	112ee <hal_uart_start_rx+0x12>
        u = &uart0;
   112ea:	4c0d      	ldr	r4, [pc, #52]	; (11320 <hal_uart_start_rx+0x44>)
        nrf_uart = NRF_UARTE0;
   112ec:	4d0d      	ldr	r5, [pc, #52]	; (11324 <hal_uart_start_rx+0x48>)
    if (u->u_rx_stall) {
   112ee:	7823      	ldrb	r3, [r4, #0]
   112f0:	f013 0f02 	tst.w	r3, #2
   112f4:	d00f      	beq.n	11316 <hal_uart_start_rx+0x3a>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
   112f6:	f3ef 8610 	mrs	r6, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
   112fa:	b672      	cpsid	i
        rc = u->u_rx_func(u->u_func_arg, u->u_rx_buf);
   112fc:	68e3      	ldr	r3, [r4, #12]
   112fe:	7861      	ldrb	r1, [r4, #1]
   11300:	69a0      	ldr	r0, [r4, #24]
   11302:	4798      	blx	r3
        if (rc == 0) {
   11304:	b928      	cbnz	r0, 11312 <hal_uart_start_rx+0x36>
            u->u_rx_stall = 0;
   11306:	7823      	ldrb	r3, [r4, #0]
   11308:	f36f 0341 	bfc	r3, #1, #1
   1130c:	7023      	strb	r3, [r4, #0]
            nrf_uart->TASKS_STARTRX = 1;
   1130e:	2301      	movs	r3, #1
   11310:	602b      	str	r3, [r5, #0]
        __HAL_ENABLE_INTERRUPTS(sr);
   11312:	b906      	cbnz	r6, 11316 <hal_uart_start_rx+0x3a>
  __ASM volatile ("cpsie i" : : : "memory");
   11314:	b662      	cpsie	i
}
   11316:	bd70      	pop	{r4, r5, r6, pc}
   11318:	200023f8 	.word	0x200023f8
   1131c:	40028000 	.word	0x40028000
   11320:	200023dc 	.word	0x200023dc
   11324:	40002000 	.word	0x40002000

00011328 <hal_uart_blocking_tx>:
{
   11328:	b082      	sub	sp, #8
   1132a:	f88d 1007 	strb.w	r1, [sp, #7]
    if (port == 0) {
   1132e:	b120      	cbz	r0, 1133a <hal_uart_blocking_tx+0x12>
    } else if (port == 1) {
   11330:	2801      	cmp	r0, #1
   11332:	d120      	bne.n	11376 <hal_uart_blocking_tx+0x4e>
        nrf_uart = NRF_UARTE1;
   11334:	4b11      	ldr	r3, [pc, #68]	; (1137c <hal_uart_blocking_tx+0x54>)
        u = &uart1;
   11336:	4a12      	ldr	r2, [pc, #72]	; (11380 <hal_uart_blocking_tx+0x58>)
   11338:	e001      	b.n	1133e <hal_uart_blocking_tx+0x16>
        nrf_uart = NRF_UARTE0;
   1133a:	4b12      	ldr	r3, [pc, #72]	; (11384 <hal_uart_blocking_tx+0x5c>)
        u = &uart0;
   1133c:	4a12      	ldr	r2, [pc, #72]	; (11388 <hal_uart_blocking_tx+0x60>)
    if (!u->u_open) {
   1133e:	7812      	ldrb	r2, [r2, #0]
   11340:	f012 0f01 	tst.w	r2, #1
   11344:	d017      	beq.n	11376 <hal_uart_blocking_tx+0x4e>
    if (u->u_tx_started) {
   11346:	f012 0f04 	tst.w	r2, #4
   1134a:	d003      	beq.n	11354 <hal_uart_blocking_tx+0x2c>
        while (nrf_uart->EVENTS_ENDTX == 0) {
   1134c:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
   11350:	2a00      	cmp	r2, #0
   11352:	d0fb      	beq.n	1134c <hal_uart_blocking_tx+0x24>
    nrf_uart->EVENTS_ENDTX = 0;
   11354:	2200      	movs	r2, #0
   11356:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
    nrf_uart->TXD.PTR = (uint32_t)&data;
   1135a:	f10d 0207 	add.w	r2, sp, #7
   1135e:	f8c3 2544 	str.w	r2, [r3, #1348]	; 0x544
    nrf_uart->TXD.MAXCNT = 1;
   11362:	2201      	movs	r2, #1
   11364:	f8c3 2548 	str.w	r2, [r3, #1352]	; 0x548
    nrf_uart->TASKS_STARTTX = 1;
   11368:	609a      	str	r2, [r3, #8]
    while (nrf_uart->EVENTS_ENDTX == 0) {
   1136a:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
   1136e:	2a00      	cmp	r2, #0
   11370:	d0fb      	beq.n	1136a <hal_uart_blocking_tx+0x42>
    nrf_uart->TASKS_STOPTX = 1;
   11372:	2201      	movs	r2, #1
   11374:	60da      	str	r2, [r3, #12]
}
   11376:	b002      	add	sp, #8
   11378:	4770      	bx	lr
   1137a:	bf00      	nop
   1137c:	40028000 	.word	0x40028000
   11380:	200023f8 	.word	0x200023f8
   11384:	40002000 	.word	0x40002000
   11388:	200023dc 	.word	0x200023dc

0001138c <hal_uart_init>:
{
    struct nrf52_uart_cfg *cfg;
    NRF_UARTE_Type *nrf_uart;

#if defined(NRF52840_XXAA)
    if (port == 0) {
   1138c:	b9b0      	cbnz	r0, 113bc <hal_uart_init+0x30>
  uint32_t vectors = (uint32_t )SCB->VTOR;
   1138e:	4b11      	ldr	r3, [pc, #68]	; (113d4 <hal_uart_init+0x48>)
   11390:	689b      	ldr	r3, [r3, #8]
  (* (int *) (vectors + ((int32_t)IRQn + NVIC_USER_IRQ_OFFSET) * 4)) = vector;
   11392:	4a11      	ldr	r2, [pc, #68]	; (113d8 <hal_uart_init+0x4c>)
   11394:	649a      	str	r2, [r3, #72]	; 0x48
        nrf_uart = NRF_UARTE0;
   11396:	4b11      	ldr	r3, [pc, #68]	; (113dc <hal_uart_init+0x50>)
    NVIC_SetVector(UARTE0_UART0_IRQn, (uint32_t)uart0_irq_handler);
#endif

    cfg = (struct nrf52_uart_cfg *)arg;

    nrf_uart->PSEL.TXD = cfg->suc_pin_tx;
   11398:	f991 2000 	ldrsb.w	r2, [r1]
   1139c:	f8c3 250c 	str.w	r2, [r3, #1292]	; 0x50c
    nrf_uart->PSEL.RXD = cfg->suc_pin_rx;
   113a0:	f991 2001 	ldrsb.w	r2, [r1, #1]
   113a4:	f8c3 2514 	str.w	r2, [r3, #1300]	; 0x514
    nrf_uart->PSEL.RTS = cfg->suc_pin_rts;
   113a8:	f991 2002 	ldrsb.w	r2, [r1, #2]
   113ac:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
    nrf_uart->PSEL.CTS = cfg->suc_pin_cts;
   113b0:	f991 2003 	ldrsb.w	r2, [r1, #3]
   113b4:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510

    return 0;
   113b8:	2000      	movs	r0, #0
   113ba:	4770      	bx	lr
    } else if (port == 1) {
   113bc:	2801      	cmp	r0, #1
   113be:	d106      	bne.n	113ce <hal_uart_init+0x42>
  uint32_t vectors = (uint32_t )SCB->VTOR;
   113c0:	4b04      	ldr	r3, [pc, #16]	; (113d4 <hal_uart_init+0x48>)
   113c2:	689b      	ldr	r3, [r3, #8]
  (* (int *) (vectors + ((int32_t)IRQn + NVIC_USER_IRQ_OFFSET) * 4)) = vector;
   113c4:	4a06      	ldr	r2, [pc, #24]	; (113e0 <hal_uart_init+0x54>)
   113c6:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
        nrf_uart = NRF_UARTE1;
   113ca:	4b06      	ldr	r3, [pc, #24]	; (113e4 <hal_uart_init+0x58>)
}
   113cc:	e7e4      	b.n	11398 <hal_uart_init+0xc>
        return -1;
   113ce:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   113d2:	4770      	bx	lr
   113d4:	e000ed00 	.word	0xe000ed00
   113d8:	00011115 	.word	0x00011115
   113dc:	40002000 	.word	0x40002000
   113e0:	00011129 	.word	0x00011129
   113e4:	40028000 	.word	0x40028000

000113e8 <hal_uart_config>:

int
hal_uart_config(int port, int32_t baudrate, uint8_t databits, uint8_t stopbits,
  enum hal_uart_parity parity, enum hal_uart_flow_ctl flow_ctl)
{
   113e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   113ea:	f89d 6018 	ldrb.w	r6, [sp, #24]
    uint32_t baud_reg;
    NRF_UARTE_Type *nrf_uart;
    IRQn_Type irqnum;

#if defined(NRF52840_XXAA)
    if (port == 0) {
   113ee:	b128      	cbz	r0, 113fc <hal_uart_config+0x14>
        nrf_uart = NRF_UARTE0;
        irqnum = UARTE0_UART0_IRQn;
        u = &uart0;
    } else if (port == 1) {
   113f0:	2801      	cmp	r0, #1
   113f2:	d15b      	bne.n	114ac <hal_uart_config+0xc4>
        nrf_uart = NRF_UARTE1;
        irqnum = UARTE1_IRQn;
   113f4:	2728      	movs	r7, #40	; 0x28
        nrf_uart = NRF_UARTE1;
   113f6:	4c36      	ldr	r4, [pc, #216]	; (114d0 <hal_uart_config+0xe8>)
        u = &uart1;
   113f8:	4d36      	ldr	r5, [pc, #216]	; (114d4 <hal_uart_config+0xec>)
   113fa:	e002      	b.n	11402 <hal_uart_config+0x1a>
        irqnum = UARTE0_UART0_IRQn;
   113fc:	2702      	movs	r7, #2
        nrf_uart = NRF_UARTE0;
   113fe:	4c36      	ldr	r4, [pc, #216]	; (114d8 <hal_uart_config+0xf0>)
        u = &uart0;
   11400:	4d36      	ldr	r5, [pc, #216]	; (114dc <hal_uart_config+0xf4>)
    nrf_uart = NRF_UARTE0;
    irqnum = UARTE0_UART0_IRQn;
    u = &uart0;
#endif

    if (u->u_open) {
   11402:	7828      	ldrb	r0, [r5, #0]
   11404:	f010 0f01 	tst.w	r0, #1
   11408:	d153      	bne.n	114b2 <hal_uart_config+0xca>
     * pin config
     * UART config
     * nvic config
     * enable uart
     */
    if (databits != 8) {
   1140a:	2a08      	cmp	r2, #8
   1140c:	d154      	bne.n	114b8 <hal_uart_config+0xd0>
        return -1;
    }
    if (stopbits != 1) {
   1140e:	2b01      	cmp	r3, #1
   11410:	d155      	bne.n	114be <hal_uart_config+0xd6>
        return -1;
    }

    switch (parity) {
   11412:	2e01      	cmp	r6, #1
   11414:	d056      	beq.n	114c4 <hal_uart_config+0xdc>
   11416:	2e02      	cmp	r6, #2
   11418:	d130      	bne.n	1147c <hal_uart_config+0x94>
    case HAL_UART_PARITY_NONE:
        break;
    case HAL_UART_PARITY_ODD:
        return -1;
    case HAL_UART_PARITY_EVEN:
        cfg_reg |= UARTE_CONFIG_PARITY;
   1141a:	260e      	movs	r6, #14
        break;
    }

    switch (flow_ctl) {
   1141c:	f89d 301c 	ldrb.w	r3, [sp, #28]
   11420:	2b01      	cmp	r3, #1
   11422:	d02d      	beq.n	11480 <hal_uart_config+0x98>
            assert(0);
            return -1;
        }
        break;
    }
    baud_reg = hal_uart_baudrate(baudrate);
   11424:	4608      	mov	r0, r1
   11426:	f7ff fe89 	bl	1113c <hal_uart_baudrate>
    if (baud_reg == 0) {
   1142a:	4603      	mov	r3, r0
   1142c:	2800      	cmp	r0, #0
   1142e:	d04c      	beq.n	114ca <hal_uart_config+0xe2>
        return -1;
    }
    nrf_uart->ENABLE = 0;
   11430:	2000      	movs	r0, #0
   11432:	f8c4 0500 	str.w	r0, [r4, #1280]	; 0x500
    nrf_uart->INTENCLR = 0xffffffff;
   11436:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1143a:	f8c4 2308 	str.w	r2, [r4, #776]	; 0x308
    nrf_uart->BAUDRATE = baud_reg;
   1143e:	f8c4 3524 	str.w	r3, [r4, #1316]	; 0x524
    nrf_uart->CONFIG = cfg_reg;
   11442:	f8c4 656c 	str.w	r6, [r4, #1388]	; 0x56c
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   11446:	f007 010a 	and.w	r1, r7, #10
   1144a:	097b      	lsrs	r3, r7, #5
   1144c:	2201      	movs	r2, #1
   1144e:	fa02 f101 	lsl.w	r1, r2, r1
   11452:	4e23      	ldr	r6, [pc, #140]	; (114e0 <hal_uart_config+0xf8>)
   11454:	f846 1023 	str.w	r1, [r6, r3, lsl #2]

    NVIC_EnableIRQ(irqnum);

    nrf_uart->ENABLE = UARTE_ENABLE;
   11458:	2308      	movs	r3, #8
   1145a:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500

    nrf_uart->INTENSET = UARTE_INT_ENDRX;
   1145e:	2310      	movs	r3, #16
   11460:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
    nrf_uart->RXD.PTR = (uint32_t)&u->u_rx_buf;
   11464:	18ab      	adds	r3, r5, r2
   11466:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
    nrf_uart->RXD.MAXCNT = sizeof(u->u_rx_buf);
   1146a:	f8c4 2538 	str.w	r2, [r4, #1336]	; 0x538
    nrf_uart->TASKS_STARTRX = 1;
   1146e:	6022      	str	r2, [r4, #0]

    u->u_rx_stall = 0;
   11470:	782b      	ldrb	r3, [r5, #0]
    u->u_tx_started = 0;
    u->u_open = 1;
   11472:	f003 03f9 	and.w	r3, r3, #249	; 0xf9
   11476:	4313      	orrs	r3, r2
   11478:	702b      	strb	r3, [r5, #0]

    return 0;
}
   1147a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    switch (parity) {
   1147c:	2600      	movs	r6, #0
   1147e:	e7cd      	b.n	1141c <hal_uart_config+0x34>
        cfg_reg |= UARTE_CONFIG_HWFC;
   11480:	f046 0601 	orr.w	r6, r6, #1
        if (nrf_uart->PSEL.RTS == 0xffffffff ||
   11484:	f8d4 3508 	ldr.w	r3, [r4, #1288]	; 0x508
   11488:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   1148c:	d004      	beq.n	11498 <hal_uart_config+0xb0>
          nrf_uart->PSEL.CTS == 0xffffffff) {
   1148e:	f8d4 3510 	ldr.w	r3, [r4, #1296]	; 0x510
        if (nrf_uart->PSEL.RTS == 0xffffffff ||
   11492:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   11496:	d1c5      	bne.n	11424 <hal_uart_config+0x3c>
            assert(0);
   11498:	f7fa fe80 	bl	c19c <hal_debugger_connected>
   1149c:	b100      	cbz	r0, 114a0 <hal_uart_config+0xb8>
   1149e:	be01      	bkpt	0x0001
   114a0:	2300      	movs	r3, #0
   114a2:	461a      	mov	r2, r3
   114a4:	4619      	mov	r1, r3
   114a6:	4618      	mov	r0, r3
   114a8:	f7fb f856 	bl	c558 <__assert_func>
        return -1;
   114ac:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   114b0:	e7e3      	b.n	1147a <hal_uart_config+0x92>
        return -1;
   114b2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   114b6:	e7e0      	b.n	1147a <hal_uart_config+0x92>
        return -1;
   114b8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   114bc:	e7dd      	b.n	1147a <hal_uart_config+0x92>
        return -1;
   114be:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   114c2:	e7da      	b.n	1147a <hal_uart_config+0x92>
    switch (parity) {
   114c4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   114c8:	e7d7      	b.n	1147a <hal_uart_config+0x92>
        return -1;
   114ca:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   114ce:	e7d4      	b.n	1147a <hal_uart_config+0x92>
   114d0:	40028000 	.word	0x40028000
   114d4:	200023f8 	.word	0x200023f8
   114d8:	40002000 	.word	0x40002000
   114dc:	200023dc 	.word	0x200023dc
   114e0:	e000e100 	.word	0xe000e100

000114e4 <hal_uart_close>:
{
    volatile struct hal_uart *u;
    NRF_UARTE_Type *nrf_uart;

#if defined(NRF52840_XXAA)
    if (port == 0) {
   114e4:	b120      	cbz	r0, 114f0 <hal_uart_close+0xc>
        nrf_uart = NRF_UARTE0;
        u = &uart0;
    } else if (port == 1) {
   114e6:	2801      	cmp	r0, #1
   114e8:	d114      	bne.n	11514 <hal_uart_close+0x30>
        nrf_uart = NRF_UARTE1;
   114ea:	490c      	ldr	r1, [pc, #48]	; (1151c <hal_uart_close+0x38>)
        u = &uart1;
   114ec:	4a0c      	ldr	r2, [pc, #48]	; (11520 <hal_uart_close+0x3c>)
   114ee:	e001      	b.n	114f4 <hal_uart_close+0x10>
        nrf_uart = NRF_UARTE0;
   114f0:	490c      	ldr	r1, [pc, #48]	; (11524 <hal_uart_close+0x40>)
        u = &uart0;
   114f2:	4a0d      	ldr	r2, [pc, #52]	; (11528 <hal_uart_close+0x44>)
    }
    nrf_uart = NRF_UARTE0;
    u = &uart0;
#endif

    u->u_open = 0;
   114f4:	7813      	ldrb	r3, [r2, #0]
   114f6:	f36f 0300 	bfc	r3, #0, #1
   114fa:	7013      	strb	r3, [r2, #0]
    while (u->u_tx_started) {
   114fc:	7813      	ldrb	r3, [r2, #0]
   114fe:	f013 0f04 	tst.w	r3, #4
   11502:	d1fb      	bne.n	114fc <hal_uart_close+0x18>
        /* Wait here until the dma is finished */
    }
    nrf_uart->ENABLE = 0;
   11504:	2000      	movs	r0, #0
   11506:	f8c1 0500 	str.w	r0, [r1, #1280]	; 0x500
    nrf_uart->INTENCLR = 0xffffffff;
   1150a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1150e:	f8c1 3308 	str.w	r3, [r1, #776]	; 0x308
    return 0;
   11512:	4770      	bx	lr
        return -1;
   11514:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   11518:	4770      	bx	lr
   1151a:	bf00      	nop
   1151c:	40028000 	.word	0x40028000
   11520:	200023f8 	.word	0x200023f8
   11524:	40002000 	.word	0x40002000
   11528:	200023dc 	.word	0x200023dc

0001152c <__aeabi_uldivmod>:
   1152c:	b953      	cbnz	r3, 11544 <__aeabi_uldivmod+0x18>
   1152e:	b94a      	cbnz	r2, 11544 <__aeabi_uldivmod+0x18>
   11530:	2900      	cmp	r1, #0
   11532:	bf08      	it	eq
   11534:	2800      	cmpeq	r0, #0
   11536:	bf1c      	itt	ne
   11538:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
   1153c:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   11540:	f000 b96c 	b.w	1181c <__aeabi_idiv0>
   11544:	f1ad 0c08 	sub.w	ip, sp, #8
   11548:	e96d ce04 	strd	ip, lr, [sp, #-16]!
   1154c:	f000 f806 	bl	1155c <__udivmoddi4>
   11550:	f8dd e004 	ldr.w	lr, [sp, #4]
   11554:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   11558:	b004      	add	sp, #16
   1155a:	4770      	bx	lr

0001155c <__udivmoddi4>:
   1155c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   11560:	9e08      	ldr	r6, [sp, #32]
   11562:	460d      	mov	r5, r1
   11564:	4604      	mov	r4, r0
   11566:	468e      	mov	lr, r1
   11568:	2b00      	cmp	r3, #0
   1156a:	f040 8082 	bne.w	11672 <__udivmoddi4+0x116>
   1156e:	428a      	cmp	r2, r1
   11570:	4617      	mov	r7, r2
   11572:	d946      	bls.n	11602 <__udivmoddi4+0xa6>
   11574:	fab2 f282 	clz	r2, r2
   11578:	b14a      	cbz	r2, 1158e <__udivmoddi4+0x32>
   1157a:	f1c2 0120 	rsb	r1, r2, #32
   1157e:	fa05 f302 	lsl.w	r3, r5, r2
   11582:	fa20 f101 	lsr.w	r1, r0, r1
   11586:	4097      	lsls	r7, r2
   11588:	ea41 0e03 	orr.w	lr, r1, r3
   1158c:	4094      	lsls	r4, r2
   1158e:	ea4f 4817 	mov.w	r8, r7, lsr #16
   11592:	0c23      	lsrs	r3, r4, #16
   11594:	fbbe fcf8 	udiv	ip, lr, r8
   11598:	b2b9      	uxth	r1, r7
   1159a:	fb08 ee1c 	mls	lr, r8, ip, lr
   1159e:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
   115a2:	fb0c f001 	mul.w	r0, ip, r1
   115a6:	4298      	cmp	r0, r3
   115a8:	d90a      	bls.n	115c0 <__udivmoddi4+0x64>
   115aa:	18fb      	adds	r3, r7, r3
   115ac:	f10c 35ff 	add.w	r5, ip, #4294967295	; 0xffffffff
   115b0:	f080 8116 	bcs.w	117e0 <__udivmoddi4+0x284>
   115b4:	4298      	cmp	r0, r3
   115b6:	f240 8113 	bls.w	117e0 <__udivmoddi4+0x284>
   115ba:	f1ac 0c02 	sub.w	ip, ip, #2
   115be:	443b      	add	r3, r7
   115c0:	1a1b      	subs	r3, r3, r0
   115c2:	b2a4      	uxth	r4, r4
   115c4:	fbb3 f0f8 	udiv	r0, r3, r8
   115c8:	fb08 3310 	mls	r3, r8, r0, r3
   115cc:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
   115d0:	fb00 f101 	mul.w	r1, r0, r1
   115d4:	42a1      	cmp	r1, r4
   115d6:	d909      	bls.n	115ec <__udivmoddi4+0x90>
   115d8:	193c      	adds	r4, r7, r4
   115da:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   115de:	f080 8101 	bcs.w	117e4 <__udivmoddi4+0x288>
   115e2:	42a1      	cmp	r1, r4
   115e4:	f240 80fe 	bls.w	117e4 <__udivmoddi4+0x288>
   115e8:	3802      	subs	r0, #2
   115ea:	443c      	add	r4, r7
   115ec:	1a64      	subs	r4, r4, r1
   115ee:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
   115f2:	2100      	movs	r1, #0
   115f4:	b11e      	cbz	r6, 115fe <__udivmoddi4+0xa2>
   115f6:	40d4      	lsrs	r4, r2
   115f8:	2300      	movs	r3, #0
   115fa:	e9c6 4300 	strd	r4, r3, [r6]
   115fe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   11602:	b902      	cbnz	r2, 11606 <__udivmoddi4+0xaa>
   11604:	deff      	udf	#255	; 0xff
   11606:	fab2 f282 	clz	r2, r2
   1160a:	2a00      	cmp	r2, #0
   1160c:	d14f      	bne.n	116ae <__udivmoddi4+0x152>
   1160e:	1bcb      	subs	r3, r1, r7
   11610:	ea4f 4e17 	mov.w	lr, r7, lsr #16
   11614:	fa1f f887 	uxth.w	r8, r7
   11618:	2101      	movs	r1, #1
   1161a:	fbb3 fcfe 	udiv	ip, r3, lr
   1161e:	0c25      	lsrs	r5, r4, #16
   11620:	fb0e 331c 	mls	r3, lr, ip, r3
   11624:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
   11628:	fb08 f30c 	mul.w	r3, r8, ip
   1162c:	42ab      	cmp	r3, r5
   1162e:	d907      	bls.n	11640 <__udivmoddi4+0xe4>
   11630:	197d      	adds	r5, r7, r5
   11632:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
   11636:	d202      	bcs.n	1163e <__udivmoddi4+0xe2>
   11638:	42ab      	cmp	r3, r5
   1163a:	f200 80e7 	bhi.w	1180c <__udivmoddi4+0x2b0>
   1163e:	4684      	mov	ip, r0
   11640:	1aed      	subs	r5, r5, r3
   11642:	b2a3      	uxth	r3, r4
   11644:	fbb5 f0fe 	udiv	r0, r5, lr
   11648:	fb0e 5510 	mls	r5, lr, r0, r5
   1164c:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
   11650:	fb08 f800 	mul.w	r8, r8, r0
   11654:	45a0      	cmp	r8, r4
   11656:	d907      	bls.n	11668 <__udivmoddi4+0x10c>
   11658:	193c      	adds	r4, r7, r4
   1165a:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   1165e:	d202      	bcs.n	11666 <__udivmoddi4+0x10a>
   11660:	45a0      	cmp	r8, r4
   11662:	f200 80d7 	bhi.w	11814 <__udivmoddi4+0x2b8>
   11666:	4618      	mov	r0, r3
   11668:	eba4 0408 	sub.w	r4, r4, r8
   1166c:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
   11670:	e7c0      	b.n	115f4 <__udivmoddi4+0x98>
   11672:	428b      	cmp	r3, r1
   11674:	d908      	bls.n	11688 <__udivmoddi4+0x12c>
   11676:	2e00      	cmp	r6, #0
   11678:	f000 80af 	beq.w	117da <__udivmoddi4+0x27e>
   1167c:	2100      	movs	r1, #0
   1167e:	e9c6 0500 	strd	r0, r5, [r6]
   11682:	4608      	mov	r0, r1
   11684:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   11688:	fab3 f183 	clz	r1, r3
   1168c:	2900      	cmp	r1, #0
   1168e:	d14b      	bne.n	11728 <__udivmoddi4+0x1cc>
   11690:	42ab      	cmp	r3, r5
   11692:	d302      	bcc.n	1169a <__udivmoddi4+0x13e>
   11694:	4282      	cmp	r2, r0
   11696:	f200 80b7 	bhi.w	11808 <__udivmoddi4+0x2ac>
   1169a:	1a84      	subs	r4, r0, r2
   1169c:	eb65 0303 	sbc.w	r3, r5, r3
   116a0:	2001      	movs	r0, #1
   116a2:	469e      	mov	lr, r3
   116a4:	2e00      	cmp	r6, #0
   116a6:	d0aa      	beq.n	115fe <__udivmoddi4+0xa2>
   116a8:	e9c6 4e00 	strd	r4, lr, [r6]
   116ac:	e7a7      	b.n	115fe <__udivmoddi4+0xa2>
   116ae:	f1c2 0c20 	rsb	ip, r2, #32
   116b2:	fa01 f302 	lsl.w	r3, r1, r2
   116b6:	4097      	lsls	r7, r2
   116b8:	fa20 f00c 	lsr.w	r0, r0, ip
   116bc:	ea4f 4e17 	mov.w	lr, r7, lsr #16
   116c0:	fa21 fc0c 	lsr.w	ip, r1, ip
   116c4:	4318      	orrs	r0, r3
   116c6:	fbbc f1fe 	udiv	r1, ip, lr
   116ca:	0c05      	lsrs	r5, r0, #16
   116cc:	fb0e cc11 	mls	ip, lr, r1, ip
   116d0:	fa1f f887 	uxth.w	r8, r7
   116d4:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
   116d8:	fb01 f308 	mul.w	r3, r1, r8
   116dc:	42ab      	cmp	r3, r5
   116de:	fa04 f402 	lsl.w	r4, r4, r2
   116e2:	d909      	bls.n	116f8 <__udivmoddi4+0x19c>
   116e4:	197d      	adds	r5, r7, r5
   116e6:	f101 3cff 	add.w	ip, r1, #4294967295	; 0xffffffff
   116ea:	f080 808b 	bcs.w	11804 <__udivmoddi4+0x2a8>
   116ee:	42ab      	cmp	r3, r5
   116f0:	f240 8088 	bls.w	11804 <__udivmoddi4+0x2a8>
   116f4:	3902      	subs	r1, #2
   116f6:	443d      	add	r5, r7
   116f8:	1aeb      	subs	r3, r5, r3
   116fa:	b285      	uxth	r5, r0
   116fc:	fbb3 f0fe 	udiv	r0, r3, lr
   11700:	fb0e 3310 	mls	r3, lr, r0, r3
   11704:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
   11708:	fb00 f308 	mul.w	r3, r0, r8
   1170c:	42ab      	cmp	r3, r5
   1170e:	d907      	bls.n	11720 <__udivmoddi4+0x1c4>
   11710:	197d      	adds	r5, r7, r5
   11712:	f100 3cff 	add.w	ip, r0, #4294967295	; 0xffffffff
   11716:	d271      	bcs.n	117fc <__udivmoddi4+0x2a0>
   11718:	42ab      	cmp	r3, r5
   1171a:	d96f      	bls.n	117fc <__udivmoddi4+0x2a0>
   1171c:	3802      	subs	r0, #2
   1171e:	443d      	add	r5, r7
   11720:	1aeb      	subs	r3, r5, r3
   11722:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
   11726:	e778      	b.n	1161a <__udivmoddi4+0xbe>
   11728:	f1c1 0c20 	rsb	ip, r1, #32
   1172c:	408b      	lsls	r3, r1
   1172e:	fa22 f70c 	lsr.w	r7, r2, ip
   11732:	431f      	orrs	r7, r3
   11734:	fa20 f40c 	lsr.w	r4, r0, ip
   11738:	fa05 f301 	lsl.w	r3, r5, r1
   1173c:	ea4f 4e17 	mov.w	lr, r7, lsr #16
   11740:	fa25 f50c 	lsr.w	r5, r5, ip
   11744:	431c      	orrs	r4, r3
   11746:	0c23      	lsrs	r3, r4, #16
   11748:	fbb5 f9fe 	udiv	r9, r5, lr
   1174c:	fa1f f887 	uxth.w	r8, r7
   11750:	fb0e 5519 	mls	r5, lr, r9, r5
   11754:	ea43 4505 	orr.w	r5, r3, r5, lsl #16
   11758:	fb09 fa08 	mul.w	sl, r9, r8
   1175c:	45aa      	cmp	sl, r5
   1175e:	fa02 f201 	lsl.w	r2, r2, r1
   11762:	fa00 f301 	lsl.w	r3, r0, r1
   11766:	d908      	bls.n	1177a <__udivmoddi4+0x21e>
   11768:	197d      	adds	r5, r7, r5
   1176a:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
   1176e:	d247      	bcs.n	11800 <__udivmoddi4+0x2a4>
   11770:	45aa      	cmp	sl, r5
   11772:	d945      	bls.n	11800 <__udivmoddi4+0x2a4>
   11774:	f1a9 0902 	sub.w	r9, r9, #2
   11778:	443d      	add	r5, r7
   1177a:	eba5 050a 	sub.w	r5, r5, sl
   1177e:	b2a4      	uxth	r4, r4
   11780:	fbb5 f0fe 	udiv	r0, r5, lr
   11784:	fb0e 5510 	mls	r5, lr, r0, r5
   11788:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
   1178c:	fb00 f808 	mul.w	r8, r0, r8
   11790:	45a0      	cmp	r8, r4
   11792:	d907      	bls.n	117a4 <__udivmoddi4+0x248>
   11794:	193c      	adds	r4, r7, r4
   11796:	f100 35ff 	add.w	r5, r0, #4294967295	; 0xffffffff
   1179a:	d22d      	bcs.n	117f8 <__udivmoddi4+0x29c>
   1179c:	45a0      	cmp	r8, r4
   1179e:	d92b      	bls.n	117f8 <__udivmoddi4+0x29c>
   117a0:	3802      	subs	r0, #2
   117a2:	443c      	add	r4, r7
   117a4:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
   117a8:	eba4 0408 	sub.w	r4, r4, r8
   117ac:	fba0 8902 	umull	r8, r9, r0, r2
   117b0:	454c      	cmp	r4, r9
   117b2:	46c6      	mov	lr, r8
   117b4:	464d      	mov	r5, r9
   117b6:	d319      	bcc.n	117ec <__udivmoddi4+0x290>
   117b8:	d016      	beq.n	117e8 <__udivmoddi4+0x28c>
   117ba:	b15e      	cbz	r6, 117d4 <__udivmoddi4+0x278>
   117bc:	ebb3 020e 	subs.w	r2, r3, lr
   117c0:	eb64 0405 	sbc.w	r4, r4, r5
   117c4:	fa04 fc0c 	lsl.w	ip, r4, ip
   117c8:	40ca      	lsrs	r2, r1
   117ca:	ea4c 0202 	orr.w	r2, ip, r2
   117ce:	40cc      	lsrs	r4, r1
   117d0:	e9c6 2400 	strd	r2, r4, [r6]
   117d4:	2100      	movs	r1, #0
   117d6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   117da:	4631      	mov	r1, r6
   117dc:	4630      	mov	r0, r6
   117de:	e70e      	b.n	115fe <__udivmoddi4+0xa2>
   117e0:	46ac      	mov	ip, r5
   117e2:	e6ed      	b.n	115c0 <__udivmoddi4+0x64>
   117e4:	4618      	mov	r0, r3
   117e6:	e701      	b.n	115ec <__udivmoddi4+0x90>
   117e8:	4543      	cmp	r3, r8
   117ea:	d2e6      	bcs.n	117ba <__udivmoddi4+0x25e>
   117ec:	ebb8 0e02 	subs.w	lr, r8, r2
   117f0:	eb69 0507 	sbc.w	r5, r9, r7
   117f4:	3801      	subs	r0, #1
   117f6:	e7e0      	b.n	117ba <__udivmoddi4+0x25e>
   117f8:	4628      	mov	r0, r5
   117fa:	e7d3      	b.n	117a4 <__udivmoddi4+0x248>
   117fc:	4660      	mov	r0, ip
   117fe:	e78f      	b.n	11720 <__udivmoddi4+0x1c4>
   11800:	4681      	mov	r9, r0
   11802:	e7ba      	b.n	1177a <__udivmoddi4+0x21e>
   11804:	4661      	mov	r1, ip
   11806:	e777      	b.n	116f8 <__udivmoddi4+0x19c>
   11808:	4608      	mov	r0, r1
   1180a:	e74b      	b.n	116a4 <__udivmoddi4+0x148>
   1180c:	f1ac 0c02 	sub.w	ip, ip, #2
   11810:	443d      	add	r5, r7
   11812:	e715      	b.n	11640 <__udivmoddi4+0xe4>
   11814:	3802      	subs	r0, #2
   11816:	443c      	add	r4, r7
   11818:	e726      	b.n	11668 <__udivmoddi4+0x10c>
   1181a:	bf00      	nop

0001181c <__aeabi_idiv0>:
   1181c:	4770      	bx	lr
   1181e:	bf00      	nop

00011820 <__init_array_end>:
   11820:	6c6c6548 	.word	0x6c6c6548
   11824:	6f77206f 	.word	0x6f77206f
   11828:	21646c72 	.word	0x21646c72
   1182c:	0000000a 	.word	0x0000000a
   11830:	65737341 	.word	0x65737341
   11834:	40207472 	.word	0x40207472
   11838:	25783020 	.word	0x25783020
   1183c:	00000a78 	.word	0x00000a78
   11840:	65737341 	.word	0x65737341
   11844:	40207472 	.word	0x40207472
   11848:	25783020 	.word	0x25783020
   1184c:	202d2078 	.word	0x202d2078
   11850:	253a7325 	.word	0x253a7325
   11854:	00000a64 	.word	0x00000a64
   11858:	61686e55 	.word	0x61686e55
   1185c:	656c646e 	.word	0x656c646e
   11860:	6e692064 	.word	0x6e692064
   11864:	72726574 	.word	0x72726574
   11868:	20747075 	.word	0x20747075
   1186c:	646c2528 	.word	0x646c2528
   11870:	65202c29 	.word	0x65202c29
   11874:	70656378 	.word	0x70656378
   11878:	6e6f6974 	.word	0x6e6f6974
   1187c:	20707320 	.word	0x20707320
   11880:	30257830 	.word	0x30257830
   11884:	0a786c38 	.word	0x0a786c38
   11888:	00000000 	.word	0x00000000
   1188c:	3a307220 	.word	0x3a307220
   11890:	30257830 	.word	0x30257830
   11894:	20786c38 	.word	0x20786c38
   11898:	3a317220 	.word	0x3a317220
   1189c:	30257830 	.word	0x30257830
   118a0:	20786c38 	.word	0x20786c38
   118a4:	3a327220 	.word	0x3a327220
   118a8:	30257830 	.word	0x30257830
   118ac:	20786c38 	.word	0x20786c38
   118b0:	3a337220 	.word	0x3a337220
   118b4:	30257830 	.word	0x30257830
   118b8:	0a786c38 	.word	0x0a786c38
   118bc:	00000000 	.word	0x00000000
   118c0:	3a347220 	.word	0x3a347220
   118c4:	30257830 	.word	0x30257830
   118c8:	20786c38 	.word	0x20786c38
   118cc:	3a357220 	.word	0x3a357220
   118d0:	30257830 	.word	0x30257830
   118d4:	20786c38 	.word	0x20786c38
   118d8:	3a367220 	.word	0x3a367220
   118dc:	30257830 	.word	0x30257830
   118e0:	20786c38 	.word	0x20786c38
   118e4:	3a377220 	.word	0x3a377220
   118e8:	30257830 	.word	0x30257830
   118ec:	0a786c38 	.word	0x0a786c38
   118f0:	00000000 	.word	0x00000000
   118f4:	3a387220 	.word	0x3a387220
   118f8:	30257830 	.word	0x30257830
   118fc:	20786c38 	.word	0x20786c38
   11900:	3a397220 	.word	0x3a397220
   11904:	30257830 	.word	0x30257830
   11908:	20786c38 	.word	0x20786c38
   1190c:	3a303172 	.word	0x3a303172
   11910:	30257830 	.word	0x30257830
   11914:	20786c38 	.word	0x20786c38
   11918:	3a313172 	.word	0x3a313172
   1191c:	30257830 	.word	0x30257830
   11920:	0a786c38 	.word	0x0a786c38
   11924:	00000000 	.word	0x00000000
   11928:	3a323172 	.word	0x3a323172
   1192c:	30257830 	.word	0x30257830
   11930:	20786c38 	.word	0x20786c38
   11934:	3a726c20 	.word	0x3a726c20
   11938:	30257830 	.word	0x30257830
   1193c:	20786c38 	.word	0x20786c38
   11940:	3a637020 	.word	0x3a637020
   11944:	30257830 	.word	0x30257830
   11948:	20786c38 	.word	0x20786c38
   1194c:	3a727370 	.word	0x3a727370
   11950:	30257830 	.word	0x30257830
   11954:	0a786c38 	.word	0x0a786c38
   11958:	00000000 	.word	0x00000000
   1195c:	52534349 	.word	0x52534349
   11960:	2578303a 	.word	0x2578303a
   11964:	786c3830 	.word	0x786c3830
   11968:	53464820 	.word	0x53464820
   1196c:	78303a52 	.word	0x78303a52
   11970:	6c383025 	.word	0x6c383025
   11974:	46432078 	.word	0x46432078
   11978:	303a5253 	.word	0x303a5253
   1197c:	38302578 	.word	0x38302578
   11980:	000a786c 	.word	0x000a786c
   11984:	52414642 	.word	0x52414642
   11988:	2578303a 	.word	0x2578303a
   1198c:	786c3830 	.word	0x786c3830
   11990:	464d4d20 	.word	0x464d4d20
   11994:	303a5241 	.word	0x303a5241
   11998:	38302578 	.word	0x38302578
   1199c:	000a786c 	.word	0x000a786c
   119a0:	656c6469 	.word	0x656c6469
   119a4:	00000000 	.word	0x00000000
   119a8:	6e69616d 	.word	0x6e69616d
   119ac:	00000000 	.word	0x00000000
   119b0:	7379736d 	.word	0x7379736d
   119b4:	0000315f 	.word	0x0000315f
   119b8:	6c363025 	.word	0x6c363025
   119bc:	00002075 	.word	0x00002075
   119c0:	74726175 	.word	0x74726175
   119c4:	00000030 	.word	0x00000030
   119c8:	3d73745b 	.word	0x3d73745b
   119cc:	756c6c25 	.word	0x756c6c25
   119d0:	202c7375 	.word	0x202c7375
   119d4:	3d646f6d 	.word	0x3d646f6d
   119d8:	6c207525 	.word	0x6c207525
   119dc:	6c657665 	.word	0x6c657665
   119e0:	2075253d 	.word	0x2075253d
   119e4:	00000000 	.word	0x00000000
   119e8:	303d6869 	.word	0x303d6869
   119ec:	25782578 	.word	0x25782578
   119f0:	25782578 	.word	0x25782578
   119f4:	00000078 	.word	0x00000078
   119f8:	0000005d 	.word	0x0000005d
   119fc:	736e6f63 	.word	0x736e6f63
   11a00:	00656c6f 	.word	0x00656c6f

00011a04 <log_console_handler>:
   11a04:	00000000 0000e7e9 00000000 0000e8c5     ................
   11a14:	0000e885 00000000 00000000 0000e7ed     ................
   11a24:	00000000 0000e7f1 00000000 6c646f6d     ............modl
   11a34:	6d5f676f 69707061 705f676e 006c6f6f     og_mapping_pool.

00011a44 <sysflash_map_dflt>:
	...
   11a4c:	00008000 00000001 0000c000 00076000     .............`..
   11a5c:	00000002 00082000 00076000 00000003     ..... ...`......
   11a6c:	000f8000 00004000 00000010 00008000     .....@..........
   11a7c:	00004000 00000011 000fc000 00004000     .@...........@..
   11a8c:	68323025 00007868 00006325 0063255c     %02hhx..%c..\%c.
   11a9c:	3025755c 5c586c34 34302575 0000586c     \u%04lX\u%04lX..
   11aac:	3025755c 00586c34 0000007b 0000005b     \u%04lX.{...[...
   11abc:	0000007d 736c6166 00000065 65757274     }...false...true
   11acc:	00000000 0000205f 756c6c25 00000000     ...._ ..%llu....
   11adc:	6c6c252d 00000075 3438312d 34373634     -%llu...-1844674
   11aec:	33373034 35393037 31363135 00000036     4073709551616...
   11afc:	00002768 00000027 00000022 756c6c25     h'..'..."...%llu
   11b0c:	00000028 00000029 706d6973 2528656c     (...)...simple(%
   11b1c:	29756868 00000000 6c6c756e 00000000     hhu)....null....
   11b2c:	65646e75 656e6966 00000064 61766e69     undefined...inva
   11b3c:	0064696c 0000202c 00007325 0000203a     lid., ..%s..: ..

00011b4c <nrf52k_flash_dev>:
   11b4c:	00011b64 00000000 00100000 00000100     d...............
   11b5c:	00000001 000000ff                       ........

00011b64 <nrf52k_flash_funcs>:
   11b64:	0000fdbd 0000fcf5 0000fc79 0000fccd     ........y.......
   11b74:	00000000 0000fcc9 00000000              ............

00011b80 <os_bsp_uart0_cfg>:
   11b80:	07050806                                ....

00011b84 <nrf52_hal_timers>:
   11b84:	200023bc 00000000 00000000 00000000     .#. ............
	...

00011b9c <stdout>:
   11b9c:	20000154                                T.. 

/Users/tianzeng/Documents/workspace/playground/bin/targets/nrf52_blinky/app/apps/blinky/blinky.elf:     file format elf32-littlearm

arm-none-eabi-objdump: section '.rodata' mentioned in a -j option, but not found in any input file
   text	   data	    bss	    dec	    hex	filename
  23448	     96	   9172	  32716	   7fcc	/Users/tianzeng/Documents/workspace/playground/bin/targets/nrf52_blinky/app/apps/blinky/blinky.elf
